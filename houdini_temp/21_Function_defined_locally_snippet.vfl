// Here we define a function locally just for use inside this node


// this test function demonstrates how multiple outputs can be handled at once using export
vector testFunction(
                int myInt;
                float myFloat;
                vector2 myVector2;
                vector myVector3;
                vector4 myVector4;
                export int exInt; // exports mean that they will carry to computation outside
                export float exFloat;
                export vector2 exVector2;
                export vector exVector3;
                export vector4 exVector4;
                ) {
        // just scale every single value by two
        exInt = 2*myInt;
        exFloat = 2*myFloat;
        exVector2 = 2*myVector2;
        exVector3 = 2*myVector3;
        exVector3 = 2*myVector3;
        exVector4 = 2*myVector4;
        
        // and return the vector3 as an example. You could also make this function void to not return anything
        return exVector3;
}


// let us play around with the function
// inside this example

int testInt;
vector test = testFunction(
    1, // an int
    2.0, // a float
    set(3.0,4), // a vector2    
    set(5.0,6.0,7), // a vector3
    set(8,9.0,10,11.0), // a vector4
    testInt, // reciever of an int
    f@testFloat, // direct writing into float attrib.
    u@testVector2, // writing into vector2 attrib.
    v@testVector3, // writing into vector attrib.
    p@testVector4); // writing into vector4 attrib.

// and copy testInt to attribute to see that this works
i@testInt = testInt;

// and check the output with the vector 3
f@difference = length(test - v@testVector3);

// now check the geometry spreadsheet if everything arrived well
