//printf("%i", i@numpt); // 210

if (!i@giveup) {
  int rules[] = {};
  resize(rules, npoints(1));
  for (int i=0; i<npoints(1); ++i) {
    rules[i] = int(point(1, 'islegal', i)); // 0 or 1
  }

  vector dirs[] = {
    {0, 0, -1}, // up 0
    {1, 0, 0},  // right 1
    {0, 0, 1},  // down 2
    {-1, 0, 0}, // left 3
    {0, -1, 0}, // bottom 4
    {0, 1, 0}   // top 5
  };
  int ncollapsed = 0;
  for (int i=0; i<i@numpt; ++i) {
    int px =  i % i@cols;
    int py =  i / (i@cols*i@rows);
    int pz =  (i-px-i@cols*i@rows*py)/i@cols; // x+35y+5z = ptnum
    int cor[] = array(px, py, pz); // 3d coordinates of each ptnum
    //printf("%i \n", cor);
    int ptlegal[] = point(0, 'legal', i); // [0,1,...14]
    int pttile   = point(0, 'tile', i); //

    // found conflict
    if (len(ptlegal)==0 && pttile==-1) {
      i@giveup = 1;
      setpointgroup(0, 'badpt', i, 1);
      setpointattrib(0, 'Cd', i, {1,0,0});
      break;
    } else if (pttile>=0) {
      ++ncollapsed;
    }

    // look around
    // find the neighbor point number in each direction
    for (int didx=0; didx<6; ++didx) {
      int dx = int(dirs[didx].x);
      int dy = int(dirs[didx].y);
      int dz = int(dirs[didx].z);
      if (px+dx<0 || px+dx>=i@cols)
        continue;
      if (py+dy<0 || py+dy>=i@height)
        continue;
      if (pz+dz<0 || pz+dz>=i@rows)
        continue;
      

      int neighborpt = (dx+px) + i@cols*i@rows*(dy+py) + i@cols*(dz+pz); //neighbor point number in certain direction
      int pair[] = array(i, neighborpt);
      //printf("%i \n", pair);
      int neighbor = point(0, 'tile', neighborpt);
      // if neighbor's tile is determined
      if (neighbor>=0) { // determinded
        int impossible[]={}; // impossible tiles
        foreach(int candidate; ptlegal) {
          if (rules[candidate+i@ntiles*6*neighbor+i@ntiles*didx] == 0) { // [tileA][tileB][direction]
            if (find(impossible, candidate)<0) { //Finds an item in an array or string.return negative number if not found
              append(impossible, candidate);
            }
          }
        }
        foreach(int imp; impossible) {
          removevalue(ptlegal, imp);
        }
      }
    } // for each direction
    setpointattrib(0, 'legal', i, ptlegal);
  } // for each point

  // finished
  if (ncollapsed == npoints(0)) {
    i@giveup = 1;
  }
} // giveup
