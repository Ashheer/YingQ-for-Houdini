;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [9 x i8] c"usamples\00"
@1 = private constant [16 x i8] c"bypasslastpassu\00"
@2 = private constant [9 x i8] c"vsamples\00"
@3 = private constant [16 x i8] c"bypasslastpassv\00"
@4 = private constant [16 x i8] c"bypasslastpassw\00"
@5 = private constant [9 x i8] c"wsamples\00"
@6 = private constant [5 x i8] c"umin\00"
@7 = private constant [5 x i8] c"umax\00"
@8 = private constant [9 x i8] c"umultipi\00"
@9 = private constant [5 x i8] c"vmin\00"
@10 = private constant [5 x i8] c"vmax\00"
@11 = private constant [9 x i8] c"vmultipi\00"
@12 = private constant [5 x i8] c"wmin\00"
@13 = private constant [5 x i8] c"wmax\00"
@14 = private constant [9 x i8] c"wmultipi\00"
@15 = private constant [6 x i8] c"../m1\00"
@16 = private constant [5 x i8] c"../a\00"
@17 = private constant [6 x i8] c"../n2\00"
@18 = private constant [6 x i8] c"../m2\00"
@19 = private constant [5 x i8] c"../b\00"
@20 = private constant [6 x i8] c"../n3\00"
@21 = private constant [6 x i8] c"../n1\00"
@22 = private constant [8 x i8] c"../type\00"
@ptnum = external global i64
@P = external global <3 x double>
@23 = private constant [6 x i8] c"ptnum\00"
@24 = private constant [2 x i8] c"P\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@IV"(i64* %_bound_ptnum, <3 x double>* %_bound_P) #0 {
__llvm_entry:
  %0 = alloca double
  %1 = alloca double
  %_bound_ptnum1 = load i64, i64* %_bound_ptnum
  %return = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @0, i64 0, i64 0))
  %return2 = call i64 @"mod@III"(i64 %_bound_ptnum1, i64 %return)
  %cast = sitofp i64 %return2 to double
  %return3 = call i64 @"chi@IS"(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @1, i64 0, i64 0))
  %2 = icmp ne i64 %return3, 0
  %return5 = call double @"chf@FS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @0, i64 0, i64 0))
  br i1 %2, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %output = call double @"div@FF"(double %cast, double %return5)
  br label %end

false:                                            ; preds = %__llvm_entry
  %output8 = fsub double %return5, 1.000000e+00
  %output9 = call double @"div@FF"(double %cast, double %output8)
  br label %end

end:                                              ; preds = %false, %true
  %u.0 = phi double [ %output, %true ], [ %output9, %false ]
  %_bound_ptnum10 = load i64, i64* %_bound_ptnum
  %output12 = call i64 @"div@II"(i64 %_bound_ptnum10, i64 %return)
  %return13 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @2, i64 0, i64 0))
  %return14 = call i64 @"mod@III"(i64 %output12, i64 %return13)
  %cast15 = sitofp i64 %return14 to double
  %return16 = call i64 @"chi@IS"(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @3, i64 0, i64 0))
  %3 = icmp ne i64 %return16, 0
  %return21 = call double @"chf@FS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @2, i64 0, i64 0))
  br i1 %3, label %true17, label %false18

true17:                                           ; preds = %end
  %output22 = call double @"div@FF"(double %cast15, double %return21)
  br label %end19

false18:                                          ; preds = %end
  %output25 = fsub double %return21, 1.000000e+00
  %output26 = call double @"div@FF"(double %cast15, double %output25)
  br label %end19

end19:                                            ; preds = %false18, %true17
  %v.0 = phi double [ %output22, %true17 ], [ %output26, %false18 ]
  %_bound_ptnum27 = load i64, i64* %_bound_ptnum
  %output30 = mul i64 %return, %return13
  %output31 = call i64 @"div@II"(i64 %_bound_ptnum27, i64 %output30)
  %cast32 = sitofp i64 %output31 to double
  %return33 = call i64 @"chi@IS"(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @4, i64 0, i64 0))
  %4 = icmp ne i64 %return33, 0
  %return38 = call double @"chf@FS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @5, i64 0, i64 0))
  br i1 %4, label %true34, label %false35

true34:                                           ; preds = %end19
  %output39 = call double @"div@FF"(double %cast32, double %return38)
  br label %end36

false35:                                          ; preds = %end19
  %output42 = fsub double %return38, 1.000000e+00
  %output43 = call double @"div@FF"(double %cast32, double %output42)
  br label %end36

end36:                                            ; preds = %false35, %true34
  %w.0 = phi double [ %output39, %true34 ], [ %output43, %false35 ]
  %return45 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @6, i64 0, i64 0))
  %return46 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @7, i64 0, i64 0))
  %return47 = call double @"fit01@FFFF"(double %u.0, double %return45, double %return46)
  %return48 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @8, i64 0, i64 0))
  %5 = icmp ne i64 %return48, 0
  %return49 = select i1 %5, double 0x400921FB4D12D84A, double 1.000000e+00
  %output50 = fmul double %return47, %return49
  %return52 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @9, i64 0, i64 0))
  %return53 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @10, i64 0, i64 0))
  %return54 = call double @"fit01@FFFF"(double %v.0, double %return52, double %return53)
  %return55 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @11, i64 0, i64 0))
  %6 = icmp ne i64 %return55, 0
  %return56 = select i1 %6, double 0x400921FB4D12D84A, double 1.000000e+00
  %output57 = fmul double %return54, %return56
  %return59 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @12, i64 0, i64 0))
  %return60 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @13, i64 0, i64 0))
  %return61 = call double @"fit01@FFFF"(double %w.0, double %return59, double %return60)
  %return62 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @14, i64 0, i64 0))
  %7 = icmp ne i64 %return62, 0
  %return65 = call i64 @"chi@IS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @22, i64 0, i64 0))
  %8 = icmp ne i64 %return65, 0
  store double %output50, double* %0
  %superformula = call double @"superformula@FF"(double* %0)
  br i1 %8, label %true66, label %end68

true66:                                           ; preds = %end36
  store double %output57, double* %1
  %superformula71 = call double @"superformula@FF"(double* %1)
  %output74 = fmul double %superformula, %superformula71
  %return76 = call double @"cos@FF"(double %output57)
  %output77 = fmul double %output74, %return76
  br label %end68

end68:                                            ; preds = %end36, %true66
  %b.0 = phi double [ %superformula71, %true66 ], [ 0.000000e+00, %end36 ]
  %abcosv.0 = phi double [ %output77, %true66 ], [ 0.000000e+00, %end36 ]
  %return83 = call double @"cos@FF"(double %output50)
  %output84 = fmul double %abcosv.0, %return83
  %output88 = fmul double %superformula, %return83
  %return89 = select i1 %8, double %output84, double %output88
  %tmp = load <3 x double>, <3 x double>* %_bound_P
  %return90 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %tmp, double %return89, i64 0)
  %output92 = extractvalue { double, <3 x double> } %return90, 1
  store <3 x double> %output92, <3 x double>* %_bound_P
  %return96 = call double @"sin@FF"(double %output57)
  %output97 = fmul double %b.0, %return96
  %return98 = select i1 %8, double %output97, double 0.000000e+00
  %return100 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %output92, double %return98, i64 1)
  %output102 = extractvalue { double, <3 x double> } %return100, 1
  store <3 x double> %output102, <3 x double>* %_bound_P
  %return106 = call double @"sin@FF"(double %output50)
  %output107 = fmul double %abcosv.0, %return106
  %output111 = fmul double %superformula, %return106
  %return112 = select i1 %8, double %output107, double %output111
  %return114 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %output102, double %return112, i64 2)
  %output116 = extractvalue { double, <3 x double> } %return114, 1
  store <3 x double> %output116, <3 x double>* %_bound_P
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"mod@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #1

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: nounwind readnone
declare i64 @"div@II"(i64, i64) #1

; Function Attrs: nounwind
declare double @"fit01@FFFF"(double, double, double) #2

; Function Attrs: alwaysinline nounwind
define private double @"superformula@FF"(double* %x) #0 {
__llvm_entry:
  %return = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @15, i64 0, i64 0))
  %output = call double @"div@FF"(double %return, double 4.000000e+00)
  %x1 = load double, double* %x
  %output2 = fmul double %output, %x1
  %return3 = call double @"cos@FF"(double %output2)
  %return4 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @16, i64 0, i64 0))
  %output5 = call double @"div@FF"(double %return3, double %return4)
  %return6 = call double @"abs@FF"(double %output5)
  %return7 = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @17, i64 0, i64 0))
  %return8 = call double @"pow@FFF"(double %return6, double %return7)
  %return9 = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @18, i64 0, i64 0))
  %output10 = call double @"div@FF"(double %return9, double 4.000000e+00)
  %x11 = load double, double* %x
  %output12 = fmul double %output10, %x11
  %return13 = call double @"sin@FF"(double %output12)
  %return14 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @19, i64 0, i64 0))
  %output15 = call double @"div@FF"(double %return13, double %return14)
  %return16 = call double @"abs@FF"(double %output15)
  %return17 = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @20, i64 0, i64 0))
  %return18 = call double @"pow@FFF"(double %return16, double %return17)
  %output19 = fadd double %return8, %return18
  %return20 = call i64 @"neg@II"(i64 1)
  %return21 = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @21, i64 0, i64 0))
  %cast = sitofp i64 %return20 to double
  %output22 = call double @"div@FF"(double %cast, double %return21)
  %return23 = call double @"pow@FFF"(double %output19, double %output22)
  ret double %return23
}

; Function Attrs: nounwind readnone
declare double @"cos@FF"(double) #1

; Function Attrs: nounwind
declare double @"abs@FF"(double) #2

; Function Attrs: nounwind readnone
declare double @"pow@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare double @"sin@FF"(double) #1

; Function Attrs: nounwind readnone
declare i64 @"neg@II"(i64) #1

; Function Attrs: alwaysinline
define private { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %rw11, double %rw22, i64 %rw33) #3 {
__llvm_entry:
  %rw16 = call <3 x double> @"setcomp@VFI"(<3 x double> %rw11, double %rw22, i64 %rw33)
  %mrv = insertvalue { double, <3 x double> } undef, double %rw22, 0
  %mrv9 = insertvalue { double, <3 x double> } %mrv, <3 x double> %rw16, 1
  ret { double, <3 x double> } %mrv9
}

; Function Attrs: nounwind readnone
declare <3 x double> @"setcomp@VFI"(<3 x double>, double, i64) #1

; Function Attrs: nounwind
define void @__vex_snippet(i64 %ptnum, <3 x double> %P) #2 {
__llvm_entry:
  %"<P>" = alloca <3 x double>
  %0 = alloca i64
  store <3 x double> %P, <3 x double>* %"<P>"
  store i64 %ptnum, i64* %0
  call void @"__vex_snippet_snippet@IV"(i64* %0, <3 x double>* %"<P>")
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @23, i64 0, i64 0), i64 %ptnum) #4
  %evalue2 = load <3 x double>, <3 x double>* %"<P>"
  %gvalue3 = call <3 x double> @"_export@VSV"(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @24, i64 0, i64 0), <3 x double> %evalue2) #4
  store i64 %gvalue, i64* @ptnum
  store <3 x double> %gvalue3, <3 x double>* @P
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

declare <3 x double> @"_export@VSV"(i8*, <3 x double>)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0, <3 x double> zeroinitializer)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { alwaysinline }
attributes #4 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.531"}
!2 = !{!"64"}

;_code_end
