;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [7 x i8] c"attach\00"
@1 = private constant [4 x i8] c"pin\00"
@2 = private constant [7 x i8] c"stitch\00"
@3 = private constant [13 x i8] c"branchstitch\00"
@4 = private constant [9 x i8] c"distance\00"
@5 = private constant [13 x i8] c"attachnormal\00"
@6 = private constant [13 x i8] c"distanceline\00"
@7 = private constant [1 x i8] zeroinitializer
@8 = private constant [13 x i8] c"stretchshear\00"
@9 = private constant [5 x i8] c"weld\00"
@10 = private constant [7 x i8] c"ptprim\00"
@11 = private constant [0 x i64] zeroinitializer
@12 = private constant [7 x i8] c"attrib\00"
@13 = private constant [12 x i8] c"attribvalue\00"
@14 = private constant [7 x i8] c"source\00"
@15 = private constant [7 x i8] c"target\00"
@16 = private constant [4 x i8] c"min\00"
@17 = private constant [5 x i8] c"mult\00"
@18 = private constant [5 x i8] c"mean\00"
@19 = private constant [4 x i8] c"max\00"
@20 = private constant [6 x i8] c"value\00"
@21 = private constant [14 x i8] c"attribpromote\00"
@22 = private constant [13 x i8] c"stiffnessexp\00"
@23 = private constant [13 x i8] c"doanisotropy\00"
@24 = private constant [11 x i8] c"warp_scale\00"
@25 = private constant [11 x i8] c"weft_scale\00"
@26 = private constant [12 x i8] c"shear_scale\00"
@27 = private constant [11 x i8] c"materialuv\00"
@28 = private constant [10 x i8] c"stiffattr\00"
@29 = private constant [9 x i8] c"stiffval\00"
@30 = private constant [10 x i8] c"stiffmode\00"
@31 = private constant [9 x i8] c"dampattr\00"
@32 = private constant [8 x i8] c"dampval\00"
@33 = private constant [9 x i8] c"dampmode\00"
@34 = private constant [11 x i8] c"plasticity\00"
@35 = private constant [11 x i8] c"threshattr\00"
@36 = private constant [10 x i8] c"threshval\00"
@37 = private constant [11 x i8] c"threshmode\00"
@38 = private constant [9 x i8] c"rateattr\00"
@39 = private constant [8 x i8] c"rateval\00"
@40 = private constant [9 x i8] c"ratemode\00"
@41 = private constant [9 x i8] c"hardattr\00"
@42 = private constant [8 x i8] c"hardval\00"
@43 = private constant [9 x i8] c"hardmode\00"
@stiffness = external global double
@dampingratio = external global double
@plasticthreshold = external global double
@plasticrate = external global double
@plastichardening = external global double
@44 = private constant [10 x i8] c"stiffness\00"
@45 = private constant [13 x i8] c"dampingratio\00"
@46 = private constant [17 x i8] c"plasticthreshold\00"
@47 = private constant [12 x i8] c"plasticrate\00"
@48 = private constant [17 x i8] c"plastichardening\00"

; Function Attrs: alwaysinline nounwind
define private i8* @"constraintAlias@SS"(i8** %type) #0 {
__llvm_entry:
  %type1 = load i8*, i8** %type
  %return = call i64 @"eq@ISS"(i8* %type1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @0, i64 0, i64 0))
  %0 = icmp ne i64 %return, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %end8, %end, %__llvm_entry
  %merge = phi i8* [ getelementptr inbounds ([4 x i8], [4 x i8]* @1, i64 0, i64 0), %__llvm_entry ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @4, i64 0, i64 0), %end ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @6, i64 0, i64 0), %end8 ]
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  %return3 = call i64 @"eq@ISS"(i8* %type1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @2, i64 0, i64 0))
  %return5 = call i64 @"eq@ISS"(i8* %type1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @3, i64 0, i64 0))
  %return6 = call i64 @"or@III"(i64 %return3, i64 %return5)
  %1 = icmp ne i64 %return6, 0
  br i1 %1, label %true, label %end8

end8:                                             ; preds = %end
  %return10 = call i64 @"eq@ISS"(i8* %type1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @5, i64 0, i64 0))
  %2 = icmp ne i64 %return10, 0
  br i1 %2, label %true, label %end12

end12:                                            ; preds = %end8
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end12, %true
  %UnifiedRetVal = phi i8* [ %merge, %true ], [ %type1, %end12 ]
  ret i8* %UnifiedRetVal
}

; Function Attrs: nounwind readnone
declare i64 @"eq@ISS"(i8*, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #1

; Function Attrs: alwaysinline nounwind
define private double @"logscaleStiffness@FFF"(double* %k, double* %stiffness) #0 {
__llvm_entry:
  %k1 = load double, double* %k
  %stiffness2 = load double, double* %stiffness
  %output = fadd double %stiffness2, 1.000000e+00
  %return = call double @"log@FF"(double %output)
  %output3 = fmul double %k1, %return
  %return4 = call double @"exp@FF"(double %output3)
  %output5 = fsub double %return4, 1.000000e+00
  %return6 = call double @"clamp@FFFF"(double %output5, double 0.000000e+00, double 1.000000e+37)
  ret double %return6
}

; Function Attrs: nounwind readnone
declare double @"log@FF"(double) #1

; Function Attrs: nounwind readnone
declare double @"exp@FF"(double) #1

; Function Attrs: nounwind
declare double @"clamp@FFFF"(double, double, double) #2

; Function Attrs: alwaysinline nounwind
define private i64* @"getSourcePoints@[IS[I"(i8** %intype, i64** %pts) #0 {
__llvm_entry:
  %0 = alloca i8*
  %intype1 = load i8*, i8** %intype
  store i8* %intype1, i8** %0
  %constraintAlias = call i8* @"constraintAlias@SS"(i8** %0)
  %return = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @4, i64 0, i64 0))
  %return4 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @8, i64 0, i64 0))
  %return5 = call i64 @"or@III"(i64 %return, i64 %return4)
  %return7 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @9, i64 0, i64 0))
  %return8 = call i64 @"or@III"(i64 %return5, i64 %return7)
  %return10 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @10, i64 0, i64 0))
  %return11 = call i64 @"or@III"(i64 %return8, i64 %return10)
  %1 = icmp ne i64 %return11, 0
  %pts12 = load i64*, i64** %pts
  br i1 %1, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %return13 = call i64* @"slice@[I[IIIIIII"(i64* %pts12, i64 0, i64 0, i64 1, i64 1, i64 0, i64 0)
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end, %true
  %UnifiedRetVal = phi i64* [ %return13, %true ], [ %pts12, %end ]
  ret i64* %UnifiedRetVal
}

; Function Attrs: nounwind
declare i64* @"slice@[I[IIIIIII"(i64*, i64, i64, i64, i64, i64, i64) #2

; Function Attrs: alwaysinline nounwind
define private i64* @"getTargetPoints@[IS[I"(i8** %intype, i64** %pts) #0 {
__llvm_entry:
  %0 = alloca i8*
  %intype1 = load i8*, i8** %intype
  store i8* %intype1, i8** %0
  %constraintAlias = call i8* @"constraintAlias@SS"(i8** %0)
  %return = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @4, i64 0, i64 0))
  %return4 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @8, i64 0, i64 0))
  %return5 = call i64 @"or@III"(i64 %return, i64 %return4)
  %return7 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @9, i64 0, i64 0))
  %return8 = call i64 @"or@III"(i64 %return5, i64 %return7)
  %return10 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @10, i64 0, i64 0))
  %return11 = call i64 @"or@III"(i64 %return8, i64 %return10)
  %1 = icmp ne i64 %return11, 0
  br i1 %1, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %pts12 = load i64*, i64** %pts
  %return13 = call i64* @"slice@[I[IIIIIII"(i64* %pts12, i64 1, i64 1, i64 0, i64 0, i64 0, i64 0)
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end, %true
  %UnifiedRetVal = phi i64* [ %return13, %true ], [ getelementptr inbounds ([0 x i64], [0 x i64]* @11, i64 0, i64 0), %end ]
  ret i64* %UnifiedRetVal
}

; Function Attrs: alwaysinline nounwind
define private double @"accumScaleValues@FSI[ISIVSFSS"(i8** %type, i64* %ptgeo, i64** %inpts, i8** %primgeo, i64* %targetprim, <3 x double>* %uv, i8** %attr, double* %valscale, i8** %scalemode, i8** %promotion) #0 {
__llvm_entry:
  %0 = alloca i8*
  %1 = alloca i64*
  %2 = alloca i8*
  %3 = alloca i64*
  %scalemode1 = load i8*, i8** %scalemode
  %return = call i64 @"eq@ISS"(i8* %scalemode1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @12, i64 0, i64 0))
  %return3 = call i64 @"eq@ISS"(i8* %scalemode1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @13, i64 0, i64 0))
  %return4 = call i64 @"or@III"(i64 %return, i64 %return3)
  %4 = icmp ne i64 %return4, 0
  br i1 %4, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %inpts5 = load i64*, i64** %inpts
  %promotion6 = load i8*, i8** %promotion
  %return7 = call i64 @"eq@ISS"(i8* %promotion6, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @14, i64 0, i64 0))
  %5 = icmp ne i64 %return7, 0
  br i1 %5, label %true8, label %end9

end:                                              ; preds = %false136, %true143, %true135, %true127, %true116, %end30, %__llvm_entry
  %div.0 = phi i64 [ %output124, %true116 ], [ 1, %true127 ], [ 1, %true135 ], [ 1, %true143 ], [ %div.1, %false136 ], [ %div.1, %end30 ], [ 0, %__llvm_entry ]
  %attrscale.0 = phi double [ %output121, %true116 ], [ %return132, %true127 ], [ %return140, %true135 ], [ %output147, %true143 ], [ %attrscale.3, %false136 ], [ %attrscale.3, %end30 ], [ 0.000000e+00, %__llvm_entry ]
  %return149 = call i64 @"gt@III"(i64 %div.0, i64 0)
  %6 = icmp ne i64 %return149, 0
  br i1 %6, label %true150, label %end151

true8:                                            ; preds = %true
  %type10 = load i8*, i8** %type
  store i8* %type10, i8** %0
  %inpts11 = load i64*, i64** %inpts
  store i64* %inpts11, i64** %1
  %getSourcePoints = call i64* @"getSourcePoints@[IS[I"(i8** %0, i64** %1)
  br label %end9

end9:                                             ; preds = %true8, %true
  %pts.0 = phi i64* [ %getSourcePoints, %true8 ], [ %inpts5, %true ]
  %promotion12 = load i8*, i8** %promotion
  %return13 = call i64 @"eq@ISS"(i8* %promotion12, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @15, i64 0, i64 0))
  %7 = icmp ne i64 %return13, 0
  br i1 %7, label %true14, label %end15

true14:                                           ; preds = %end9
  %type16 = load i8*, i8** %type
  store i8* %type16, i8** %2
  %inpts17 = load i64*, i64** %inpts
  store i64* %inpts17, i64** %3
  %getTargetPoints = call i64* @"getTargetPoints@[IS[I"(i8** %2, i64** %3)
  br label %end15

end15:                                            ; preds = %true14, %end9
  %pts.1 = phi i64* [ %getTargetPoints, %true14 ], [ %pts.0, %end9 ]
  %promotion18 = load i8*, i8** %promotion
  %return19 = call i64 @"eq@ISS"(i8* %promotion18, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @16, i64 0, i64 0))
  %8 = icmp ne i64 %return19, 0
  br i1 %8, label %true20, label %end21

true20:                                           ; preds = %end15
  br label %end21

end21:                                            ; preds = %true20, %end15
  %attrscale.1 = phi double [ 1.000000e+23, %true20 ], [ 0.000000e+00, %end15 ]
  %promotion22 = load i8*, i8** %promotion
  %return23 = call i64 @"eq@ISS"(i8* %promotion22, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @17, i64 0, i64 0))
  %9 = icmp ne i64 %return23, 0
  br i1 %9, label %true24, label %end25

true24:                                           ; preds = %end21
  br label %end25

end25:                                            ; preds = %true24, %end21
  %attrscale.2 = phi double [ 1.000000e+00, %true24 ], [ %attrscale.1, %end21 ]
  %ptgeo26 = load i64, i64* %ptgeo
  %attr27 = load i8*, i8** %attr
  %return28 = call i64 @"haspointattrib@IIS"(i64 %ptgeo26, i8* %attr27)
  %10 = icmp ne i64 %return28, 0
  br i1 %10, label %true29, label %end30

true29:                                           ; preds = %end25
  %return32 = call i64 @"len@I[I"(i64* %pts.1)
  br label %cond

end30:                                            ; preds = %cond, %end25
  %div.1 = phi i64 [ %div.2, %cond ], [ 0, %end25 ]
  %attrscale.3 = phi double [ %attrscale.4, %cond ], [ %attrscale.2, %end25 ]
  %primgeo84 = load i8*, i8** %primgeo
  %return85 = call i64 @"ne@ISS"(i8* %primgeo84, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @7, i64 0, i64 0))
  %targetprim86 = load i64, i64* %targetprim
  %return87 = call i64 @"ge@III"(i64 %targetprim86, i64 0)
  %return88 = call i64 @"and@III"(i64 %return85, i64 %return87)
  %promotion89 = load i8*, i8** %promotion
  %return90 = call i64 @"ne@ISS"(i8* %promotion89, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @14, i64 0, i64 0))
  %return91 = call i64 @"and@III"(i64 %return88, i64 %return90)
  %attr93 = load i8*, i8** %attr
  %return94 = call i64 @"hasprimattrib@ISS"(i8* %primgeo84, i8* %attr93)
  %primgeo95 = load i8*, i8** %primgeo
  %attr96 = load i8*, i8** %attr
  %return97 = call i64 @"hasvertexattrib@ISS"(i8* %primgeo95, i8* %attr96)
  %return98 = call i64 @"or@III"(i64 %return94, i64 %return97)
  %primgeo99 = load i8*, i8** %primgeo
  %attr100 = load i8*, i8** %attr
  %return101 = call i64 @"haspointattrib@ISS"(i8* %primgeo99, i8* %attr100)
  %return102 = call i64 @"or@III"(i64 %return98, i64 %return101)
  %return103 = call i64 @"and@III"(i64 %return91, i64 %return102)
  %11 = icmp ne i64 %return103, 0
  br i1 %11, label %true104, label %end

cond:                                             ; preds = %end53, %true29
  %div.2 = phi i64 [ 0, %true29 ], [ %div.3, %end53 ]
  %__impl_foreach_index_284.0 = phi i64 [ 0, %true29 ], [ %output83, %end53 ]
  %attrscale.4 = phi double [ %attrscale.2, %true29 ], [ %attrscale.5, %end53 ]
  %return35 = call i64 @"lt@III"(i64 %__impl_foreach_index_284.0, i64 %return32)
  %12 = icmp ne i64 %return35, 0
  br i1 %12, label %body, label %end30

body:                                             ; preds = %cond
  %return39 = call i64 @"getcomp@I[II"(i64* %pts.1, i64 %__impl_foreach_index_284.0)
  %ptgeo40 = load i64, i64* %ptgeo
  %attr41 = load i8*, i8** %attr
  %return43 = call double @"point@FISI"(i64 %ptgeo40, i8* %attr41, i64 %return39)
  %promotion44 = load i8*, i8** %promotion
  %return45 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @18, i64 0, i64 0))
  %return47 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @14, i64 0, i64 0))
  %return48 = call i64 @"or@III"(i64 %return45, i64 %return47)
  %return50 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @15, i64 0, i64 0))
  %return51 = call i64 @"or@III"(i64 %return48, i64 %return50)
  %13 = icmp ne i64 %return51, 0
  br i1 %13, label %true52, label %false

true52:                                           ; preds = %body
  %output = fadd double %attrscale.4, %return43
  %output58 = add i64 %div.2, 1
  br label %end53

false:                                            ; preds = %body
  %return60 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @19, i64 0, i64 0))
  %14 = icmp ne i64 %return60, 0
  br i1 %14, label %true61, label %false62

end53:                                            ; preds = %false70, %true77, %true69, %true61, %true52
  %div.3 = phi i64 [ %output58, %true52 ], [ 1, %true61 ], [ 1, %true69 ], [ 1, %true77 ], [ %div.2, %false70 ]
  %attrscale.5 = phi double [ %output, %true52 ], [ %return66, %true61 ], [ %return74, %true69 ], [ %output81, %true77 ], [ %attrscale.4, %false70 ]
  %output83 = add i64 %__impl_foreach_index_284.0, 1
  br label %cond

true61:                                           ; preds = %false
  %return66 = call double @"max@FFF"(double %attrscale.4, double %return43)
  br label %end53

false62:                                          ; preds = %false
  %return68 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @16, i64 0, i64 0))
  %15 = icmp ne i64 %return68, 0
  br i1 %15, label %true69, label %false70

true69:                                           ; preds = %false62
  %return74 = call double @"min@FFF"(double %attrscale.4, double %return43)
  br label %end53

false70:                                          ; preds = %false62
  %return76 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @17, i64 0, i64 0))
  %16 = icmp ne i64 %return76, 0
  br i1 %16, label %true77, label %end53

true77:                                           ; preds = %false70
  %output81 = fmul double %attrscale.4, %return43
  br label %end53

true104:                                          ; preds = %end30
  %primgeo106 = load i8*, i8** %primgeo
  %attr107 = load i8*, i8** %attr
  %targetprim108 = load i64, i64* %targetprim
  %uv109 = load <3 x double>, <3 x double>* %uv
  %return110 = call double @"primuv@FSSIV"(i8* %primgeo106, i8* %attr107, i64 %targetprim108, <3 x double> %uv109)
  %promotion111 = load i8*, i8** %promotion
  %return112 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @18, i64 0, i64 0))
  %return114 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @15, i64 0, i64 0))
  %return115 = call i64 @"or@III"(i64 %return112, i64 %return114)
  %17 = icmp ne i64 %return115, 0
  br i1 %17, label %true116, label %false117

true116:                                          ; preds = %true104
  %output121 = fadd double %attrscale.3, %return110
  %output124 = add i64 %div.1, 1
  br label %end

false117:                                         ; preds = %true104
  %return126 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @19, i64 0, i64 0))
  %18 = icmp ne i64 %return126, 0
  br i1 %18, label %true127, label %false128

true127:                                          ; preds = %false117
  %return132 = call double @"max@FFF"(double %attrscale.3, double %return110)
  br label %end

false128:                                         ; preds = %false117
  %return134 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @16, i64 0, i64 0))
  %19 = icmp ne i64 %return134, 0
  br i1 %19, label %true135, label %false136

true135:                                          ; preds = %false128
  %return140 = call double @"min@FFF"(double %attrscale.3, double %return110)
  br label %end

false136:                                         ; preds = %false128
  %return142 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @17, i64 0, i64 0))
  %20 = icmp ne i64 %return142, 0
  br i1 %20, label %true143, label %end

true143:                                          ; preds = %false136
  %output147 = fmul double %attrscale.3, %return110
  br label %end

true150:                                          ; preds = %end
  %cast = sitofp i64 %div.0 to double
  %output155 = call double @"div@FF"(double %attrscale.0, double %cast)
  br label %end151

end151:                                           ; preds = %true150, %end
  %scale.0 = phi double [ %output155, %true150 ], [ 1.000000e+00, %end ]
  %scalemode157 = load i8*, i8** %scalemode
  %return158 = call i64 @"eq@ISS"(i8* %scalemode157, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @20, i64 0, i64 0))
  %return160 = call i64 @"eq@ISS"(i8* %scalemode157, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @13, i64 0, i64 0))
  %return161 = call i64 @"or@III"(i64 %return158, i64 %return160)
  %21 = icmp ne i64 %return161, 0
  br i1 %21, label %true162, label %end163

true162:                                          ; preds = %end151
  %valscale165 = load double, double* %valscale
  %output166 = fmul double %scale.0, %valscale165
  br label %end163

end163:                                           ; preds = %true162, %end151
  %scale.1 = phi double [ %output166, %true162 ], [ %scale.0, %end151 ]
  ret double %scale.1
}

; Function Attrs: nounwind
declare i64 @"haspointattrib@IIS"(i64, i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #1

; Function Attrs: nounwind
declare double @"point@FISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare double @"max@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare double @"min@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare i64 @"ne@ISS"(i8*, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"ge@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"hasprimattrib@ISS"(i8*, i8*) #2

; Function Attrs: nounwind
declare i64 @"hasvertexattrib@ISS"(i8*, i8*) #2

; Function Attrs: nounwind
declare i64 @"haspointattrib@ISS"(i8*, i8*) #2

; Function Attrs: nounwind
declare double @"primuv@FSSIV"(i8*, i8*, i64, <3 x double>) #2

; Function Attrs: nounwind readnone
declare i64 @"gt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: alwaysinline nounwind
define private double @"warpWeftScale@FI[IFFFS"(i64* %geo, i64** %pts, double* %warp, double* %weft, double* %shear, i8** %materialuv) #0 {
__llvm_entry:
  %geo1 = load i64, i64* %geo
  %materialuv2 = load i8*, i8** %materialuv
  %pts3 = load i64*, i64** %pts
  %return = call i64 @"getcomp@I[II"(i64* %pts3, i64 0)
  %return4 = call <3 x double> @"point@VISI"(i64 %geo1, i8* %materialuv2, i64 %return)
  %geo5 = load i64, i64* %geo
  %materialuv6 = load i8*, i8** %materialuv
  %pts7 = load i64*, i64** %pts
  %return8 = call i64 @"getcomp@I[II"(i64* %pts7, i64 1)
  %return9 = call <3 x double> @"point@VISI"(i64 %geo5, i8* %materialuv6, i64 %return8)
  %output = call <3 x double> @"sub@VV"(<3 x double> %return9, <3 x double> %return4)
  %return13 = call double @"getcomp@FVI"(<3 x double> %output, i64 0)
  %return15 = call double @"getcomp@FVI"(<3 x double> %output, i64 1)
  %return16 = call double @"atan2@FFF"(double %return13, double %return15)
  %return17 = call double @"degrees@FF"(double %return16)
  %return18 = call double @"mod@FFF"(double %return17, double 1.800000e+02)
  %return20 = fcmp ogt double %return18, 9.000000e+01
  br i1 %return20, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %output23 = fsub double 1.800000e+02, %return18
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %angle.0 = phi double [ %output23, %true ], [ %return18, %__llvm_entry ]
  %output25 = call double @"div@FF"(double %angle.0, double 9.000000e+01)
  %return27 = fcmp olt double %output25, 5.000000e-01
  br i1 %return27, label %true29, label %false

true29:                                           ; preds = %end
  %warp31 = load double, double* %warp
  %shear32 = load double, double* %shear
  %output34 = fmul double %output25, 2.000000e+00
  %return35 = call double @"lerp@FFFF"(double %warp31, double %shear32, double %output34)
  br label %end30

false:                                            ; preds = %end
  %shear36 = load double, double* %shear
  %weft37 = load double, double* %weft
  %output39 = fsub double %output25, 5.000000e-01
  %output40 = fmul double %output39, 2.000000e+00
  %return41 = call double @"lerp@FFFF"(double %shear36, double %weft37, double %output40)
  br label %end30

end30:                                            ; preds = %false, %true29
  %scale.0 = phi double [ %return35, %true29 ], [ %return41, %false ]
  ret double %scale.0
}

; Function Attrs: nounwind
declare <3 x double> @"point@VISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"sub@VV"(<3 x double>, <3 x double>) #1

; Function Attrs: nounwind readnone
declare double @"getcomp@FVI"(<3 x double>, i64) #1

; Function Attrs: nounwind readnone
declare double @"atan2@FFF"(double, double) #1

; Function Attrs: nounwind
declare double @"degrees@FF"(double) #2

; Function Attrs: nounwind readnone
declare double @"mod@FFF"(double, double) #1

; Function Attrs: nounwind
declare double @"lerp@FFFF"(double, double, double) #2

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@IVSISFFFFF"(i64* %_bound_target_prim, <3 x double>* %_bound_target_uv, i8** %_bound_target_path, i64* %_bound_primnum, i8** %_bound_type, double* %_bound_stiffness, double* %_bound_dampingratio, double* %_bound_plasticthreshold, double* %_bound_plasticrate, double* %_bound_plastichardening) #0 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64*
  %2 = alloca double
  %3 = alloca double
  %4 = alloca double
  %5 = alloca i8*
  %6 = alloca double
  %7 = alloca double
  %8 = alloca i8*
  %9 = alloca i64
  %10 = alloca i64*
  %11 = alloca i8*
  %12 = alloca i64
  %13 = alloca <3 x double>
  %14 = alloca i8*
  %15 = alloca double
  %16 = alloca i8*
  %17 = alloca i8*
  %18 = alloca double
  %19 = alloca double
  %20 = alloca i8*
  %21 = alloca i64
  %22 = alloca i64*
  %23 = alloca i8*
  %24 = alloca i64
  %25 = alloca <3 x double>
  %26 = alloca i8*
  %27 = alloca double
  %28 = alloca i8*
  %29 = alloca i8*
  %30 = alloca i8*
  %31 = alloca i64
  %32 = alloca i64*
  %33 = alloca i8*
  %34 = alloca i64
  %35 = alloca <3 x double>
  %36 = alloca i8*
  %37 = alloca double
  %38 = alloca i8*
  %39 = alloca i8*
  %40 = alloca i8*
  %41 = alloca i64
  %42 = alloca i64*
  %43 = alloca i8*
  %44 = alloca i64
  %45 = alloca <3 x double>
  %46 = alloca i8*
  %47 = alloca double
  %48 = alloca i8*
  %49 = alloca i8*
  %50 = alloca i8*
  %51 = alloca i64
  %52 = alloca i64*
  %53 = alloca i8*
  %54 = alloca i64
  %55 = alloca <3 x double>
  %56 = alloca i8*
  %57 = alloca double
  %58 = alloca i8*
  %59 = alloca i8*
  %return = call i8* @"chs@SS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @21, i64 0, i64 0))
  %_bound_primnum1 = load i64, i64* %_bound_primnum
  %return2 = call i64* @"primpoints@[III"(i64 0, i64 %_bound_primnum1)
  %_bound_type3 = load i8*, i8** %_bound_type
  %return4 = call i64 @"ne@ISS"(i8* %_bound_type3, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @5, i64 0, i64 0))
  %60 = icmp ne i64 %return4, 0
  br i1 %60, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %_bound_stiffness5 = load double, double* %_bound_stiffness
  %return6 = call double @"chf@FS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @22, i64 0, i64 0))
  %return7 = call double @"pow@FFF"(double 1.000000e+01, double %return6)
  %output = fmul double %_bound_stiffness5, %return7
  store double %output, double* %_bound_stiffness
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %_bound_type8 = load i8*, i8** %_bound_type
  %return9 = call i64 @"eq@ISS"(i8* %_bound_type8, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @4, i64 0, i64 0))
  %return10 = call i64 @"chi@IS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @23, i64 0, i64 0))
  %return11 = call i64 @"and@III"(i64 %return9, i64 %return10)
  %61 = icmp ne i64 %return11, 0
  br i1 %61, label %true12, label %end13

true12:                                           ; preds = %end
  store i64 1, i64* %0
  store i64* %return2, i64** %1
  %return15 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @24, i64 0, i64 0))
  store double %return15, double* %2
  %return16 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @25, i64 0, i64 0))
  store double %return16, double* %3
  %return17 = call double @"chf@FS"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @26, i64 0, i64 0))
  store double %return17, double* %4
  %return18 = call i8* @"chs@SS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @27, i64 0, i64 0))
  store i8* %return18, i8** %5
  %warpWeftScale = call double @"warpWeftScale@FI[IFFFS"(i64* %0, i64** %1, double* %2, double* %3, double* %4, i8** %5)
  store double %warpWeftScale, double* %6
  %_bound_stiffness20 = load double, double* %_bound_stiffness
  store double %_bound_stiffness20, double* %7
  %logscaleStiffness = call double @"logscaleStiffness@FFF"(double* %6, double* %7)
  store double %logscaleStiffness, double* %_bound_stiffness
  br label %end13

end13:                                            ; preds = %true12, %end
  %_bound_type21 = load i8*, i8** %_bound_type
  store i8* %_bound_type21, i8** %8
  store i64 1, i64* %9
  store i64* %return2, i64** %10
  %_bound_target_path23 = load i8*, i8** %_bound_target_path
  store i8* %_bound_target_path23, i8** %11
  %_bound_target_prim24 = load i64, i64* %_bound_target_prim
  store i64 %_bound_target_prim24, i64* %12
  %_bound_target_uv25 = load <3 x double>, <3 x double>* %_bound_target_uv
  store <3 x double> %_bound_target_uv25, <3 x double>* %13
  %return26 = call i8* @"chs@SS"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @28, i64 0, i64 0))
  store i8* %return26, i8** %14
  %return27 = call double @"chf@FS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @29, i64 0, i64 0))
  store double %return27, double* %15
  %return28 = call i8* @"chs@SS"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @30, i64 0, i64 0))
  store i8* %return28, i8** %16
  store i8* %return, i8** %17
  %accumScaleValues = call double @"accumScaleValues@FSI[ISIVSFSS"(i8** %8, i64* %9, i64** %10, i8** %11, i64* %12, <3 x double>* %13, i8** %14, double* %15, i8** %16, i8** %17)
  store double %accumScaleValues, double* %18
  %_bound_stiffness31 = load double, double* %_bound_stiffness
  store double %_bound_stiffness31, double* %19
  %logscaleStiffness32 = call double @"logscaleStiffness@FFF"(double* %18, double* %19)
  store double %logscaleStiffness32, double* %_bound_stiffness
  %_bound_dampingratio33 = load double, double* %_bound_dampingratio
  %_bound_type34 = load i8*, i8** %_bound_type
  store i8* %_bound_type34, i8** %20
  store i64 1, i64* %21
  store i64* %return2, i64** %22
  %_bound_target_path36 = load i8*, i8** %_bound_target_path
  store i8* %_bound_target_path36, i8** %23
  %_bound_target_prim37 = load i64, i64* %_bound_target_prim
  store i64 %_bound_target_prim37, i64* %24
  %_bound_target_uv38 = load <3 x double>, <3 x double>* %_bound_target_uv
  store <3 x double> %_bound_target_uv38, <3 x double>* %25
  %return39 = call i8* @"chs@SS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @31, i64 0, i64 0))
  store i8* %return39, i8** %26
  %return40 = call double @"chf@FS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @32, i64 0, i64 0))
  store double %return40, double* %27
  %return41 = call i8* @"chs@SS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @33, i64 0, i64 0))
  store i8* %return41, i8** %28
  store i8* %return, i8** %29
  %accumScaleValues43 = call double @"accumScaleValues@FSI[ISIVSFSS"(i8** %20, i64* %21, i64** %22, i8** %23, i64* %24, <3 x double>* %25, i8** %26, double* %27, i8** %28, i8** %29)
  %output44 = fmul double %_bound_dampingratio33, %accumScaleValues43
  store double %output44, double* %_bound_dampingratio
  %return45 = call i64 @"chi@IS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @34, i64 0, i64 0))
  %62 = icmp ne i64 %return45, 0
  br i1 %62, label %true46, label %end47

true46:                                           ; preds = %end13
  %_bound_plasticthreshold48 = load double, double* %_bound_plasticthreshold
  %_bound_type49 = load i8*, i8** %_bound_type
  store i8* %_bound_type49, i8** %30
  store i64 1, i64* %31
  store i64* %return2, i64** %32
  %_bound_target_path51 = load i8*, i8** %_bound_target_path
  store i8* %_bound_target_path51, i8** %33
  %_bound_target_prim52 = load i64, i64* %_bound_target_prim
  store i64 %_bound_target_prim52, i64* %34
  %_bound_target_uv53 = load <3 x double>, <3 x double>* %_bound_target_uv
  store <3 x double> %_bound_target_uv53, <3 x double>* %35
  %return54 = call i8* @"chs@SS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @35, i64 0, i64 0))
  store i8* %return54, i8** %36
  %return55 = call double @"chf@FS"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @36, i64 0, i64 0))
  store double %return55, double* %37
  %return56 = call i8* @"chs@SS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @37, i64 0, i64 0))
  store i8* %return56, i8** %38
  store i8* %return, i8** %39
  %accumScaleValues58 = call double @"accumScaleValues@FSI[ISIVSFSS"(i8** %30, i64* %31, i64** %32, i8** %33, i64* %34, <3 x double>* %35, i8** %36, double* %37, i8** %38, i8** %39)
  %output59 = fmul double %_bound_plasticthreshold48, %accumScaleValues58
  store double %output59, double* %_bound_plasticthreshold
  %_bound_plasticrate60 = load double, double* %_bound_plasticrate
  %_bound_type61 = load i8*, i8** %_bound_type
  store i8* %_bound_type61, i8** %40
  store i64 1, i64* %41
  store i64* %return2, i64** %42
  %_bound_target_path63 = load i8*, i8** %_bound_target_path
  store i8* %_bound_target_path63, i8** %43
  %_bound_target_prim64 = load i64, i64* %_bound_target_prim
  store i64 %_bound_target_prim64, i64* %44
  %_bound_target_uv65 = load <3 x double>, <3 x double>* %_bound_target_uv
  store <3 x double> %_bound_target_uv65, <3 x double>* %45
  %return66 = call i8* @"chs@SS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @38, i64 0, i64 0))
  store i8* %return66, i8** %46
  %return67 = call double @"chf@FS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @39, i64 0, i64 0))
  store double %return67, double* %47
  %return68 = call i8* @"chs@SS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @40, i64 0, i64 0))
  store i8* %return68, i8** %48
  store i8* %return, i8** %49
  %accumScaleValues70 = call double @"accumScaleValues@FSI[ISIVSFSS"(i8** %40, i64* %41, i64** %42, i8** %43, i64* %44, <3 x double>* %45, i8** %46, double* %47, i8** %48, i8** %49)
  %output71 = fmul double %_bound_plasticrate60, %accumScaleValues70
  store double %output71, double* %_bound_plasticrate
  %_bound_plastichardening72 = load double, double* %_bound_plastichardening
  %_bound_type73 = load i8*, i8** %_bound_type
  store i8* %_bound_type73, i8** %50
  store i64 1, i64* %51
  store i64* %return2, i64** %52
  %_bound_target_path75 = load i8*, i8** %_bound_target_path
  store i8* %_bound_target_path75, i8** %53
  %_bound_target_prim76 = load i64, i64* %_bound_target_prim
  store i64 %_bound_target_prim76, i64* %54
  %_bound_target_uv77 = load <3 x double>, <3 x double>* %_bound_target_uv
  store <3 x double> %_bound_target_uv77, <3 x double>* %55
  %return78 = call i8* @"chs@SS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @41, i64 0, i64 0))
  store i8* %return78, i8** %56
  %return79 = call double @"chf@FS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @42, i64 0, i64 0))
  store double %return79, double* %57
  %return80 = call i8* @"chs@SS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @43, i64 0, i64 0))
  store i8* %return80, i8** %58
  store i8* %return, i8** %59
  %accumScaleValues82 = call double @"accumScaleValues@FSI[ISIVSFSS"(i8** %50, i64* %51, i64** %52, i8** %53, i64* %54, <3 x double>* %55, i8** %56, double* %57, i8** %58, i8** %59)
  %output83 = fmul double %_bound_plastichardening72, %accumScaleValues82
  store double %output83, double* %_bound_plastichardening
  br label %end47

end47:                                            ; preds = %true46, %end13
  ret void
}

; Function Attrs: nounwind readnone
declare i8* @"chs@SS"(i8*) #1

; Function Attrs: nounwind
declare i64* @"primpoints@[III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #1

; Function Attrs: nounwind readnone
declare double @"pow@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #1

; Function Attrs: nounwind
define void @__vex_snippet(i64 %target_prim, <3 x double> %target_uv, i8* %target_path, i64 %primnum, i8* %type, double %stiffness, double %dampingratio, double %plasticthreshold, double %plasticrate, double %plastichardening) #2 {
__llvm_entry:
  %"<stiffness>" = alloca double
  %"<dampingratio>" = alloca double
  %"<plasticthreshold>" = alloca double
  %"<plasticrate>" = alloca double
  %"<plastichardening>" = alloca double
  %0 = alloca i64
  %1 = alloca <3 x double>
  %2 = alloca i8*
  %3 = alloca i64
  %4 = alloca i8*
  store double %stiffness, double* %"<stiffness>"
  store double %dampingratio, double* %"<dampingratio>"
  store double %plasticthreshold, double* %"<plasticthreshold>"
  store double %plasticrate, double* %"<plasticrate>"
  store double %plastichardening, double* %"<plastichardening>"
  store i64 %target_prim, i64* %0
  store <3 x double> %target_uv, <3 x double>* %1
  store i8* %target_path, i8** %2
  store i64 %primnum, i64* %3
  store i8* %type, i8** %4
  call void @"__vex_snippet_snippet@IVSISFFFFF"(i64* %0, <3 x double>* %1, i8** %2, i64* %3, i8** %4, double* %"<stiffness>", double* %"<dampingratio>", double* %"<plasticthreshold>", double* %"<plasticrate>", double* %"<plastichardening>")
  %evalue = load double, double* %"<stiffness>"
  %gvalue = call double @"_export@FSF"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @44, i64 0, i64 0), double %evalue) #3
  %evalue6 = load double, double* %"<dampingratio>"
  %gvalue7 = call double @"_export@FSF"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @45, i64 0, i64 0), double %evalue6) #3
  %evalue8 = load double, double* %"<plasticthreshold>"
  %gvalue9 = call double @"_export@FSF"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @46, i64 0, i64 0), double %evalue8) #3
  %evalue10 = load double, double* %"<plasticrate>"
  %gvalue11 = call double @"_export@FSF"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @47, i64 0, i64 0), double %evalue10) #3
  %evalue12 = load double, double* %"<plastichardening>"
  %gvalue13 = call double @"_export@FSF"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @48, i64 0, i64 0), double %evalue12) #3
  store double %gvalue, double* @stiffness
  store double %gvalue7, double* @dampingratio
  store double %gvalue9, double* @plasticthreshold
  store double %gvalue11, double* @plasticrate
  store double %gvalue13, double* @plastichardening
  ret void
}

declare double @"_export@FSF"(i8*, double)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 -1, <3 x double> zeroinitializer, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @7, i64 0, i64 0), i64 0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @7, i64 0, i64 0), double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}

;_code_end
