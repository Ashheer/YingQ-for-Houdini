;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [8 x i64] [i64 1, i64 2, i64 3, i64 4, i64 5, i64 6, i64 7, i64 8]
@1 = private constant [6 x i8] c"value\00"
@2 = private constant [2 x i64] [i64 -1, i64 -1]
@3 = private constant [0 x i64] zeroinitializer
@perm = external global i64*
@current_iter = external global i64
@p_dirs = external global i64*
@x_dirs = external global i64*
@4 = private constant [5 x i8] c"perm\00"
@5 = private constant [13 x i8] c"current_iter\00"
@6 = private constant [7 x i8] c"p_dirs\00"
@7 = private constant [7 x i8] c"x_dirs\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@[II[I[I"(i64** %_bound_perm, i64* %_bound_current_iter, i64** %_bound_p_dirs, i64** %_bound_x_dirs) #0 {
__llvm_entry:
  store i64* getelementptr inbounds ([8 x i64], [8 x i64]* @0, i64 0, i64 0), i64** %_bound_perm
  %return = call double @"detail@FIS"(i64 1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @1, i64 0, i64 0))
  %cast = fptosi double %return to i64
  store i64 %cast, i64* %_bound_current_iter
  br label %cond

cond:                                             ; preds = %body, %__llvm_entry
  %i.0 = phi i64 [ 0, %__llvm_entry ], [ %output47, %body ]
  %return3 = call i64 @"lt@III"(i64 %i.0, i64 8)
  %0 = icmp ne i64 %return3, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %cast6 = sitofp i64 %i.0 to double
  %output = fmul double %cast6, 3.141500e+00
  %output8 = fadd double %output, %return
  %return9 = call <2 x double> @"rand@UF"(double %output8)
  %return11 = call double @"getcomp@FUI"(<2 x double> %return9, i64 0)
  %output12 = fmul double %return11, 8.000000e+00
  %return13 = call i64 @"floor@IF"(double %output12)
  %return15 = call double @"getcomp@FUI"(<2 x double> %return9, i64 1)
  %output16 = fmul double %return15, 8.000000e+00
  %return17 = call i64 @"floor@IF"(double %output16)
  %return19 = call i64 @"eq@III"(i64 %return13, i64 8)
  %1 = icmp ne i64 %return19, 0
  %phi = select i1 %1, i64 7, i64 %return13
  %return23 = call i64 @"eq@III"(i64 %return17, i64 8)
  %2 = icmp ne i64 %return23, 0
  %phi28 = select i1 %2, i64 7, i64 %return17
  %_bound_perm29 = load i64*, i64** %_bound_perm
  %return31 = call i64 @"getcomp@I[II"(i64* %_bound_perm29, i64 %phi)
  %return35 = call i64 @"getcomp@I[II"(i64* %_bound_perm29, i64 %phi28)
  %return36 = call { i64, i64* } @"setcomp@I[III"(i64* %_bound_perm29, i64 %return35, i64 %phi)
  %output38 = extractvalue { i64, i64* } %return36, 1
  %return42 = call { i64, i64* } @"setcomp@I[III"(i64* %output38, i64 %return31, i64 %phi28)
  %output44 = extractvalue { i64, i64* } %return42, 1
  store i64* %output44, i64** %_bound_perm
  %output47 = add i64 %i.0, 1
  br label %cond

end:                                              ; preds = %cond
  store i64* getelementptr inbounds ([2 x i64], [2 x i64]* @2, i64 0, i64 0), i64** %_bound_p_dirs
  br label %cond49

cond49:                                           ; preds = %end66, %end
  %i48.0 = phi i64 [ 0, %end ], [ %output80, %end66 ]
  %return52 = call i64 @"lt@III"(i64 %i48.0, i64 2)
  %3 = icmp ne i64 %return52, 0
  br i1 %3, label %body50, label %end53

body50:                                           ; preds = %cond49
  %cast56 = sitofp i64 %i48.0 to double
  %output57 = fmul double %cast56, 3.270000e+00
  %output59 = fadd double %output57, %return
  %return60 = call double @"rand@FF"(double %output59)
  %return62 = fcmp ogt double %return60, 5.000000e-01
  br i1 %return62, label %true64, label %false65

end53:                                            ; preds = %cond49
  store i64* getelementptr inbounds ([2 x i64], [2 x i64]* @2, i64 0, i64 0), i64** %_bound_x_dirs
  br label %cond82

true64:                                           ; preds = %body50
  %tmp68 = load i64*, i64** %_bound_p_dirs
  %return69 = call { i64, i64* } @"setcomp@I[III"(i64* %tmp68, i64 1, i64 %i48.0)
  %output71 = extractvalue { i64, i64* } %return69, 1
  store i64* %output71, i64** %_bound_p_dirs
  br label %end66

false65:                                          ; preds = %body50
  %return73 = call i64 @"neg@II"(i64 1)
  %tmp74 = load i64*, i64** %_bound_p_dirs
  %return75 = call { i64, i64* } @"setcomp@I[III"(i64* %tmp74, i64 %return73, i64 %i48.0)
  %output77 = extractvalue { i64, i64* } %return75, 1
  store i64* %output77, i64** %_bound_p_dirs
  br label %end66

end66:                                            ; preds = %false65, %true64
  %output80 = add i64 %i48.0, 1
  br label %cond49

cond82:                                           ; preds = %end100, %end53
  %i81.0 = phi i64 [ 0, %end53 ], [ %output114, %end100 ]
  %return85 = call i64 @"lt@III"(i64 %i81.0, i64 2)
  %4 = icmp ne i64 %return85, 0
  br i1 %4, label %body83, label %end86

body83:                                           ; preds = %cond82
  %cast90 = sitofp i64 %i81.0 to double
  %output91 = fmul double %cast90, 4.130000e+00
  %output93 = fadd double %output91, %return
  %return94 = call double @"rand@FF"(double %output93)
  %return96 = fcmp ogt double %return94, 5.000000e-01
  br i1 %return96, label %true98, label %false99

end86:                                            ; preds = %cond82
  ret void

true98:                                           ; preds = %body83
  %tmp102 = load i64*, i64** %_bound_x_dirs
  %return103 = call { i64, i64* } @"setcomp@I[III"(i64* %tmp102, i64 1, i64 %i81.0)
  %output105 = extractvalue { i64, i64* } %return103, 1
  store i64* %output105, i64** %_bound_x_dirs
  br label %end100

false99:                                          ; preds = %body83
  %return107 = call i64 @"neg@II"(i64 1)
  %tmp108 = load i64*, i64** %_bound_x_dirs
  %return109 = call { i64, i64* } @"setcomp@I[III"(i64* %tmp108, i64 %return107, i64 %i81.0)
  %output111 = extractvalue { i64, i64* } %return109, 1
  store i64* %output111, i64** %_bound_x_dirs
  br label %end100

end100:                                           ; preds = %false99, %true98
  %output114 = add i64 %i81.0, 1
  br label %cond82
}

; Function Attrs: nounwind
declare double @"detail@FIS"(i64, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #2

; Function Attrs: nounwind
declare <2 x double> @"rand@UF"(double) #1

; Function Attrs: nounwind readnone
declare double @"getcomp@FUI"(<2 x double>, i64) #2

; Function Attrs: nounwind
declare i64 @"floor@IF"(double) #1

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #2

; Function Attrs: nounwind readnone
declare { i64, i64* } @"setcomp@I[III"(i64*, i64, i64) #2

; Function Attrs: nounwind
declare double @"rand@FF"(double) #1

; Function Attrs: nounwind readnone
declare i64 @"neg@II"(i64) #2

; Function Attrs: nounwind
define void @__vex_snippet(i64* %perm, i64 %current_iter, i64* %p_dirs, i64* %x_dirs) #1 {
__llvm_entry:
  %"<current_iter>" = alloca i64
  %"<p_dirs>" = alloca i64*
  %"<x_dirs>" = alloca i64*
  %"<perm>" = alloca i64*
  store i64* %perm, i64** %"<perm>"
  store i64 %current_iter, i64* %"<current_iter>"
  store i64* %p_dirs, i64** %"<p_dirs>"
  store i64* %x_dirs, i64** %"<x_dirs>"
  call void @"__vex_snippet_snippet@[II[I[I"(i64** %"<perm>", i64* %"<current_iter>", i64** %"<p_dirs>", i64** %"<x_dirs>")
  %evalue = load i64*, i64** %"<perm>"
  %gvalue = call i64* @"_export@[IS[I"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @4, i64 0, i64 0), i64* %evalue) #3
  %evalue1 = load i64, i64* %"<current_iter>"
  %gvalue2 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @5, i64 0, i64 0), i64 %evalue1) #3
  %evalue3 = load i64*, i64** %"<p_dirs>"
  %gvalue4 = call i64* @"_export@[IS[I"(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @6, i64 0, i64 0), i64* %evalue3) #3
  %evalue5 = load i64*, i64** %"<x_dirs>"
  %gvalue6 = call i64* @"_export@[IS[I"(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @7, i64 0, i64 0), i64* %evalue5) #3
  store i64* %gvalue, i64** @perm
  store i64 %gvalue2, i64* @current_iter
  store i64* %gvalue4, i64** @p_dirs
  store i64* %gvalue6, i64** @x_dirs
  ret void
}

declare i64* @"_export@[IS[I"(i8*, i64*)

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64* getelementptr inbounds ([0 x i64], [0 x i64]* @3, i64 0, i64 0), i64 0, i64* getelementptr inbounds ([0 x i64], [0 x i64]* @3, i64 0, i64 0), i64* getelementptr inbounds ([0 x i64], [0 x i64]* @3, i64 0, i64 0))
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.531"}
!2 = !{!"64"}

;_code_end
