;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [8 x i8] c"../%s%d\00"
@1 = private constant [12 x i8] c"scatterfrom\00"
@2 = private constant [11 x i8] c"scatterpts\00"
@3 = private constant [18 x i8] c"scatterptsscaling\00"
@4 = private constant [11 x i8] c"rangeremap\00"
@5 = private constant [13 x i8] c"rangeremapin\00"
@6 = private constant [14 x i8] c"rangeremapout\00"
@7 = private constant [20 x i8] c"scatterptsattribute\00"
@8 = private constant [12 x i8] c"scatterseed\00"
@9 = private constant [14 x i8] c"../randomseed\00"
@10 = private constant [12 x i8] c"useptsinput\00"
@11 = private constant [14 x i8] c"ptsinputgroup\00"
@12 = private constant [1 x i8] zeroinitializer
@iteration = external global i64
@scatterfrom = external global i64
@scatterpts = external global i64
@scatterptsscaling = external global i64
@rangeremap = external global i64
@rangein = external global <2 x double>
@rangeout = external global <2 x double>
@scatterptsattribute = external global i8*
@scatterseed = external global double
@useptsinput = external global i64
@ptsinputgroup = external global i8*
@13 = private constant [10 x i8] c"iteration\00"
@14 = private constant [8 x i8] c"rangein\00"
@15 = private constant [9 x i8] c"rangeout\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@IIIIIUUSFIS"(i64* %_bound_iteration, i64* %_bound_scatterfrom, i64* %_bound_scatterpts, i64* %_bound_scatterptsscaling, i64* %_bound_rangeremap, <2 x double>* %_bound_rangein, <2 x double>* %_bound_rangeout, i8** %_bound_scatterptsattribute, double* %_bound_scatterseed, i64* %_bound_useptsinput, i8** %_bound_ptsinputgroup) #0 {
__llvm_entry:
  %0 = alloca i8*
  %1 = alloca i64
  %2 = alloca i8*
  %3 = alloca i64
  %4 = alloca i8*
  %5 = alloca i64
  %6 = alloca i8*
  %7 = alloca i64
  %8 = alloca i8*
  %9 = alloca i64
  %10 = alloca i8*
  %11 = alloca i64
  %12 = alloca i8*
  %13 = alloca i64
  %14 = alloca i8*
  %15 = alloca i64
  %16 = alloca i8*
  %17 = alloca i64
  %18 = alloca i8*
  %19 = alloca i64
  %_bound_iteration1 = load i64, i64* %_bound_iteration
  %output = add i64 %_bound_iteration1, 1
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @1, i64 0, i64 0), i8** %0
  store i64 %output, i64* %1
  %parm = call i8* @"parm@SSI"(i8** %0, i64* %1)
  %return = call i64 @"chi@IS"(i8* %parm)
  store i64 %return, i64* %_bound_scatterfrom
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @2, i64 0, i64 0), i8** %2
  store i64 %output, i64* %3
  %parm4 = call i8* @"parm@SSI"(i8** %2, i64* %3)
  %return5 = call i64 @"chi@IS"(i8* %parm4)
  store i64 %return5, i64* %_bound_scatterpts
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @3, i64 0, i64 0), i8** %4
  store i64 %output, i64* %5
  %parm7 = call i8* @"parm@SSI"(i8** %4, i64* %5)
  %return8 = call i64 @"chi@IS"(i8* %parm7)
  store i64 %return8, i64* %_bound_scatterptsscaling
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @4, i64 0, i64 0), i8** %6
  store i64 %output, i64* %7
  %parm10 = call i8* @"parm@SSI"(i8** %6, i64* %7)
  %return11 = call i64 @"chi@IS"(i8* %parm10)
  store i64 %return11, i64* %_bound_rangeremap
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @5, i64 0, i64 0), i8** %8
  store i64 %output, i64* %9
  %parm13 = call i8* @"parm@SSI"(i8** %8, i64* %9)
  %return14 = call <2 x double> @"chu@US"(i8* %parm13)
  store <2 x double> %return14, <2 x double>* %_bound_rangein
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @6, i64 0, i64 0), i8** %10
  store i64 %output, i64* %11
  %parm16 = call i8* @"parm@SSI"(i8** %10, i64* %11)
  %return17 = call <2 x double> @"chu@US"(i8* %parm16)
  store <2 x double> %return17, <2 x double>* %_bound_rangeout
  store i8* getelementptr inbounds ([20 x i8], [20 x i8]* @7, i64 0, i64 0), i8** %12
  store i64 %output, i64* %13
  %parm19 = call i8* @"parm@SSI"(i8** %12, i64* %13)
  %return20 = call i8* @"chs@SS"(i8* %parm19)
  store i8* %return20, i8** %_bound_scatterptsattribute
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @8, i64 0, i64 0), i8** %14
  store i64 %output, i64* %15
  %parm22 = call i8* @"parm@SSI"(i8** %14, i64* %15)
  %return23 = call double @"chf@FS"(i8* %parm22)
  %return24 = call double @"chf@FS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @9, i64 0, i64 0))
  %output25 = fadd double %return23, %return24
  store double %output25, double* %_bound_scatterseed
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @10, i64 0, i64 0), i8** %16
  store i64 %output, i64* %17
  %parm27 = call i8* @"parm@SSI"(i8** %16, i64* %17)
  %return28 = call i64 @"chi@IS"(i8* %parm27)
  store i64 %return28, i64* %_bound_useptsinput
  store i8* getelementptr inbounds ([14 x i8], [14 x i8]* @11, i64 0, i64 0), i8** %18
  store i64 %output, i64* %19
  %parm30 = call i8* @"parm@SSI"(i8** %18, i64* %19)
  %return31 = call i8* @"chs@SS"(i8* %parm30)
  store i8* %return31, i8** %_bound_ptsinputgroup
  ret void
}

; Function Attrs: alwaysinline nounwind
define private i8* @"parm@SSI"(i8** %parmname, i64* %idx) #0 {
__llvm_entry:
  %parmname1 = load i8*, i8** %parmname
  %idx2 = load i64, i64* %idx
  %return = call i8* @"sprintf@SS:SI"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @0, i64 0, i64 0), i8* %parmname1, i64 %idx2)
  ret i8* %return
}

; Function Attrs: nounwind readnone
declare i8* @"sprintf@SS:SI"(i8*, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #1

; Function Attrs: nounwind readnone
declare <2 x double> @"chu@US"(i8*) #1

; Function Attrs: nounwind readnone
declare i8* @"chs@SS"(i8*) #1

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #1

; Function Attrs: nounwind
define void @__vex_snippet(i64 %iteration, i64 %scatterfrom, i64 %scatterpts, i64 %scatterptsscaling, i64 %rangeremap, <2 x double> %rangein, <2 x double> %rangeout, i8* %scatterptsattribute, double %scatterseed, i64 %useptsinput, i8* %ptsinputgroup) #2 {
__llvm_entry:
  %"<scatterfrom>" = alloca i64
  %"<scatterpts>" = alloca i64
  %"<scatterptsscaling>" = alloca i64
  %"<rangeremap>" = alloca i64
  %"<rangein>" = alloca <2 x double>
  %"<rangeout>" = alloca <2 x double>
  %"<scatterptsattribute>" = alloca i8*
  %"<scatterseed>" = alloca double
  %"<useptsinput>" = alloca i64
  %"<ptsinputgroup>" = alloca i8*
  %0 = alloca i64
  store i64 %scatterfrom, i64* %"<scatterfrom>"
  store i64 %scatterpts, i64* %"<scatterpts>"
  store i64 %scatterptsscaling, i64* %"<scatterptsscaling>"
  store i64 %rangeremap, i64* %"<rangeremap>"
  store <2 x double> %rangein, <2 x double>* %"<rangein>"
  store <2 x double> %rangeout, <2 x double>* %"<rangeout>"
  store i8* %scatterptsattribute, i8** %"<scatterptsattribute>"
  store double %scatterseed, double* %"<scatterseed>"
  store i64 %useptsinput, i64* %"<useptsinput>"
  store i8* %ptsinputgroup, i8** %"<ptsinputgroup>"
  store i64 %iteration, i64* %0
  call void @"__vex_snippet_snippet@IIIIIUUSFIS"(i64* %0, i64* %"<scatterfrom>", i64* %"<scatterpts>", i64* %"<scatterptsscaling>", i64* %"<rangeremap>", <2 x double>* %"<rangein>", <2 x double>* %"<rangeout>", i8** %"<scatterptsattribute>", double* %"<scatterseed>", i64* %"<useptsinput>", i8** %"<ptsinputgroup>")
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @13, i64 0, i64 0), i64 %iteration) #3
  %evalue2 = load i64, i64* %"<scatterfrom>"
  %gvalue3 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @1, i64 0, i64 0), i64 %evalue2) #3
  %evalue4 = load i64, i64* %"<scatterpts>"
  %gvalue5 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @2, i64 0, i64 0), i64 %evalue4) #3
  %evalue6 = load i64, i64* %"<scatterptsscaling>"
  %gvalue7 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @3, i64 0, i64 0), i64 %evalue6) #3
  %evalue8 = load i64, i64* %"<rangeremap>"
  %gvalue9 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @4, i64 0, i64 0), i64 %evalue8) #3
  %evalue10 = load <2 x double>, <2 x double>* %"<rangein>"
  %gvalue11 = call <2 x double> @"_export@USU"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @14, i64 0, i64 0), <2 x double> %evalue10) #3
  %evalue12 = load <2 x double>, <2 x double>* %"<rangeout>"
  %gvalue13 = call <2 x double> @"_export@USU"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @15, i64 0, i64 0), <2 x double> %evalue12) #3
  %evalue14 = load i8*, i8** %"<scatterptsattribute>"
  %gvalue15 = call i8* @"_export@SSS"(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @7, i64 0, i64 0), i8* %evalue14) #3
  %evalue16 = load double, double* %"<scatterseed>"
  %gvalue17 = call double @"_export@FSF"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @8, i64 0, i64 0), double %evalue16) #3
  %evalue18 = load i64, i64* %"<useptsinput>"
  %gvalue19 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @10, i64 0, i64 0), i64 %evalue18) #3
  %evalue20 = load i8*, i8** %"<ptsinputgroup>"
  %gvalue21 = call i8* @"_export@SSS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @11, i64 0, i64 0), i8* %evalue20) #3
  store i64 %gvalue, i64* @iteration
  store i64 %gvalue3, i64* @scatterfrom
  store i64 %gvalue5, i64* @scatterpts
  store i64 %gvalue7, i64* @scatterptsscaling
  store i64 %gvalue9, i64* @rangeremap
  store <2 x double> %gvalue11, <2 x double>* @rangein
  store <2 x double> %gvalue13, <2 x double>* @rangeout
  store i8* %gvalue15, i8** @scatterptsattribute
  store double %gvalue17, double* @scatterseed
  store i64 %gvalue19, i64* @useptsinput
  store i8* %gvalue21, i8** @ptsinputgroup
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

declare <2 x double> @"_export@USU"(i8*, <2 x double>)

declare i8* @"_export@SSS"(i8*, i8*)

declare double @"_export@FSF"(i8*, double)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0, i64 0, i64 0, i64 0, i64 0, <2 x double> zeroinitializer, <2 x double> zeroinitializer, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @12, i64 0, i64 0), double 0.000000e+00, i64 0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @12, i64 0, i64 0))
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}

;_code_end
