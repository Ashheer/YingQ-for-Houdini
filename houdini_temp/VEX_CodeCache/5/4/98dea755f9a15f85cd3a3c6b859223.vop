;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [11 x i8] c"edgelength\00"
@1 = private constant [19 x i8] c"vex_selectiongroup\00"
@2 = private constant [0 x i64] zeroinitializer
@3 = private constant [0 x double] zeroinitializer
@nebs = external global i64*
@nearptidx = external global i64
@edgelength = external global double
@dist = external global double*
@group___tempgrp_nonOverlapMaxpscale_fee1 = external global i64
@diff = external global double
@4 = private constant [5 x i8] c"nebs\00"
@5 = private constant [10 x i8] c"nearptidx\00"
@6 = private constant [5 x i8] c"dist\00"
@7 = private constant [41 x i8] c"group___tempgrp_nonOverlapMaxpscale_fee1\00"
@8 = private constant [5 x i8] c"diff\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@[IIF[FIF"(i64** %_bound_nebs, i64* %_bound_nearptidx, double* %_bound_edgelength, double** %_bound_dist, i64* %_bound_group___tempgrp_nonOverlapMaxpscale_fee1, double* %_bound_diff) #0 {
__llvm_entry:
  %_bound_nebs1 = load i64*, i64** %_bound_nebs
  %_bound_nearptidx2 = load i64, i64* %_bound_nearptidx
  %return = call i64 @"getcomp@I[II"(i64* %_bound_nebs1, i64 %_bound_nearptidx2)
  %return3 = call double @"point@FISI"(i64 0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @0, i64 0, i64 0), i64 %return)
  %_bound_edgelength5 = load double, double* %_bound_edgelength
  %output = fadd double %return3, %_bound_edgelength5
  %_bound_dist6 = load double*, double** %_bound_dist
  %_bound_nearptidx7 = load i64, i64* %_bound_nearptidx
  %return8 = call double @"getcomp@F[FI"(double* %_bound_dist6, i64 %_bound_nearptidx7)
  %return9 = fcmp oge double %output, %return8
  br i1 %return9, label %true, label %false

true:                                             ; preds = %__llvm_entry
  store i64 1, i64* %_bound_group___tempgrp_nonOverlapMaxpscale_fee1
  br label %end

false:                                            ; preds = %__llvm_entry
  %return11 = call i8* @"chs@SS"(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @1, i64 0, i64 0))
  %_bound_nebs12 = load i64*, i64** %_bound_nebs
  %return14 = call i64 @"getcomp@I[II"(i64* %_bound_nebs12, i64 %_bound_nearptidx7)
  %return15 = call i64 @"inpointgroup@IISI"(i64 0, i8* %return11, i64 %return14)
  %0 = icmp ne i64 %return15, 0
  br i1 %0, label %true16, label %end

end:                                              ; preds = %true42, %false43, %false, %true
  br label %UnifiedReturnBlock

true16:                                           ; preds = %false
  %_bound_diff18 = load double, double* %_bound_diff
  %_bound_dist19 = load double*, double** %_bound_dist
  %_bound_nearptidx20 = load i64, i64* %_bound_nearptidx
  %return21 = call double @"getcomp@F[FI"(double* %_bound_dist19, i64 %_bound_nearptidx20)
  %output23 = fsub double %return21, %return3
  %return24 = call double @"min@FFF"(double %_bound_diff18, double %output23)
  store double %return24, double* %_bound_diff
  %_bound_nearptidx25 = load i64, i64* %_bound_nearptidx
  %_bound_nebs26 = load i64*, i64** %_bound_nebs
  %return27 = call i64 @"len@I[I"(i64* %_bound_nebs26)
  %output28 = sub i64 %return27, 1
  %return29 = call i64 @"eq@III"(i64 %_bound_nearptidx25, i64 %output28)
  %1 = icmp ne i64 %return29, 0
  br i1 %1, label %true30, label %end31

true30:                                           ; preds = %true16
  store double %return24, double* %_bound_edgelength
  store i64 1, i64* %_bound_group___tempgrp_nonOverlapMaxpscale_fee1
  br label %UnifiedReturnBlock

end31:                                            ; preds = %true16
  %_bound_dist33 = load double*, double** %_bound_dist
  %output35 = add i64 %_bound_nearptidx25, 1
  store i64 %output35, i64* %_bound_nearptidx
  %return36 = call double @"getcomp@F[FI"(double* %_bound_dist33, i64 %output35)
  %output37 = call double @"div@FF"(double %return36, double 2.000000e+00)
  %_bound_diff38 = load double, double* %_bound_diff
  %return40 = fcmp ole double %_bound_diff38, %output37
  br i1 %return40, label %true42, label %false43

true42:                                           ; preds = %end31
  store double %_bound_diff38, double* %_bound_edgelength
  store i64 1, i64* %_bound_group___tempgrp_nonOverlapMaxpscale_fee1
  br label %end

false43:                                          ; preds = %end31
  store double %output37, double* %_bound_edgelength
  br label %end

UnifiedReturnBlock:                               ; preds = %true30, %end
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #1

; Function Attrs: nounwind
declare double @"point@FISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare double @"getcomp@F[FI"(double*, i64) #1

; Function Attrs: nounwind readnone
declare i8* @"chs@SS"(i8*) #1

; Function Attrs: nounwind
declare i64 @"inpointgroup@IISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare double @"min@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: nounwind
define void @__vex_snippet(i64* %nebs, i64 %nearptidx, double %edgelength, double* %dist, i64 %group___tempgrp_nonOverlapMaxpscale_fee1, double %diff) #2 {
__llvm_entry:
  %"<nearptidx>" = alloca i64
  %"<edgelength>" = alloca double
  %"<group___tempgrp_nonOverlapMaxpscale_fee1>" = alloca i64
  %"<diff>" = alloca double
  %0 = alloca i64*
  %1 = alloca double*
  store i64 %nearptidx, i64* %"<nearptidx>"
  store double %edgelength, double* %"<edgelength>"
  store i64 %group___tempgrp_nonOverlapMaxpscale_fee1, i64* %"<group___tempgrp_nonOverlapMaxpscale_fee1>"
  store double %diff, double* %"<diff>"
  store i64* %nebs, i64** %0
  store double* %dist, double** %1
  call void @"__vex_snippet_snippet@[IIF[FIF"(i64** %0, i64* %"<nearptidx>", double* %"<edgelength>", double** %1, i64* %"<group___tempgrp_nonOverlapMaxpscale_fee1>", double* %"<diff>")
  %gvalue = call i64* @"_export@[IS[I"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @4, i64 0, i64 0), i64* %nebs) #3
  %evalue3 = load i64, i64* %"<nearptidx>"
  %gvalue4 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @5, i64 0, i64 0), i64 %evalue3) #3
  %evalue5 = load double, double* %"<edgelength>"
  %gvalue6 = call double @"_export@FSF"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @0, i64 0, i64 0), double %evalue5) #3
  %gvalue8 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @6, i64 0, i64 0), double* %dist) #3
  %evalue9 = load i64, i64* %"<group___tempgrp_nonOverlapMaxpscale_fee1>"
  %gvalue10 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @7, i64 0, i64 0), i64 %evalue9) #3
  %evalue11 = load double, double* %"<diff>"
  %gvalue12 = call double @"_export@FSF"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @8, i64 0, i64 0), double %evalue11) #3
  store i64* %gvalue, i64** @nebs
  store i64 %gvalue4, i64* @nearptidx
  store double %gvalue6, double* @edgelength
  store double* %gvalue8, double** @dist
  store i64 %gvalue10, i64* @group___tempgrp_nonOverlapMaxpscale_fee1
  store double %gvalue12, double* @diff
  ret void
}

declare i64* @"_export@[IS[I"(i8*, i64*)

declare i64 @"_export@ISI"(i8*, i64)

declare double @"_export@FSF"(i8*, double)

declare double* @"_export@[FS[F"(i8*, double*)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64* getelementptr inbounds ([0 x i64], [0 x i64]* @2, i64 0, i64 0), i64 0, double 0.000000e+00, double* getelementptr inbounds ([0 x double], [0 x double]* @3, i64 0, i64 0), i64 0, double 0.000000e+00)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}

;_code_end
