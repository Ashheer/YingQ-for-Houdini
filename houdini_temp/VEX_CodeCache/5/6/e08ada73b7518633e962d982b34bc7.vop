;_name	/obj/geo1/solver1/d/s/selection/attribvop1
; ModuleID = 'obj_geo1_solver1_d_s_selection_attribvop1'

@0 = private constant [6 x i8] c"error\00"
@1 = private constant [0 x <3 x double>] zeroinitializer
@2 = private constant [4 x i8] c"ctr\00"
@3 = private constant [0 x double] zeroinitializer
@4 = private constant [4 x i8] c"rad\00"
@5 = private constant [0 x <4 x double>] zeroinitializer
@6 = private constant [5 x i8] c"rgba\00"
@octr = external global <3 x double>*
@ctr = external global <3 x double>*
@orad = external global double*
@rad = external global double*
@orgba = external global <4 x double>*
@rgba = external global <4 x double>*
@numpt = external global i64
@7 = private constant [5 x i8] c"octr\00"
@8 = private constant [5 x i8] c"orad\00"
@9 = private constant [6 x i8] c"orgba\00"
@10 = private constant [6 x i8] c"numpt\00"

define private void @"_obj_geo1_solver1_d_s_selection_attribvop1_snippet1@[V[V[F[F[P[PI"(<3 x double>** %_bound_octr, <3 x double>** %_bound_ctr, double** %_bound_orad, double** %_bound_rad, <4 x double>** %_bound_orgba, <4 x double>** %_bound_rgba, i64* %_bound_numpt) nounwind alwaysinline {
__llvm_entry:
  %_bound_ctr1 = load <3 x double>** %_bound_ctr
  store <3 x double>* %_bound_ctr1, <3 x double>** %_bound_octr
  %_bound_rad2 = load double** %_bound_rad
  store double* %_bound_rad2, double** %_bound_orad
  %_bound_rgba3 = load <4 x double>** %_bound_rgba
  store <4 x double>* %_bound_rgba3, <4 x double>** %_bound_orgba
  %return = call i64 @"neg@II"(i64 1)
  br label %cond

cond:                                             ; preds = %end24, %__llvm_entry
  %i.0 = phi i64 [ 0, %__llvm_entry ], [ %output32, %end24 ]
  %best.0 = phi double [ 1.000000e+09, %__llvm_entry ], [ %best.1, %end24 ]
  %partnerB.0 = phi i64 [ %return, %__llvm_entry ], [ %partnerB.2, %end24 ]
  %partnerA.0 = phi i64 [ %return, %__llvm_entry ], [ %partnerA.1, %end24 ]
  %_bound_numpt6 = load i64* %_bound_numpt
  %return7 = call i64 @"lt@III"(i64 %i.0, i64 %_bound_numpt6)
  %0 = icmp ne i64 %return7, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %return8 = call double @"nrandom@F"()
  %_bound_numpt9 = load i64* %_bound_numpt
  %cast = sitofp i64 %_bound_numpt9 to double
  %output = fmul double %return8, %cast
  %cast10 = fptosi double %output to i64
  %return12 = call double @"point@FISI"(i64 0, i8* getelementptr inbounds ([6 x i8]* @0, i64 0, i64 0), i64 %cast10)
  %return15 = fcmp olt double %return12, %best.0
  br i1 %return15, label %true, label %end17

end:                                              ; preds = %cond
  %_bound_rad33 = load double** %_bound_rad
  %return34 = call i64 @"len@I[F"(double* %_bound_rad33)
  %return35 = call double @"nrandom@F"()
  %cast37 = sitofp i64 %return34 to double
  %output38 = fmul double %return35, %cast37
  %cast39 = fptosi double %output38 to i64
  %return41 = call <3 x double>* @"point@[VISI"(i64 0, i8* getelementptr inbounds ([4 x i8]* @2, i64 0, i64 0), i64 %partnerA.0)
  %return43 = call <3 x double>* @"point@[VISI"(i64 0, i8* getelementptr inbounds ([4 x i8]* @2, i64 0, i64 0), i64 %partnerB.0)
  %return45 = call double* @"point@[FISI"(i64 0, i8* getelementptr inbounds ([4 x i8]* @4, i64 0, i64 0), i64 %partnerA.0)
  %return47 = call double* @"point@[FISI"(i64 0, i8* getelementptr inbounds ([4 x i8]* @4, i64 0, i64 0), i64 %partnerB.0)
  %return49 = call <4 x double>* @"point@[PISI"(i64 0, i8* getelementptr inbounds ([5 x i8]* @6, i64 0, i64 0), i64 %partnerA.0)
  %return51 = call <4 x double>* @"point@[PISI"(i64 0, i8* getelementptr inbounds ([5 x i8]* @6, i64 0, i64 0), i64 %partnerB.0)
  %return55 = call <3 x double>* @"slice@[V[VIIIIII"(<3 x double>* %return41, i64 1, i64 0, i64 1, i64 %cast39, i64 0, i64 0)
  %output56 = call <3 x double>* @"push@[V[V"(<3 x double>* getelementptr inbounds ([0 x <3 x double>]* @1, i64 0, i64 0), <3 x double>* %return55)
  %return60 = call <3 x double>* @"slice@[V[VIIIIII"(<3 x double>* %return43, i64 1, i64 %cast39, i64 0, i64 0, i64 0, i64 0)
  %output61 = call <3 x double>* @"push@[V[V"(<3 x double>* %output56, <3 x double>* %return60)
  %return65 = call double* @"slice@[F[FIIIIII"(double* %return45, i64 1, i64 0, i64 1, i64 %cast39, i64 0, i64 0)
  %output66 = call double* @"push@[F[F"(double* getelementptr inbounds ([0 x double]* @3, i64 0, i64 0), double* %return65)
  %return70 = call double* @"slice@[F[FIIIIII"(double* %return47, i64 1, i64 %cast39, i64 0, i64 0, i64 0, i64 0)
  %output71 = call double* @"push@[F[F"(double* %output66, double* %return70)
  %return75 = call <4 x double>* @"slice@[P[PIIIIII"(<4 x double>* %return49, i64 1, i64 0, i64 1, i64 %cast39, i64 0, i64 0)
  %output76 = call <4 x double>* @"push@[P[P"(<4 x double>* getelementptr inbounds ([0 x <4 x double>]* @5, i64 0, i64 0), <4 x double>* %return75)
  %return80 = call <4 x double>* @"slice@[P[PIIIIII"(<4 x double>* %return51, i64 1, i64 %cast39, i64 0, i64 0, i64 0, i64 0)
  %output81 = call <4 x double>* @"push@[P[P"(<4 x double>* %output76, <4 x double>* %return80)
  store <3 x double>* %output61, <3 x double>** %_bound_ctr
  store double* %output71, double** %_bound_rad
  store <4 x double>* %output81, <4 x double>** %_bound_rgba
  ret void

true:                                             ; preds = %body
  br label %end17

end17:                                            ; preds = %true, %body
  %best.1 = phi double [ %return12, %true ], [ %best.0, %body ]
  %partnerB.1 = phi i64 [ %partnerA.0, %true ], [ %partnerB.0, %body ]
  %partnerA.1 = phi i64 [ %cast10, %true ], [ %partnerA.0, %body ]
  %return22 = call i64 @"lt@III"(i64 %partnerB.1, i64 0)
  %1 = icmp ne i64 %return22, 0
  br i1 %1, label %true23, label %end24

true23:                                           ; preds = %end17
  %return25 = call double @"nrandom@F"()
  %_bound_numpt26 = load i64* %_bound_numpt
  %cast27 = sitofp i64 %_bound_numpt26 to double
  %output28 = fmul double %return25, %cast27
  %cast29 = fptosi double %output28 to i64
  br label %end24

end24:                                            ; preds = %true23, %end17
  %partnerB.2 = phi i64 [ %cast29, %true23 ], [ %partnerB.1, %end17 ]
  %output32 = add i64 %i.0, 1
  br label %cond
}

declare i64 @"neg@II"(i64) nounwind readnone

declare i64 @"lt@III"(i64, i64) nounwind readnone

declare double @"nrandom@F"() nounwind

declare double @"point@FISI"(i64, i8*, i64) nounwind

declare i64 @"len@I[F"(double*) nounwind readnone

declare <3 x double>* @"point@[VISI"(i64, i8*, i64) nounwind

declare double* @"point@[FISI"(i64, i8*, i64) nounwind

declare <4 x double>* @"point@[PISI"(i64, i8*, i64) nounwind

declare <3 x double>* @"slice@[V[VIIIIII"(<3 x double>*, i64, i64, i64, i64, i64, i64) nounwind

declare <3 x double>* @"push@[V[V"(<3 x double>*, <3 x double>*) nounwind readnone

declare double* @"slice@[F[FIIIIII"(double*, i64, i64, i64, i64, i64, i64) nounwind

declare double* @"push@[F[F"(double*, double*) nounwind readnone

declare <4 x double>* @"slice@[P[PIIIIII"(<4 x double>*, i64, i64, i64, i64, i64, i64) nounwind

declare <4 x double>* @"push@[P[P"(<4 x double>*, <4 x double>*) nounwind readnone

define void @obj_geo1_solver1_d_s_selection_attribvop1(<3 x double>* %octr, <3 x double>* %ctr, double* %orad, double* %rad, <4 x double>* %orgba, <4 x double>* %rgba, i64 %numpt) nounwind {
__llvm_entry:
  %"<ctr>" = alloca <3 x double>*
  %"<orad>" = alloca double*
  %"<rad>" = alloca double*
  %"<orgba>" = alloca <4 x double>*
  %"<rgba>" = alloca <4 x double>*
  %0 = alloca i64
  %"<octr>" = alloca <3 x double>*
  store <3 x double>* %octr, <3 x double>** %"<octr>"
  store <3 x double>* %ctr, <3 x double>** %"<ctr>"
  store double* %orad, double** %"<orad>"
  store double* %rad, double** %"<rad>"
  store <4 x double>* %orgba, <4 x double>** %"<orgba>"
  store <4 x double>* %rgba, <4 x double>** %"<rgba>"
  store i64 %numpt, i64* %0
  call void @"_obj_geo1_solver1_d_s_selection_attribvop1_snippet1@[V[V[F[F[P[PI"(<3 x double>** %"<octr>", <3 x double>** %"<ctr>", double** %"<orad>", double** %"<rad>", <4 x double>** %"<orgba>", <4 x double>** %"<rgba>", i64* %0)
  %evalue = load <3 x double>** %"<octr>"
  %gvalue = call <3 x double>* @"_export@[VS[V"(i8* getelementptr inbounds ([5 x i8]* @7, i64 0, i64 0), <3 x double>* %evalue) nounwind readonly
  %evalue2 = load <3 x double>** %"<ctr>"
  %gvalue3 = call <3 x double>* @"_export@[VS[V"(i8* getelementptr inbounds ([4 x i8]* @2, i64 0, i64 0), <3 x double>* %evalue2) nounwind readonly
  %evalue4 = load double** %"<orad>"
  %gvalue5 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([5 x i8]* @8, i64 0, i64 0), double* %evalue4) nounwind readonly
  %evalue6 = load double** %"<rad>"
  %gvalue7 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([4 x i8]* @4, i64 0, i64 0), double* %evalue6) nounwind readonly
  %evalue8 = load <4 x double>** %"<orgba>"
  %gvalue9 = call <4 x double>* @"_export@[PS[P"(i8* getelementptr inbounds ([6 x i8]* @9, i64 0, i64 0), <4 x double>* %evalue8) nounwind readonly
  %evalue10 = load <4 x double>** %"<rgba>"
  %gvalue11 = call <4 x double>* @"_export@[PS[P"(i8* getelementptr inbounds ([5 x i8]* @6, i64 0, i64 0), <4 x double>* %evalue10) nounwind readonly
  %gvalue13 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8]* @10, i64 0, i64 0), i64 %numpt) nounwind readonly
  store <3 x double>* %gvalue, <3 x double>** @octr
  store <3 x double>* %gvalue3, <3 x double>** @ctr
  store double* %gvalue5, double** @orad
  store double* %gvalue7, double** @rad
  store <4 x double>* %gvalue9, <4 x double>** @orgba
  store <4 x double>* %gvalue11, <4 x double>** @rgba
  store i64 %gvalue13, i64* @numpt
  ret void
}

declare <3 x double>* @"_export@[VS[V"(i8*, <3 x double>*)

declare double* @"_export@[FS[F"(i8*, double*)

declare <4 x double>* @"_export@[PS[P"(i8*, <4 x double>*)

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @obj_geo1_solver1_d_s_selection_attribvop1(<3 x double>* getelementptr inbounds ([0 x <3 x double>]* @1, i64 0, i64 0), <3 x double>* getelementptr inbounds ([0 x <3 x double>]* @1, i64 0, i64 0), double* getelementptr inbounds ([0 x double]* @3, i64 0, i64 0), double* getelementptr inbounds ([0 x double]* @3, i64 0, i64 0), <4 x double>* getelementptr inbounds ([0 x <4 x double>]* @5, i64 0, i64 0), <4 x double>* getelementptr inbounds ([0 x <4 x double>]* @5, i64 0, i64 0), i64 0)
  ret void
}

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = metadata !{metadata !"cvex"}
!1 = metadata !{metadata !"18.5.633"}
!2 = metadata !{metadata !"64"}

;_code_end
