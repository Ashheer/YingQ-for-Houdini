;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [0 x double] zeroinitializer
@1 = private constant [2 x i8] c"/\00"
@2 = private constant [0 x i8*] zeroinitializer
@boneCapture_pCaptPath = external global i8**
@boneCapture_pCaptData = external global double*
@3 = private constant [22 x i8] c"boneCapture_pCaptPath\00"
@4 = private constant [22 x i8] c"boneCapture_pCaptData\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@[S[F"(i8*** %_bound_boneCapture_pCaptPath, double** %_bound_boneCapture_pCaptData) #0 {
__llvm_entry:
  %_bound_boneCapture_pCaptPath1 = load i8**, i8*** %_bound_boneCapture_pCaptPath
  %return = call i64 @"len@I[S"(i8** %_bound_boneCapture_pCaptPath1)
  br label %cond

cond:                                             ; preds = %body, %__llvm_entry
  %idx.0 = phi i64 [ 0, %__llvm_entry ], [ %output34, %body ]
  %out_pCaptData.0 = phi double* [ getelementptr inbounds ([0 x double], [0 x double]* @0, i64 0, i64 0), %__llvm_entry ], [ %output32, %body ]
  %return4 = call i64 @"lt@III"(i64 %idx.0, i64 %return)
  %0 = icmp ne i64 %return4, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %_bound_boneCapture_pCaptPath5 = load i8**, i8*** %_bound_boneCapture_pCaptPath
  %return7 = call i8* @"getcomp@S[SI"(i8** %_bound_boneCapture_pCaptPath5, i64 %idx.0)
  %return10 = call i8** @"split@[SSS"(i8* %return7, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @1, i64 0, i64 0))
  %return11 = call i8* @"getcomp@S[SI"(i8** %return10, i64 0)
  %return12 = call { i8*, i8** } @"setcomp@S[SSI"(i8** %_bound_boneCapture_pCaptPath5, i8* %return11, i64 %idx.0)
  %output = extractvalue { i8*, i8** } %return12, 1
  store i8** %output, i8*** %_bound_boneCapture_pCaptPath
  %_bound_boneCapture_pCaptData14 = load double*, double** %_bound_boneCapture_pCaptData
  %output16 = mul i64 %idx.0, 20
  %output19 = add i64 %output16, 16
  %return20 = call double* @"slice@[F[FIIIIII"(double* %_bound_boneCapture_pCaptData14, i64 1, i64 %output16, i64 1, i64 %output19, i64 0, i64 0)
  %return21 = call <16 x double> @"set@4[F"(double* %return20)
  %return23 = call <16 x double> @"invert@44"(<16 x double> %return21)
  %return25 = call <16 x double> @"invert@44"(<16 x double> %return23)
  %return26 = call double* @"set@[F4"(<16 x double> %return25)
  %return28 = call double* @"array@[F:FFFF"(double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00)
  %output29 = call double* @"append@[F[F"(double* %return26, double* %return28)
  %output32 = call double* @"append@[F[F"(double* %out_pCaptData.0, double* %output29)
  %output34 = add i64 %idx.0, 1
  br label %cond

end:                                              ; preds = %cond
  store double* %out_pCaptData.0, double** %_bound_boneCapture_pCaptData
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"len@I[S"(i8**) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i8* @"getcomp@S[SI"(i8**, i64) #1

; Function Attrs: nounwind readnone
declare i8** @"split@[SSS"(i8*, i8*) #1

; Function Attrs: nounwind readnone
declare { i8*, i8** } @"setcomp@S[SSI"(i8**, i8*, i64) #1

; Function Attrs: nounwind
declare double* @"slice@[F[FIIIIII"(double*, i64, i64, i64, i64, i64, i64) #2

; Function Attrs: alwaysinline
define private <16 x double> @"set@4[F"(double* %rw11) #3 {
__llvm_entry:
  %t_0_ = call double @"getcomp@F[FI"(double* %rw11, i64 0)
  %t_1_ = call double @"getcomp@F[FI"(double* %rw11, i64 1)
  %t_2_ = call double @"getcomp@F[FI"(double* %rw11, i64 2)
  %t_3_ = call double @"getcomp@F[FI"(double* %rw11, i64 3)
  %t_4_ = call double @"getcomp@F[FI"(double* %rw11, i64 4)
  %t_5_ = call double @"getcomp@F[FI"(double* %rw11, i64 5)
  %t_6_ = call double @"getcomp@F[FI"(double* %rw11, i64 6)
  %t_7_ = call double @"getcomp@F[FI"(double* %rw11, i64 7)
  %t_8_ = call double @"getcomp@F[FI"(double* %rw11, i64 8)
  %t_9_ = call double @"getcomp@F[FI"(double* %rw11, i64 9)
  %t_a_ = call double @"getcomp@F[FI"(double* %rw11, i64 10)
  %t_b_ = call double @"getcomp@F[FI"(double* %rw11, i64 11)
  %t_c_ = call double @"getcomp@F[FI"(double* %rw11, i64 12)
  %t_d_ = call double @"getcomp@F[FI"(double* %rw11, i64 13)
  %t_e_ = call double @"getcomp@F[FI"(double* %rw11, i64 14)
  %t_f_ = call double @"getcomp@F[FI"(double* %rw11, i64 15)
  %rw049 = call <16 x double> @"set@4FFFFFFFFFFFFFFFF"(double %t_0_, double %t_1_, double %t_2_, double %t_3_, double %t_4_, double %t_5_, double %t_6_, double %t_7_, double %t_8_, double %t_9_, double %t_a_, double %t_b_, double %t_c_, double %t_d_, double %t_e_, double %t_f_)
  ret <16 x double> %rw049
}

; Function Attrs: nounwind readnone
declare double @"getcomp@F[FI"(double*, i64) #1

; Function Attrs: nounwind readnone
declare <16 x double> @"set@4FFFFFFFFFFFFFFFF"(double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double) #1

; Function Attrs: nounwind readnone
declare <16 x double> @"invert@44"(<16 x double>) #1

; Function Attrs: alwaysinline
define private double* @"set@[F4"(<16 x double> %rw11) #3 {
__llvm_entry:
  %rw03 = call double* @"resize@[FI"(double* undef, i64 0)
  %t_0_ = call { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } @"assign@FFFFFFFFFFFFFFFF4"(<16 x double> %rw11)
  %t_0_5 = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 0
  %t_1_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 1
  %t_2_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 2
  %t_3_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 3
  %t_4_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 4
  %t_5_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 5
  %t_6_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 6
  %t_7_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 7
  %t_8_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 8
  %t_9_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 9
  %t_a_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 10
  %t_b_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 11
  %t_c_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 12
  %t_d_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 13
  %t_e_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 14
  %t_f_ = extractvalue { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } %t_0_, 15
  %rw08 = call double* @"push@[FF"(double* %rw03, double %t_0_5)
  %rw011 = call double* @"push@[FF"(double* %rw08, double %t_1_)
  %rw014 = call double* @"push@[FF"(double* %rw011, double %t_2_)
  %rw017 = call double* @"push@[FF"(double* %rw014, double %t_3_)
  %rw020 = call double* @"push@[FF"(double* %rw017, double %t_4_)
  %rw023 = call double* @"push@[FF"(double* %rw020, double %t_5_)
  %rw026 = call double* @"push@[FF"(double* %rw023, double %t_6_)
  %rw029 = call double* @"push@[FF"(double* %rw026, double %t_7_)
  %rw032 = call double* @"push@[FF"(double* %rw029, double %t_8_)
  %rw035 = call double* @"push@[FF"(double* %rw032, double %t_9_)
  %rw038 = call double* @"push@[FF"(double* %rw035, double %t_a_)
  %rw041 = call double* @"push@[FF"(double* %rw038, double %t_b_)
  %rw044 = call double* @"push@[FF"(double* %rw041, double %t_c_)
  %rw047 = call double* @"push@[FF"(double* %rw044, double %t_d_)
  %rw050 = call double* @"push@[FF"(double* %rw047, double %t_e_)
  %rw053 = call double* @"push@[FF"(double* %rw050, double %t_f_)
  ret double* %rw053
}

; Function Attrs: nounwind readnone
declare double* @"resize@[FI"(double*, i64) #1

; Function Attrs: nounwind
declare { double, double, double, double, double, double, double, double, double, double, double, double, double, double, double, double } @"assign@FFFFFFFFFFFFFFFF4"(<16 x double>) #2

; Function Attrs: nounwind readnone
declare double* @"push@[FF"(double*, double) #1

; Function Attrs: nounwind readnone
declare double* @"array@[F:FFFF"(double, double, double, double) #1

; Function Attrs: nounwind
declare double* @"append@[F[F"(double*, double*) #2

; Function Attrs: nounwind
define void @__vex_snippet(i8** %boneCapture_pCaptPath, double* %boneCapture_pCaptData) #2 {
__llvm_entry:
  %"<boneCapture_pCaptData>" = alloca double*
  %"<boneCapture_pCaptPath>" = alloca i8**
  store i8** %boneCapture_pCaptPath, i8*** %"<boneCapture_pCaptPath>"
  store double* %boneCapture_pCaptData, double** %"<boneCapture_pCaptData>"
  call void @"__vex_snippet_snippet@[S[F"(i8*** %"<boneCapture_pCaptPath>", double** %"<boneCapture_pCaptData>")
  %evalue = load i8**, i8*** %"<boneCapture_pCaptPath>"
  %gvalue = call i8** @"_export@[SS[S"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @3, i64 0, i64 0), i8** %evalue) #4
  %evalue1 = load double*, double** %"<boneCapture_pCaptData>"
  %gvalue2 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @4, i64 0, i64 0), double* %evalue1) #4
  store i8** %gvalue, i8*** @boneCapture_pCaptPath
  store double* %gvalue2, double** @boneCapture_pCaptData
  ret void
}

declare i8** @"_export@[SS[S"(i8*, i8**)

declare double* @"_export@[FS[F"(i8*, double*)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i8** getelementptr inbounds ([0 x i8*], [0 x i8*]* @2, i64 0, i64 0), double* getelementptr inbounds ([0 x double], [0 x double]* @0, i64 0, i64 0))
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { alwaysinline }
attributes #4 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}

;_code_end
