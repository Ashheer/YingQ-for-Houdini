;_name	/obj/geo1/solver1/d/s/mutate/attribvop1
; ModuleID = 'obj_geo1_solver1_d_s_mutate_attribvop1'

@0 = private constant [14 x i8] c"Mutation_Rate\00"
@1 = private constant [21 x i8] c"Spatial_Mutation_Amp\00"
@2 = private constant [19 x i8] c"Color_Mutation_Amp\00"
@3 = private constant [17 x i8] c"Rad_Mutation_Amp\00"
@4 = private constant [0 x <3 x double>] zeroinitializer
@5 = private constant [0 x double] zeroinitializer
@6 = private constant [0 x <4 x double>] zeroinitializer
@7 = private constant [3 x i8] c"Cd\00"
@ctr = external global <3 x double>*
@rad = external global double*
@rgba = external global <4 x double>*
@8 = private constant [4 x i8] c"ctr\00"
@9 = private constant [4 x i8] c"rad\00"
@10 = private constant [5 x i8] c"rgba\00"

define private void @"_obj_geo1_solver1_d_s_mutate_attribvop1_snippet1@[V[F[P"(<3 x double>** %_bound_ctr, double** %_bound_rad, <4 x double>** %_bound_rgba) nounwind alwaysinline {
__llvm_entry:
  %return = call double @"chf@FS"(i8* getelementptr inbounds ([14 x i8]* @0, i64 0, i64 0))
  %return1 = call double @"chf@FS"(i8* getelementptr inbounds ([21 x i8]* @1, i64 0, i64 0))
  %return2 = call double @"chf@FS"(i8* getelementptr inbounds ([19 x i8]* @2, i64 0, i64 0))
  %return3 = call double @"chf@FS"(i8* getelementptr inbounds ([17 x i8]* @3, i64 0, i64 0))
  %return6 = call <3 x double> @"set@VFFF"(double %return1, double %return1, double 0.000000e+00)
  %return8 = call double @"neg@FF"(double %return1)
  %return11 = call <3 x double> @"set@VFFF"(double %return8, double %return8, double 0.000000e+00)
  %return13 = call double @"neg@FF"(double %return2)
  %return18 = call <3 x double> @"set@VFFF"(double %return13, double %return13, double %return13)
  %return22 = call <3 x double> @"set@VFFF"(double %return2, double %return2, double %return2)
  %_bound_ctr23 = load <3 x double>** %_bound_ctr
  %_bound_rad24 = load double** %_bound_rad
  %_bound_rgba25 = load <4 x double>** %_bound_rgba
  %return27 = call i64 @"len@I[F"(double* %_bound_rad24)
  br label %cond

cond:                                             ; preds = %end35, %__llvm_entry
  %rgba.0 = phi <4 x double>* [ %_bound_rgba25, %__llvm_entry ], [ %rgba.1, %end35 ]
  %rad.0 = phi double* [ %_bound_rad24, %__llvm_entry ], [ %rad.1, %end35 ]
  %ctr.0 = phi <3 x double>* [ %_bound_ctr23, %__llvm_entry ], [ %ctr.1, %end35 ]
  %i.0 = phi i64 [ 0, %__llvm_entry ], [ %output98, %end35 ]
  %return30 = call i64 @"lt@III"(i64 %i.0, i64 %return27)
  %0 = icmp ne i64 %return30, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %return31 = call double @"nrandom@F"()
  %return33 = fcmp olt double %return31, %return
  br i1 %return33, label %true, label %end35

end:                                              ; preds = %cond
  store <3 x double>* %ctr.0, <3 x double>** %_bound_ctr
  store double* %rad.0, double** %_bound_rad
  store <4 x double>* %rgba.0, <4 x double>** %_bound_rgba
  ret void

true:                                             ; preds = %body
  %return36 = call <3 x double> @"nrandom@V"()
  %return39 = call <3 x double> @"fit01@VVVV"(<3 x double> %return36, <3 x double> %return11, <3 x double> %return6)
  %return40 = call double @"nrandom@F"()
  %return42 = call double @"neg@FF"(double %return3)
  %return44 = call double @"fit01@FFFF"(double %return40, double %return42, double %return3)
  %return45 = call double @"nrandom@F"()
  %return46 = call double @"nrandom@F"()
  %return47 = call i64 @"npoints@II"(i64 1)
  %cast = sitofp i64 %return47 to double
  %output = fmul double %return46, %cast
  %cast48 = fptosi double %output to i64
  %return50 = call <3 x double> @"point@VISI"(i64 1, i8* getelementptr inbounds ([3 x i8]* @7, i64 0, i64 0), i64 %cast48)
  %return51 = call <3 x double> @"nrandom@V"()
  %return54 = call <3 x double> @"fit01@VVVV"(<3 x double> %return51, <3 x double> %return18, <3 x double> %return22)
  %output57 = call <3 x double> @"add@VV"(<3 x double> %return50, <3 x double> %return54)
  %return59 = call double @"getcomp@FVI"(<3 x double> %output57, i64 0)
  %return61 = call double @"getcomp@FVI"(<3 x double> %output57, i64 1)
  %return63 = call double @"getcomp@FVI"(<3 x double> %output57, i64 2)
  %return65 = call <4 x double> @"set@PFFFF"(double %return59, double %return61, double %return63, double %return45)
  %return69 = call <3 x double> @"getcomp@V[VI"(<3 x double>* %ctr.0, i64 %i.0)
  %output71 = call <3 x double> @"add@VV"(<3 x double> %return69, <3 x double> %return39)
  %return74 = call <3 x double> @"clamp@VVVV"(<3 x double> %output71, <3 x double> <double -5.000000e-01, double -5.000000e-01, double 0.000000e+00>, <3 x double> <double 5.000000e-01, double 5.000000e-01, double 0.000000e+00>)
  %return75 = call { <3 x double>, <3 x double>* } @"setcomp@V[VVI"(<3 x double>* %ctr.0, <3 x double> %return74, i64 %i.0)
  %output77 = extractvalue { <3 x double>, <3 x double>* } %return75, 1
  %return81 = call double @"getcomp@F[FI"(double* %rad.0, i64 %i.0)
  %output83 = fadd double %return81, %return44
  %return84 = call double @"clamp@FFFF"(double %output83, double 0.000000e+00, double 1.000000e+00)
  %return86 = call { double, double* } @"setcomp@F[FFI"(double* %rad.0, double %return84, i64 %i.0)
  %output88 = extractvalue { double, double* } %return86, 1
  %return91 = call <4 x double> @"clamp@PPPP"(<4 x double> %return65, <4 x double> zeroinitializer, <4 x double> <double 1.000000e+00, double 1.000000e+00, double 1.000000e+00, double 1.000000e+00>)
  %return93 = call { <4 x double>, <4 x double>* } @"setcomp@P[PPI"(<4 x double>* %rgba.0, <4 x double> %return91, i64 %i.0)
  %output95 = extractvalue { <4 x double>, <4 x double>* } %return93, 1
  br label %end35

end35:                                            ; preds = %true, %body
  %rgba.1 = phi <4 x double>* [ %output95, %true ], [ %rgba.0, %body ]
  %rad.1 = phi double* [ %output88, %true ], [ %rad.0, %body ]
  %ctr.1 = phi <3 x double>* [ %output77, %true ], [ %ctr.0, %body ]
  %output98 = add i64 %i.0, 1
  br label %cond
}

declare double @"chf@FS"(i8*) nounwind readnone

declare <3 x double> @"set@VFFF"(double, double, double) nounwind readnone

declare double @"neg@FF"(double) nounwind readnone

declare i64 @"len@I[F"(double*) nounwind readnone

declare i64 @"lt@III"(i64, i64) nounwind readnone

declare double @"nrandom@F"() nounwind

define private <3 x double> @"nrandom@V"() alwaysinline {
__llvm_entry:
  %t_0_ = call double @"nrandom@F"()
  %t_1_ = call double @"nrandom@F"()
  %t_2_ = call double @"nrandom@F"()
  %rw03 = call <3 x double> @"setcomp@VFI"(<3 x double> undef, double %t_0_, i64 0)
  %rw07 = call <3 x double> @"setcomp@VFI"(<3 x double> %rw03, double %t_1_, i64 1)
  %rw011 = call <3 x double> @"setcomp@VFI"(<3 x double> %rw07, double %t_2_, i64 2)
  ret <3 x double> %rw011
}

declare <3 x double> @"setcomp@VFI"(<3 x double>, double, i64) nounwind readnone

declare <3 x double> @"fit01@VVVV"(<3 x double>, <3 x double>, <3 x double>) nounwind

declare double @"fit01@FFFF"(double, double, double) nounwind

declare i64 @"npoints@II"(i64) nounwind

declare <3 x double> @"point@VISI"(i64, i8*, i64) nounwind

declare <3 x double> @"add@VV"(<3 x double>, <3 x double>) nounwind readnone

declare double @"getcomp@FVI"(<3 x double>, i64) nounwind readnone

declare <4 x double> @"set@PFFFF"(double, double, double, double) nounwind readnone

declare <3 x double> @"getcomp@V[VI"(<3 x double>*, i64) nounwind readnone

declare <3 x double> @"clamp@VVVV"(<3 x double>, <3 x double>, <3 x double>) nounwind

declare { <3 x double>, <3 x double>* } @"setcomp@V[VVI"(<3 x double>*, <3 x double>, i64) nounwind readnone

declare double @"getcomp@F[FI"(double*, i64) nounwind readnone

declare double @"clamp@FFFF"(double, double, double) nounwind

declare { double, double* } @"setcomp@F[FFI"(double*, double, i64) nounwind readnone

declare <4 x double> @"clamp@PPPP"(<4 x double>, <4 x double>, <4 x double>) nounwind

declare { <4 x double>, <4 x double>* } @"setcomp@P[PPI"(<4 x double>*, <4 x double>, i64) nounwind readnone

define void @obj_geo1_solver1_d_s_mutate_attribvop1(<3 x double>* %ctr, double* %rad, <4 x double>* %rgba) nounwind {
__llvm_entry:
  %"<rad>" = alloca double*
  %"<rgba>" = alloca <4 x double>*
  %"<ctr>" = alloca <3 x double>*
  store <3 x double>* %ctr, <3 x double>** %"<ctr>"
  store double* %rad, double** %"<rad>"
  store <4 x double>* %rgba, <4 x double>** %"<rgba>"
  call void @"_obj_geo1_solver1_d_s_mutate_attribvop1_snippet1@[V[F[P"(<3 x double>** %"<ctr>", double** %"<rad>", <4 x double>** %"<rgba>")
  %evalue = load <3 x double>** %"<ctr>"
  %gvalue = call <3 x double>* @"_export@[VS[V"(i8* getelementptr inbounds ([4 x i8]* @8, i64 0, i64 0), <3 x double>* %evalue) nounwind readonly
  %evalue1 = load double** %"<rad>"
  %gvalue2 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([4 x i8]* @9, i64 0, i64 0), double* %evalue1) nounwind readonly
  %evalue3 = load <4 x double>** %"<rgba>"
  %gvalue4 = call <4 x double>* @"_export@[PS[P"(i8* getelementptr inbounds ([5 x i8]* @10, i64 0, i64 0), <4 x double>* %evalue3) nounwind readonly
  store <3 x double>* %gvalue, <3 x double>** @ctr
  store double* %gvalue2, double** @rad
  store <4 x double>* %gvalue4, <4 x double>** @rgba
  ret void
}

declare <3 x double>* @"_export@[VS[V"(i8*, <3 x double>*)

declare double* @"_export@[FS[F"(i8*, double*)

declare <4 x double>* @"_export@[PS[P"(i8*, <4 x double>*)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @obj_geo1_solver1_d_s_mutate_attribvop1(<3 x double>* getelementptr inbounds ([0 x <3 x double>]* @4, i64 0, i64 0), double* getelementptr inbounds ([0 x double]* @5, i64 0, i64 0), <4 x double>* getelementptr inbounds ([0 x <4 x double>]* @6, i64 0, i64 0))
  ret void
}

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = metadata !{metadata !"cvex"}
!1 = metadata !{metadata !"18.5.633"}
!2 = metadata !{metadata !"64"}

;_code_end
