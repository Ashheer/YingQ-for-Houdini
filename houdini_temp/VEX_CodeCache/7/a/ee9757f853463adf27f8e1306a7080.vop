;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [7 x i8] c"attach\00"
@1 = private constant [4 x i8] c"pin\00"
@2 = private constant [7 x i8] c"stitch\00"
@3 = private constant [13 x i8] c"branchstitch\00"
@4 = private constant [9 x i8] c"distance\00"
@5 = private constant [13 x i8] c"attachnormal\00"
@6 = private constant [13 x i8] c"distanceline\00"
@7 = private constant [1 x i8] zeroinitializer
@8 = private constant [13 x i8] c"stretchshear\00"
@9 = private constant [5 x i8] c"weld\00"
@10 = private constant [7 x i8] c"ptprim\00"
@11 = private constant [0 x i64] zeroinitializer
@12 = private constant [7 x i8] c"attrib\00"
@13 = private constant [12 x i8] c"attribvalue\00"
@14 = private constant [7 x i8] c"source\00"
@15 = private constant [7 x i8] c"target\00"
@16 = private constant [4 x i8] c"min\00"
@17 = private constant [5 x i8] c"mult\00"
@18 = private constant [5 x i8] c"mean\00"
@19 = private constant [4 x i8] c"max\00"
@20 = private constant [6 x i8] c"value\00"
@21 = private constant [18 x i8] c"compressstiffness\00"
@22 = private constant [21 x i8] c"compressstiffnessexp\00"
@23 = private constant [14 x i8] c"attribpromote\00"
@24 = private constant [18 x i8] c"compressstiffattr\00"
@25 = private constant [17 x i8] c"compressstiffval\00"
@26 = private constant [18 x i8] c"compressstiffmode\00"
@compressstiffness = external global double

; Function Attrs: alwaysinline nounwind
define private i8* @"constraintAlias@SS"(i8** %type) #0 {
__llvm_entry:
  %type1 = load i8*, i8** %type
  %return = call i64 @"eq@ISS"(i8* %type1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @0, i64 0, i64 0))
  %0 = icmp ne i64 %return, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %end8, %end, %__llvm_entry
  %merge = phi i8* [ getelementptr inbounds ([4 x i8], [4 x i8]* @1, i64 0, i64 0), %__llvm_entry ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @4, i64 0, i64 0), %end ], [ getelementptr inbounds ([13 x i8], [13 x i8]* @6, i64 0, i64 0), %end8 ]
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  %return3 = call i64 @"eq@ISS"(i8* %type1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @2, i64 0, i64 0))
  %return5 = call i64 @"eq@ISS"(i8* %type1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @3, i64 0, i64 0))
  %return6 = call i64 @"or@III"(i64 %return3, i64 %return5)
  %1 = icmp ne i64 %return6, 0
  br i1 %1, label %true, label %end8

end8:                                             ; preds = %end
  %return10 = call i64 @"eq@ISS"(i8* %type1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @5, i64 0, i64 0))
  %2 = icmp ne i64 %return10, 0
  br i1 %2, label %true, label %end12

end12:                                            ; preds = %end8
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end12, %true
  %UnifiedRetVal = phi i8* [ %merge, %true ], [ %type1, %end12 ]
  ret i8* %UnifiedRetVal
}

; Function Attrs: nounwind readnone
declare i64 @"eq@ISS"(i8*, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #1

; Function Attrs: alwaysinline nounwind
define private double @"logscaleStiffness@FFF"(double* %k, double* %stiffness) #0 {
__llvm_entry:
  %k1 = load double, double* %k
  %stiffness2 = load double, double* %stiffness
  %output = fadd double %stiffness2, 1.000000e+00
  %return = call double @"log@FF"(double %output)
  %output3 = fmul double %k1, %return
  %return4 = call double @"exp@FF"(double %output3)
  %output5 = fsub double %return4, 1.000000e+00
  %return6 = call double @"clamp@FFFF"(double %output5, double 0.000000e+00, double 1.000000e+37)
  ret double %return6
}

; Function Attrs: nounwind readnone
declare double @"log@FF"(double) #1

; Function Attrs: nounwind readnone
declare double @"exp@FF"(double) #1

; Function Attrs: nounwind
declare double @"clamp@FFFF"(double, double, double) #2

; Function Attrs: alwaysinline nounwind
define private i64* @"getSourcePoints@[IS[I"(i8** %intype, i64** %pts) #0 {
__llvm_entry:
  %0 = alloca i8*
  %intype1 = load i8*, i8** %intype
  store i8* %intype1, i8** %0
  %constraintAlias = call i8* @"constraintAlias@SS"(i8** %0)
  %return = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @4, i64 0, i64 0))
  %return4 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @8, i64 0, i64 0))
  %return5 = call i64 @"or@III"(i64 %return, i64 %return4)
  %return7 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @9, i64 0, i64 0))
  %return8 = call i64 @"or@III"(i64 %return5, i64 %return7)
  %return10 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @10, i64 0, i64 0))
  %return11 = call i64 @"or@III"(i64 %return8, i64 %return10)
  %1 = icmp ne i64 %return11, 0
  %pts12 = load i64*, i64** %pts
  br i1 %1, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %return13 = call i64* @"slice@[I[IIIIIII"(i64* %pts12, i64 0, i64 0, i64 1, i64 1, i64 0, i64 0)
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end, %true
  %UnifiedRetVal = phi i64* [ %return13, %true ], [ %pts12, %end ]
  ret i64* %UnifiedRetVal
}

; Function Attrs: nounwind
declare i64* @"slice@[I[IIIIIII"(i64*, i64, i64, i64, i64, i64, i64) #2

; Function Attrs: alwaysinline nounwind
define private i64* @"getTargetPoints@[IS[I"(i8** %intype, i64** %pts) #0 {
__llvm_entry:
  %0 = alloca i8*
  %intype1 = load i8*, i8** %intype
  store i8* %intype1, i8** %0
  %constraintAlias = call i8* @"constraintAlias@SS"(i8** %0)
  %return = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @4, i64 0, i64 0))
  %return4 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @8, i64 0, i64 0))
  %return5 = call i64 @"or@III"(i64 %return, i64 %return4)
  %return7 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @9, i64 0, i64 0))
  %return8 = call i64 @"or@III"(i64 %return5, i64 %return7)
  %return10 = call i64 @"eq@ISS"(i8* %constraintAlias, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @10, i64 0, i64 0))
  %return11 = call i64 @"or@III"(i64 %return8, i64 %return10)
  %1 = icmp ne i64 %return11, 0
  br i1 %1, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %pts12 = load i64*, i64** %pts
  %return13 = call i64* @"slice@[I[IIIIIII"(i64* %pts12, i64 1, i64 1, i64 0, i64 0, i64 0, i64 0)
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end, %true
  %UnifiedRetVal = phi i64* [ %return13, %true ], [ getelementptr inbounds ([0 x i64], [0 x i64]* @11, i64 0, i64 0), %end ]
  ret i64* %UnifiedRetVal
}

; Function Attrs: alwaysinline nounwind
define private double @"accumScaleValues@FSI[ISIVSFSS"(i8** %type, i64* %ptgeo, i64** %inpts, i8** %primgeo, i64* %targetprim, <3 x double>* %uv, i8** %attr, double* %valscale, i8** %scalemode, i8** %promotion) #0 {
__llvm_entry:
  %0 = alloca i8*
  %1 = alloca i64*
  %2 = alloca i8*
  %3 = alloca i64*
  %scalemode1 = load i8*, i8** %scalemode
  %return = call i64 @"eq@ISS"(i8* %scalemode1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @12, i64 0, i64 0))
  %return3 = call i64 @"eq@ISS"(i8* %scalemode1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @13, i64 0, i64 0))
  %return4 = call i64 @"or@III"(i64 %return, i64 %return3)
  %4 = icmp ne i64 %return4, 0
  br i1 %4, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %inpts5 = load i64*, i64** %inpts
  %promotion6 = load i8*, i8** %promotion
  %return7 = call i64 @"eq@ISS"(i8* %promotion6, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @14, i64 0, i64 0))
  %5 = icmp ne i64 %return7, 0
  br i1 %5, label %true8, label %end9

end:                                              ; preds = %false136, %true143, %true135, %true127, %true116, %end30, %__llvm_entry
  %div.0 = phi i64 [ %output124, %true116 ], [ 1, %true127 ], [ 1, %true135 ], [ 1, %true143 ], [ %div.1, %false136 ], [ %div.1, %end30 ], [ 0, %__llvm_entry ]
  %attrscale.0 = phi double [ %output121, %true116 ], [ %return132, %true127 ], [ %return140, %true135 ], [ %output147, %true143 ], [ %attrscale.3, %false136 ], [ %attrscale.3, %end30 ], [ 0.000000e+00, %__llvm_entry ]
  %return149 = call i64 @"gt@III"(i64 %div.0, i64 0)
  %6 = icmp ne i64 %return149, 0
  br i1 %6, label %true150, label %end151

true8:                                            ; preds = %true
  %type10 = load i8*, i8** %type
  store i8* %type10, i8** %0
  %inpts11 = load i64*, i64** %inpts
  store i64* %inpts11, i64** %1
  %getSourcePoints = call i64* @"getSourcePoints@[IS[I"(i8** %0, i64** %1)
  br label %end9

end9:                                             ; preds = %true8, %true
  %pts.0 = phi i64* [ %getSourcePoints, %true8 ], [ %inpts5, %true ]
  %promotion12 = load i8*, i8** %promotion
  %return13 = call i64 @"eq@ISS"(i8* %promotion12, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @15, i64 0, i64 0))
  %7 = icmp ne i64 %return13, 0
  br i1 %7, label %true14, label %end15

true14:                                           ; preds = %end9
  %type16 = load i8*, i8** %type
  store i8* %type16, i8** %2
  %inpts17 = load i64*, i64** %inpts
  store i64* %inpts17, i64** %3
  %getTargetPoints = call i64* @"getTargetPoints@[IS[I"(i8** %2, i64** %3)
  br label %end15

end15:                                            ; preds = %true14, %end9
  %pts.1 = phi i64* [ %getTargetPoints, %true14 ], [ %pts.0, %end9 ]
  %promotion18 = load i8*, i8** %promotion
  %return19 = call i64 @"eq@ISS"(i8* %promotion18, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @16, i64 0, i64 0))
  %8 = icmp ne i64 %return19, 0
  br i1 %8, label %true20, label %end21

true20:                                           ; preds = %end15
  br label %end21

end21:                                            ; preds = %true20, %end15
  %attrscale.1 = phi double [ 1.000000e+23, %true20 ], [ 0.000000e+00, %end15 ]
  %promotion22 = load i8*, i8** %promotion
  %return23 = call i64 @"eq@ISS"(i8* %promotion22, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @17, i64 0, i64 0))
  %9 = icmp ne i64 %return23, 0
  br i1 %9, label %true24, label %end25

true24:                                           ; preds = %end21
  br label %end25

end25:                                            ; preds = %true24, %end21
  %attrscale.2 = phi double [ 1.000000e+00, %true24 ], [ %attrscale.1, %end21 ]
  %ptgeo26 = load i64, i64* %ptgeo
  %attr27 = load i8*, i8** %attr
  %return28 = call i64 @"haspointattrib@IIS"(i64 %ptgeo26, i8* %attr27)
  %10 = icmp ne i64 %return28, 0
  br i1 %10, label %true29, label %end30

true29:                                           ; preds = %end25
  %return32 = call i64 @"len@I[I"(i64* %pts.1)
  br label %cond

end30:                                            ; preds = %cond, %end25
  %div.1 = phi i64 [ %div.2, %cond ], [ 0, %end25 ]
  %attrscale.3 = phi double [ %attrscale.4, %cond ], [ %attrscale.2, %end25 ]
  %primgeo84 = load i8*, i8** %primgeo
  %return85 = call i64 @"ne@ISS"(i8* %primgeo84, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @7, i64 0, i64 0))
  %targetprim86 = load i64, i64* %targetprim
  %return87 = call i64 @"ge@III"(i64 %targetprim86, i64 0)
  %return88 = call i64 @"and@III"(i64 %return85, i64 %return87)
  %promotion89 = load i8*, i8** %promotion
  %return90 = call i64 @"ne@ISS"(i8* %promotion89, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @14, i64 0, i64 0))
  %return91 = call i64 @"and@III"(i64 %return88, i64 %return90)
  %attr93 = load i8*, i8** %attr
  %return94 = call i64 @"hasprimattrib@ISS"(i8* %primgeo84, i8* %attr93)
  %primgeo95 = load i8*, i8** %primgeo
  %attr96 = load i8*, i8** %attr
  %return97 = call i64 @"hasvertexattrib@ISS"(i8* %primgeo95, i8* %attr96)
  %return98 = call i64 @"or@III"(i64 %return94, i64 %return97)
  %primgeo99 = load i8*, i8** %primgeo
  %attr100 = load i8*, i8** %attr
  %return101 = call i64 @"haspointattrib@ISS"(i8* %primgeo99, i8* %attr100)
  %return102 = call i64 @"or@III"(i64 %return98, i64 %return101)
  %return103 = call i64 @"and@III"(i64 %return91, i64 %return102)
  %11 = icmp ne i64 %return103, 0
  br i1 %11, label %true104, label %end

cond:                                             ; preds = %end53, %true29
  %div.2 = phi i64 [ 0, %true29 ], [ %div.3, %end53 ]
  %__impl_foreach_index_1ee.0 = phi i64 [ 0, %true29 ], [ %output83, %end53 ]
  %attrscale.4 = phi double [ %attrscale.2, %true29 ], [ %attrscale.5, %end53 ]
  %return35 = call i64 @"lt@III"(i64 %__impl_foreach_index_1ee.0, i64 %return32)
  %12 = icmp ne i64 %return35, 0
  br i1 %12, label %body, label %end30

body:                                             ; preds = %cond
  %return39 = call i64 @"getcomp@I[II"(i64* %pts.1, i64 %__impl_foreach_index_1ee.0)
  %ptgeo40 = load i64, i64* %ptgeo
  %attr41 = load i8*, i8** %attr
  %return43 = call double @"point@FISI"(i64 %ptgeo40, i8* %attr41, i64 %return39)
  %promotion44 = load i8*, i8** %promotion
  %return45 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @18, i64 0, i64 0))
  %return47 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @14, i64 0, i64 0))
  %return48 = call i64 @"or@III"(i64 %return45, i64 %return47)
  %return50 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @15, i64 0, i64 0))
  %return51 = call i64 @"or@III"(i64 %return48, i64 %return50)
  %13 = icmp ne i64 %return51, 0
  br i1 %13, label %true52, label %false

true52:                                           ; preds = %body
  %output = fadd double %attrscale.4, %return43
  %output58 = add i64 %div.2, 1
  br label %end53

false:                                            ; preds = %body
  %return60 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @19, i64 0, i64 0))
  %14 = icmp ne i64 %return60, 0
  br i1 %14, label %true61, label %false62

end53:                                            ; preds = %false70, %true77, %true69, %true61, %true52
  %div.3 = phi i64 [ %output58, %true52 ], [ 1, %true61 ], [ 1, %true69 ], [ 1, %true77 ], [ %div.2, %false70 ]
  %attrscale.5 = phi double [ %output, %true52 ], [ %return66, %true61 ], [ %return74, %true69 ], [ %output81, %true77 ], [ %attrscale.4, %false70 ]
  %output83 = add i64 %__impl_foreach_index_1ee.0, 1
  br label %cond

true61:                                           ; preds = %false
  %return66 = call double @"max@FFF"(double %attrscale.4, double %return43)
  br label %end53

false62:                                          ; preds = %false
  %return68 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @16, i64 0, i64 0))
  %15 = icmp ne i64 %return68, 0
  br i1 %15, label %true69, label %false70

true69:                                           ; preds = %false62
  %return74 = call double @"min@FFF"(double %attrscale.4, double %return43)
  br label %end53

false70:                                          ; preds = %false62
  %return76 = call i64 @"eq@ISS"(i8* %promotion44, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @17, i64 0, i64 0))
  %16 = icmp ne i64 %return76, 0
  br i1 %16, label %true77, label %end53

true77:                                           ; preds = %false70
  %output81 = fmul double %attrscale.4, %return43
  br label %end53

true104:                                          ; preds = %end30
  %primgeo106 = load i8*, i8** %primgeo
  %attr107 = load i8*, i8** %attr
  %targetprim108 = load i64, i64* %targetprim
  %uv109 = load <3 x double>, <3 x double>* %uv
  %return110 = call double @"primuv@FSSIV"(i8* %primgeo106, i8* %attr107, i64 %targetprim108, <3 x double> %uv109)
  %promotion111 = load i8*, i8** %promotion
  %return112 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @18, i64 0, i64 0))
  %return114 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @15, i64 0, i64 0))
  %return115 = call i64 @"or@III"(i64 %return112, i64 %return114)
  %17 = icmp ne i64 %return115, 0
  br i1 %17, label %true116, label %false117

true116:                                          ; preds = %true104
  %output121 = fadd double %attrscale.3, %return110
  %output124 = add i64 %div.1, 1
  br label %end

false117:                                         ; preds = %true104
  %return126 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @19, i64 0, i64 0))
  %18 = icmp ne i64 %return126, 0
  br i1 %18, label %true127, label %false128

true127:                                          ; preds = %false117
  %return132 = call double @"max@FFF"(double %attrscale.3, double %return110)
  br label %end

false128:                                         ; preds = %false117
  %return134 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @16, i64 0, i64 0))
  %19 = icmp ne i64 %return134, 0
  br i1 %19, label %true135, label %false136

true135:                                          ; preds = %false128
  %return140 = call double @"min@FFF"(double %attrscale.3, double %return110)
  br label %end

false136:                                         ; preds = %false128
  %return142 = call i64 @"eq@ISS"(i8* %promotion111, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @17, i64 0, i64 0))
  %20 = icmp ne i64 %return142, 0
  br i1 %20, label %true143, label %end

true143:                                          ; preds = %false136
  %output147 = fmul double %attrscale.3, %return110
  br label %end

true150:                                          ; preds = %end
  %cast = sitofp i64 %div.0 to double
  %output155 = call double @"div@FF"(double %attrscale.0, double %cast)
  br label %end151

end151:                                           ; preds = %true150, %end
  %scale.0 = phi double [ %output155, %true150 ], [ 1.000000e+00, %end ]
  %scalemode157 = load i8*, i8** %scalemode
  %return158 = call i64 @"eq@ISS"(i8* %scalemode157, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @20, i64 0, i64 0))
  %return160 = call i64 @"eq@ISS"(i8* %scalemode157, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @13, i64 0, i64 0))
  %return161 = call i64 @"or@III"(i64 %return158, i64 %return160)
  %21 = icmp ne i64 %return161, 0
  br i1 %21, label %true162, label %end163

true162:                                          ; preds = %end151
  %valscale165 = load double, double* %valscale
  %output166 = fmul double %scale.0, %valscale165
  br label %end163

end163:                                           ; preds = %true162, %end151
  %scale.1 = phi double [ %output166, %true162 ], [ %scale.0, %end151 ]
  ret double %scale.1
}

; Function Attrs: nounwind
declare i64 @"haspointattrib@IIS"(i64, i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #1

; Function Attrs: nounwind
declare double @"point@FISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare double @"max@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare double @"min@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare i64 @"ne@ISS"(i8*, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"ge@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"hasprimattrib@ISS"(i8*, i8*) #2

; Function Attrs: nounwind
declare i64 @"hasvertexattrib@ISS"(i8*, i8*) #2

; Function Attrs: nounwind
declare i64 @"haspointattrib@ISS"(i8*, i8*) #2

; Function Attrs: nounwind
declare double @"primuv@FSSIV"(i8*, i8*, i64, <3 x double>) #2

; Function Attrs: nounwind readnone
declare i64 @"gt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@IVSFIS"(i64* %_bound_target_prim, <3 x double>* %_bound_target_uv, i8** %_bound_target_path, double* %_bound_compressstiffness, i64* %_bound_primnum, i8** %_bound_type) #0 {
__llvm_entry:
  %0 = alloca i8*
  %1 = alloca i64
  %2 = alloca i64*
  %3 = alloca i8*
  %4 = alloca i64
  %5 = alloca <3 x double>
  %6 = alloca i8*
  %7 = alloca double
  %8 = alloca i8*
  %9 = alloca i8*
  %10 = alloca double
  %11 = alloca double
  %return = call double @"chf@FS"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @21, i64 0, i64 0))
  %return1 = call double @"chf@FS"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @22, i64 0, i64 0))
  %return4 = call double @"pow@FFF"(double 1.000000e+01, double %return1)
  %output = fmul double %return, %return4
  store double %output, double* %_bound_compressstiffness
  %return5 = call i8* @"chs@SS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @23, i64 0, i64 0))
  %_bound_primnum6 = load i64, i64* %_bound_primnum
  %return7 = call i64* @"primpoints@[III"(i64 0, i64 %_bound_primnum6)
  %_bound_type8 = load i8*, i8** %_bound_type
  store i8* %_bound_type8, i8** %0
  store i64 1, i64* %1
  store i64* %return7, i64** %2
  %_bound_target_path10 = load i8*, i8** %_bound_target_path
  store i8* %_bound_target_path10, i8** %3
  %_bound_target_prim11 = load i64, i64* %_bound_target_prim
  store i64 %_bound_target_prim11, i64* %4
  %_bound_target_uv12 = load <3 x double>, <3 x double>* %_bound_target_uv
  store <3 x double> %_bound_target_uv12, <3 x double>* %5
  %return13 = call i8* @"chs@SS"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @24, i64 0, i64 0))
  store i8* %return13, i8** %6
  %return14 = call double @"chf@FS"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @25, i64 0, i64 0))
  store double %return14, double* %7
  %return15 = call i8* @"chs@SS"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @26, i64 0, i64 0))
  store i8* %return15, i8** %8
  store i8* %return5, i8** %9
  %accumScaleValues = call double @"accumScaleValues@FSI[ISIVSFSS"(i8** %0, i64* %1, i64** %2, i8** %3, i64* %4, <3 x double>* %5, i8** %6, double* %7, i8** %8, i8** %9)
  store double %accumScaleValues, double* %10
  %_bound_compressstiffness18 = load double, double* %_bound_compressstiffness
  store double %_bound_compressstiffness18, double* %11
  %logscaleStiffness = call double @"logscaleStiffness@FFF"(double* %10, double* %11)
  store double %logscaleStiffness, double* %_bound_compressstiffness
  ret void
}

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #1

; Function Attrs: nounwind readnone
declare double @"pow@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare i8* @"chs@SS"(i8*) #1

; Function Attrs: nounwind
declare i64* @"primpoints@[III"(i64, i64) #2

; Function Attrs: nounwind
define void @__vex_snippet(i64 %target_prim, <3 x double> %target_uv, i8* %target_path, double %compressstiffness, i64 %primnum, i8* %type) #2 {
__llvm_entry:
  %"<compressstiffness>" = alloca double
  %0 = alloca i64
  %1 = alloca <3 x double>
  %2 = alloca i8*
  %3 = alloca i64
  %4 = alloca i8*
  store double %compressstiffness, double* %"<compressstiffness>"
  store i64 %target_prim, i64* %0
  store <3 x double> %target_uv, <3 x double>* %1
  store i8* %target_path, i8** %2
  store i64 %primnum, i64* %3
  store i8* %type, i8** %4
  call void @"__vex_snippet_snippet@IVSFIS"(i64* %0, <3 x double>* %1, i8** %2, double* %"<compressstiffness>", i64* %3, i8** %4)
  %evalue = load double, double* %"<compressstiffness>"
  %gvalue = call double @"_export@FSF"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @21, i64 0, i64 0), double %evalue) #3
  store double %gvalue, double* @compressstiffness
  ret void
}

declare double @"_export@FSF"(i8*, double)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 -1, <3 x double> zeroinitializer, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @7, i64 0, i64 0), double 0.000000e+00, i64 0, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @7, i64 0, i64 0))
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}

;_code_end
