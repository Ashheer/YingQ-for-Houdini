;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [5 x i8] c"mode\00"
@1 = private constant [6 x i8] c"scale\00"
@2 = private constant [8 x i8] c"max_rpf\00"
@3 = private constant [32 x i8] c"Max RPF (Revolutions Per Frame)\00"
@4 = private constant [19 x i8] c"lookup_table_depth\00"
@5 = private constant [20 x i8] c"Lookup Table Format\00"
@6 = private constant [8 x i8] c"No Data\00"
@7 = private constant [18 x i8] c"custom_data_in_pa\00"
@8 = private constant [14 x i8] c"fluid_u_in_pa\00"
@9 = private constant [11 x i8] c"max_pscale\00"
@10 = private constant [57 x i8] c"Max Pscale or Custom Attribute in Position Texture Alpha\00"
@11 = private constant [15 x i8] c"normalize_data\00"
@12 = private constant [10 x i8] c"split_pos\00"
@13 = private constant [51 x i8] c"Texture Format and the Number of Position Textures\00"
@14 = private constant [9 x i8] c"powoftwo\00"
@15 = private constant [11 x i8] c"finalsizex\00"
@16 = private constant [15 x i8] c"finalpow2sizex\00"
@17 = private constant [11 x i8] c"finalsizey\00"
@18 = private constant [15 x i8] c"finalpow2sizey\00"
@19 = private constant [22 x i8] c"Active Pixels Ratio X\00"
@20 = private constant [22 x i8] c"Active Pixels Ratio Y\00"
@21 = private constant [14 x i8] c"texture_width\00"
@22 = private constant [19 x i8] c"export_point_count\00"
@23 = private constant [127 x i8] c"Points are folded into more than 99 rows in the animation data uv channel.               Please increase Target Texture Width.\00"
@24 = private constant [24 x i8] c"Data UV Point Row Count\00"
@25 = private constant [1 x i8] zeroinitializer
@26 = private constant [0 x double] zeroinitializer
@__max_x_data = external global i8*
@__bound_decoded = external global double*
@__max_y_data = external global i8*
@__max_z_data = external global i8*
@__min_z_data = external global i8*
@__min_x_data = external global i8*
@__min_y_data = external global i8*
@__bound_max = external global <3 x double>
@__bound_min = external global <3 x double>
@27 = private constant [13 x i8] c"__max_x_data\00"
@28 = private constant [16 x i8] c"__bound_decoded\00"
@29 = private constant [13 x i8] c"__max_y_data\00"
@30 = private constant [13 x i8] c"__max_z_data\00"
@31 = private constant [13 x i8] c"__min_z_data\00"
@32 = private constant [13 x i8] c"__min_x_data\00"
@33 = private constant [13 x i8] c"__min_y_data\00"
@34 = private constant [12 x i8] c"__bound_max\00"
@35 = private constant [12 x i8] c"__bound_min\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@S[FSSSSSVV"(i8** %_bound___max_x_data, double** %_bound___bound_decoded, i8** %_bound___max_y_data, i8** %_bound___max_z_data, i8** %_bound___min_z_data, i8** %_bound___min_x_data, i8** %_bound___min_y_data, <3 x double>* %_bound___bound_max, <3 x double>* %_bound___bound_min) #0 {
__llvm_entry:
  %return1 = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @1, i64 0, i64 0))
  %return2 = call <3 x double> @"getbbox_max@VI"(i64 0)
  %return3 = call <3 x double> @"getbbox_min@VI"(i64 0)
  %return5 = call double @"getcomp@FVI"(<3 x double> %return2, i64 0)
  %output = call double @"div@FF"(double %return5, double %return1)
  %output7 = fmul double %output, 1.000000e+01
  %return8 = call double @"ceil@FF"(double %output7)
  %output10 = fmul double %return8, %return1
  %output11 = call double @"div@FF"(double %output10, double 1.000000e+01)
  %return12 = call i64 @"chi@IS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @0, i64 0, i64 0))
  %return13 = call i64 @"eq@III"(i64 %return12, i64 1)
  %0 = icmp ne i64 %return13, 0
  br i1 %0, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %return15 = call double @"chf@FS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @2, i64 0, i64 0))
  %output16 = call double @"div@FF"(double 1.000000e+00, double %return15)
  %output17 = fsub double 1.000000e+00, %output16
  %output18 = fmul double %output17, 1.000000e-01
  %output20 = fmul double %output18, %return1
  %output21 = fadd double %output11, %output20
  %return23 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %return2, double %output21, i64 0)
  %output25 = extractvalue { double, <3 x double> } %return23, 1
  store i8* getelementptr inbounds ([32 x i8], [32 x i8]* @3, i64 0, i64 0), i8** %_bound___max_x_data
  %return27 = call double @"getcomp@FVI"(<3 x double> %output25, i64 0)
  %output29 = call double @"div@FF"(double %return27, double %return1)
  %output30 = fmul double %output29, 1.000000e+01
  %return36 = call double @"floor@FF"(double %output30)
  %output37 = fsub double %output30, %return36
  %output38 = fsub double 1.000000e+00, %output37
  %output39 = call double @"div@FF"(double 1.000000e+00, double %output38)
  %tmp40 = load double*, double** %_bound___bound_decoded
  %return41 = call { double, double* } @"setcomp@F[FFI"(double* %tmp40, double %output39, i64 0)
  %output43 = extractvalue { double, double* } %return41, 1
  store double* %output43, double** %_bound___bound_decoded
  br label %end

false:                                            ; preds = %__llvm_entry
  %return45 = call i64 @"eq@III"(i64 %return12, i64 2)
  %1 = icmp ne i64 %return45, 0
  br i1 %1, label %true46, label %false47

end:                                              ; preds = %end53, %false47, %true
  %bound_max.0 = phi <3 x double> [ %output25, %true ], [ %output64, %end53 ], [ %output85, %false47 ]
  %return91 = call double @"getcomp@FVI"(<3 x double> %bound_max.0, i64 1)
  %output93 = call double @"div@FF"(double %return91, double %return1)
  %output94 = fmul double %output93, 1.000000e+01
  %return95 = call double @"ceil@FF"(double %output94)
  %output97 = fmul double %return95, %return1
  %output98 = call double @"div@FF"(double %output97, double 1.000000e+01)
  %return102 = call i64 @"eq@III"(i64 %return12, i64 3)
  %return103 = call i64 @"or@III"(i64 %return13, i64 %return102)
  %return104 = call i64 @"chi@IS"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @7, i64 0, i64 0))
  %return105 = call i64 @"or@III"(i64 %return103, i64 %return104)
  %return106 = call i64 @"chi@IS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @8, i64 0, i64 0))
  %return107 = call i64 @"or@III"(i64 %return105, i64 %return106)
  %2 = icmp ne i64 %return107, 0
  br i1 %2, label %true108, label %false109

true46:                                           ; preds = %false
  %return49 = call i64 @"chi@IS"(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @4, i64 0, i64 0))
  %return50 = call i64 @"eq@III"(i64 %return49, i64 0)
  %3 = icmp ne i64 %return50, 0
  br i1 %3, label %true51, label %false52

false47:                                          ; preds = %false
  %return83 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %return2, double %output11, i64 0)
  %output85 = extractvalue { double, <3 x double> } %return83, 1
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @6, i64 0, i64 0), i8** %_bound___max_x_data
  %tmp86 = load double*, double** %_bound___bound_decoded
  %return87 = call { double, double* } @"setcomp@F[FFI"(double* %tmp86, double 0.000000e+00, i64 0)
  %output89 = extractvalue { double, double* } %return87, 1
  store double* %output89, double** %_bound___bound_decoded
  br label %end

true51:                                           ; preds = %true46
  br label %end53

false52:                                          ; preds = %true46
  br label %end53

end53:                                            ; preds = %false52, %true51
  %code.0 = phi double [ 7.000000e-01, %true51 ], [ 3.000000e-01, %false52 ]
  %output56 = fmul double %code.0, 1.000000e-01
  %output58 = fmul double %output56, %return1
  %output59 = fadd double %output11, %output58
  %return62 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %return2, double %output59, i64 0)
  %output64 = extractvalue { double, <3 x double> } %return62, 1
  store i8* getelementptr inbounds ([20 x i8], [20 x i8]* @5, i64 0, i64 0), i8** %_bound___max_x_data
  %return66 = call double @"getcomp@FVI"(<3 x double> %output64, i64 0)
  %output68 = call double @"div@FF"(double %return66, double %return1)
  %output69 = fmul double %output68, 1.000000e+01
  %return75 = call double @"floor@FF"(double %output69)
  %output76 = fsub double %output69, %return75
  %tmp77 = load double*, double** %_bound___bound_decoded
  %return78 = call { double, double* } @"setcomp@F[FFI"(double* %tmp77, double %output76, i64 0)
  %output80 = extractvalue { double, double* } %return78, 1
  store double* %output80, double** %_bound___bound_decoded
  br label %end

true108:                                          ; preds = %end
  %return112 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @9, i64 0, i64 0))
  %output113 = call double @"div@FF"(double 1.000000e+00, double %return112)
  %output114 = fsub double 1.000000e+00, %output113
  %output115 = fmul double %output114, 1.000000e-01
  %output117 = fmul double %output115, %return1
  %output118 = fadd double %output98, %output117
  %return121 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %bound_max.0, double %output118, i64 1)
  %output123 = extractvalue { double, <3 x double> } %return121, 1
  store i8* getelementptr inbounds ([57 x i8], [57 x i8]* @10, i64 0, i64 0), i8** %_bound___max_y_data
  %return125 = call double @"getcomp@FVI"(<3 x double> %output123, i64 1)
  %output127 = call double @"div@FF"(double %return125, double %return1)
  %output128 = fmul double %output127, 1.000000e+01
  %return134 = call double @"floor@FF"(double %output128)
  %output135 = fsub double %output128, %return134
  %output136 = fsub double 1.000000e+00, %output135
  %output137 = call double @"div@FF"(double 1.000000e+00, double %output136)
  %tmp138 = load double*, double** %_bound___bound_decoded
  %return139 = call { double, double* } @"setcomp@F[FFI"(double* %tmp138, double %output137, i64 1)
  %output141 = extractvalue { double, double* } %return139, 1
  store double* %output141, double** %_bound___bound_decoded
  br label %end110

false109:                                         ; preds = %end
  %return144 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %bound_max.0, double %output98, i64 1)
  %output146 = extractvalue { double, <3 x double> } %return144, 1
  store i8* getelementptr inbounds ([8 x i8], [8 x i8]* @6, i64 0, i64 0), i8** %_bound___max_y_data
  %tmp147 = load double*, double** %_bound___bound_decoded
  %return148 = call { double, double* } @"setcomp@F[FFI"(double* %tmp147, double 0.000000e+00, i64 1)
  %output150 = extractvalue { double, double* } %return148, 1
  store double* %output150, double** %_bound___bound_decoded
  br label %end110

end110:                                           ; preds = %false109, %true108
  %bound_max.1 = phi <3 x double> [ %output123, %true108 ], [ %output146, %false109 ]
  %return152 = call double @"getcomp@FVI"(<3 x double> %bound_max.1, i64 2)
  %output154 = call double @"div@FF"(double %return152, double %return1)
  %output155 = fmul double %output154, 1.000000e+01
  %return156 = call double @"ceil@FF"(double %output155)
  %output158 = fmul double %return156, %return1
  %output159 = call double @"div@FF"(double %output158, double 1.000000e+01)
  %return161 = call i64 @"chi@IS"(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @11, i64 0, i64 0))
  %return162 = call i64 @"not@II"(i64 %return161)
  %return163 = call i64 @"chi@IS"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @12, i64 0, i64 0))
  %return164 = call i64 @"not@II"(i64 %return163)
  %return165 = call i64 @"and@III"(i64 %return162, i64 %return164)
  %4 = icmp ne i64 %return165, 0
  br i1 %4, label %true166, label %false167

true166:                                          ; preds = %end110
  br label %end168

false167:                                         ; preds = %end110
  %return172 = call i64 @"and@III"(i64 %return161, i64 %return164)
  %5 = icmp ne i64 %return172, 0
  br i1 %5, label %true173, label %false174

end168:                                           ; preds = %true179, %false180, %true173, %true166
  %code160.0 = phi double [ 7.000000e-01, %true166 ], [ 3.000000e-01, %true173 ], [ 4.000000e-01, %true179 ], [ 8.000000e-01, %false180 ]
  %output184 = fmul double %code160.0, 1.000000e-01
  %output186 = fmul double %output184, %return1
  %output187 = fadd double %output159, %output186
  %return190 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %bound_max.1, double %output187, i64 2)
  %output192 = extractvalue { double, <3 x double> } %return190, 1
  store i8* getelementptr inbounds ([51 x i8], [51 x i8]* @13, i64 0, i64 0), i8** %_bound___max_z_data
  %return194 = call double @"getcomp@FVI"(<3 x double> %output192, i64 2)
  %output196 = call double @"div@FF"(double %return194, double %return1)
  %output197 = fmul double %output196, 1.000000e+01
  %return203 = call double @"floor@FF"(double %output197)
  %output204 = fsub double %output197, %return203
  %tmp205 = load double*, double** %_bound___bound_decoded
  %return206 = call { double, double* } @"setcomp@F[FFI"(double* %tmp205, double %output204, i64 2)
  %output208 = extractvalue { double, double* } %return206, 1
  store double* %output208, double** %_bound___bound_decoded
  %return209 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @14, i64 0, i64 0))
  %6 = icmp ne i64 %return209, 0
  br i1 %6, label %true210, label %end211

true173:                                          ; preds = %false167
  br label %end168

false174:                                         ; preds = %false167
  %return178 = call i64 @"and@III"(i64 %return161, i64 %return163)
  %7 = icmp ne i64 %return178, 0
  br i1 %7, label %true179, label %false180

true179:                                          ; preds = %false174
  br label %end168

false180:                                         ; preds = %false174
  br label %end168

true210:                                          ; preds = %end168
  %return212 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @15, i64 0, i64 0))
  %return213 = call double @"chf@FS"(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @16, i64 0, i64 0))
  %output216 = call double @"div@FF"(double %return212, double %return213)
  %output217 = fsub double 1.000000e+00, %output216
  %return218 = call double @"chf@FS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @17, i64 0, i64 0))
  %return219 = call double @"chf@FS"(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @18, i64 0, i64 0))
  %output222 = call double @"div@FF"(double %return218, double %return219)
  %output223 = fsub double 1.000000e+00, %output222
  br label %end211

end211:                                           ; preds = %true210, %end168
  %one_minus_ratio_y.0 = phi double [ %output223, %true210 ], [ 0.000000e+00, %end168 ]
  %one_minus_ratio_x.0 = phi double [ %output217, %true210 ], [ 0.000000e+00, %end168 ]
  %return225 = call double @"getcomp@FVI"(<3 x double> %return3, i64 2)
  %output227 = call double @"div@FF"(double %return225, double %return1)
  %output228 = fmul double %output227, 1.000000e+01
  %return229 = call double @"floor@FF"(double %output228)
  %output231 = fmul double %return229, %return1
  %output232 = call double @"div@FF"(double %output231, double 1.000000e+01)
  %return234 = call double @"getcomp@FVI"(<3 x double> %return3, i64 0)
  %output236 = call double @"div@FF"(double %return234, double %return1)
  %output237 = fmul double %output236, 1.000000e+01
  %return238 = call double @"floor@FF"(double %output237)
  %output240 = fmul double %return238, %return1
  %output241 = call double @"div@FF"(double %output240, double 1.000000e+01)
  %output244 = fmul double %one_minus_ratio_x.0, 1.000000e-01
  %output246 = fmul double %output244, %return1
  %output247 = fsub double %output232, %output246
  %output250 = fmul double %one_minus_ratio_y.0, 1.000000e-01
  %output252 = fmul double %output250, %return1
  %output253 = fsub double %output241, %output252
  %return256 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %return3, double %output247, i64 2)
  %output258 = extractvalue { double, <3 x double> } %return256, 1
  %return261 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %output258, double %output253, i64 0)
  %output263 = extractvalue { double, <3 x double> } %return261, 1
  store i8* getelementptr inbounds ([22 x i8], [22 x i8]* @19, i64 0, i64 0), i8** %_bound___min_z_data
  %return265 = call double @"getcomp@FVI"(<3 x double> %output263, i64 2)
  %output267 = call double @"div@FF"(double %return265, double %return1)
  %output268 = fmul double %output267, 1.000000e+01
  %return269 = call double @"ceil@FF"(double %output268)
  %output275 = fsub double %return269, %output268
  %output276 = fsub double 1.000000e+00, %output275
  %tmp277 = load double*, double** %_bound___bound_decoded
  %return278 = call { double, double* } @"setcomp@F[FFI"(double* %tmp277, double %output276, i64 5)
  %output280 = extractvalue { double, double* } %return278, 1
  store double* %output280, double** %_bound___bound_decoded
  store i8* getelementptr inbounds ([22 x i8], [22 x i8]* @20, i64 0, i64 0), i8** %_bound___min_x_data
  %return282 = call double @"getcomp@FVI"(<3 x double> %output263, i64 0)
  %output284 = call double @"div@FF"(double %return282, double %return1)
  %output285 = fmul double %output284, 1.000000e+01
  %return286 = call double @"ceil@FF"(double %output285)
  %output292 = fsub double %return286, %output285
  %output293 = fsub double 1.000000e+00, %output292
  %tmp294 = load double*, double** %_bound___bound_decoded
  %return295 = call { double, double* } @"setcomp@F[FFI"(double* %tmp294, double %output293, i64 3)
  %output297 = extractvalue { double, double* } %return295, 1
  store double* %output297, double** %_bound___bound_decoded
  %return298 = call double @"chf@FS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @21, i64 0, i64 0))
  %return299 = call double @"chf@FS"(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @22, i64 0, i64 0))
  %output302 = call double @"div@FF"(double %return299, double %return298)
  %return303 = call double @"ceil@FF"(double %output302)
  %return305 = fcmp ogt double %return303, 9.900000e+01
  br i1 %return305, label %true307, label %end308

true307:                                          ; preds = %end211
  call void @"error@S"(i8* getelementptr inbounds ([127 x i8], [127 x i8]* @23, i64 0, i64 0))
  br label %end308

end308:                                           ; preds = %true307, %end211
  %return310 = call double @"getcomp@FVI"(<3 x double> %output263, i64 1)
  %output312 = call double @"div@FF"(double %return310, double %return1)
  %output313 = fmul double %output312, 1.000000e+01
  %return314 = call double @"floor@FF"(double %output313)
  %output316 = fmul double %return314, %return1
  %output317 = call double @"div@FF"(double %output316, double 1.000000e+01)
  %output320 = fmul double %return303, 1.000000e-02
  %output321 = fmul double %output320, 1.000000e-01
  %output323 = fmul double %output321, %return1
  %output324 = fsub double %output317, %output323
  %return327 = call { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %output263, double %output324, i64 1)
  %output329 = extractvalue { double, <3 x double> } %return327, 1
  store i8* getelementptr inbounds ([24 x i8], [24 x i8]* @24, i64 0, i64 0), i8** %_bound___min_y_data
  %return331 = call double @"getcomp@FVI"(<3 x double> %output329, i64 1)
  %output333 = call double @"div@FF"(double %return331, double %return1)
  %output334 = fmul double %output333, 1.000000e+01
  %return335 = call double @"ceil@FF"(double %output334)
  %output341 = fsub double %return335, %output334
  %output342 = fmul double 1.000000e+02, %output341
  %return343 = call double @"rint@FF"(double %output342)
  %tmp344 = load double*, double** %_bound___bound_decoded
  %return345 = call { double, double* } @"setcomp@F[FFI"(double* %tmp344, double %return343, i64 4)
  %output347 = extractvalue { double, double* } %return345, 1
  store double* %output347, double** %_bound___bound_decoded
  store <3 x double> %output192, <3 x double>* %_bound___bound_max
  store <3 x double> %output329, <3 x double>* %_bound___bound_min
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #1

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #1

; Function Attrs: nounwind
declare <3 x double> @"getbbox_max@VI"(i64) #2

; Function Attrs: nounwind
declare <3 x double> @"getbbox_min@VI"(i64) #2

; Function Attrs: nounwind readnone
declare double @"getcomp@FVI"(<3 x double>, i64) #1

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: nounwind readnone
declare double @"ceil@FF"(double) #1

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #1

; Function Attrs: alwaysinline
define private { double, <3 x double> } @"setcomp@FVFI"(<3 x double> %rw11, double %rw22, i64 %rw33) #3 {
__llvm_entry:
  %rw16 = call <3 x double> @"setcomp@VFI"(<3 x double> %rw11, double %rw22, i64 %rw33)
  %mrv = insertvalue { double, <3 x double> } undef, double %rw22, 0
  %mrv9 = insertvalue { double, <3 x double> } %mrv, <3 x double> %rw16, 1
  ret { double, <3 x double> } %mrv9
}

; Function Attrs: nounwind readnone
declare <3 x double> @"setcomp@VFI"(<3 x double>, double, i64) #1

; Function Attrs: nounwind readnone
declare double @"floor@FF"(double) #1

; Function Attrs: nounwind readnone
declare { double, double* } @"setcomp@F[FFI"(double*, double, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #1

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #1

; Function Attrs: nounwind
declare void @"error@S"(i8*) #2

; Function Attrs: nounwind readnone
declare double @"rint@FF"(double) #1

; Function Attrs: nounwind
define void @__vex_snippet(i8* %__max_x_data, double* %__bound_decoded, i8* %__max_y_data, i8* %__max_z_data, i8* %__min_z_data, i8* %__min_x_data, i8* %__min_y_data, <3 x double> %__bound_max, <3 x double> %__bound_min) #2 {
__llvm_entry:
  %"<__bound_decoded>" = alloca double*
  %"<__max_y_data>" = alloca i8*
  %"<__max_z_data>" = alloca i8*
  %"<__min_z_data>" = alloca i8*
  %"<__min_x_data>" = alloca i8*
  %"<__min_y_data>" = alloca i8*
  %"<__bound_max>" = alloca <3 x double>
  %"<__bound_min>" = alloca <3 x double>
  %"<__max_x_data>" = alloca i8*
  store i8* %__max_x_data, i8** %"<__max_x_data>"
  store double* %__bound_decoded, double** %"<__bound_decoded>"
  store i8* %__max_y_data, i8** %"<__max_y_data>"
  store i8* %__max_z_data, i8** %"<__max_z_data>"
  store i8* %__min_z_data, i8** %"<__min_z_data>"
  store i8* %__min_x_data, i8** %"<__min_x_data>"
  store i8* %__min_y_data, i8** %"<__min_y_data>"
  store <3 x double> %__bound_max, <3 x double>* %"<__bound_max>"
  store <3 x double> %__bound_min, <3 x double>* %"<__bound_min>"
  call void @"__vex_snippet_snippet@S[FSSSSSVV"(i8** %"<__max_x_data>", double** %"<__bound_decoded>", i8** %"<__max_y_data>", i8** %"<__max_z_data>", i8** %"<__min_z_data>", i8** %"<__min_x_data>", i8** %"<__min_y_data>", <3 x double>* %"<__bound_max>", <3 x double>* %"<__bound_min>")
  %evalue = load i8*, i8** %"<__max_x_data>"
  %gvalue = call i8* @"_export@SSS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @27, i64 0, i64 0), i8* %evalue) #4
  %evalue1 = load double*, double** %"<__bound_decoded>"
  %gvalue2 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @28, i64 0, i64 0), double* %evalue1) #4
  %evalue3 = load i8*, i8** %"<__max_y_data>"
  %gvalue4 = call i8* @"_export@SSS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @29, i64 0, i64 0), i8* %evalue3) #4
  %evalue5 = load i8*, i8** %"<__max_z_data>"
  %gvalue6 = call i8* @"_export@SSS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @30, i64 0, i64 0), i8* %evalue5) #4
  %evalue7 = load i8*, i8** %"<__min_z_data>"
  %gvalue8 = call i8* @"_export@SSS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @31, i64 0, i64 0), i8* %evalue7) #4
  %evalue9 = load i8*, i8** %"<__min_x_data>"
  %gvalue10 = call i8* @"_export@SSS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @32, i64 0, i64 0), i8* %evalue9) #4
  %evalue11 = load i8*, i8** %"<__min_y_data>"
  %gvalue12 = call i8* @"_export@SSS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @33, i64 0, i64 0), i8* %evalue11) #4
  %evalue13 = load <3 x double>, <3 x double>* %"<__bound_max>"
  %gvalue14 = call <3 x double> @"_export@VSV"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @34, i64 0, i64 0), <3 x double> %evalue13) #4
  %evalue15 = load <3 x double>, <3 x double>* %"<__bound_min>"
  %gvalue16 = call <3 x double> @"_export@VSV"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @35, i64 0, i64 0), <3 x double> %evalue15) #4
  store i8* %gvalue, i8** @__max_x_data
  store double* %gvalue2, double** @__bound_decoded
  store i8* %gvalue4, i8** @__max_y_data
  store i8* %gvalue6, i8** @__max_z_data
  store i8* %gvalue8, i8** @__min_z_data
  store i8* %gvalue10, i8** @__min_x_data
  store i8* %gvalue12, i8** @__min_y_data
  store <3 x double> %gvalue14, <3 x double>* @__bound_max
  store <3 x double> %gvalue16, <3 x double>* @__bound_min
  ret void
}

declare i8* @"_export@SSS"(i8*, i8*)

declare double* @"_export@[FS[F"(i8*, double*)

declare <3 x double> @"_export@VSV"(i8*, <3 x double>)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @25, i64 0, i64 0), double* getelementptr inbounds ([0 x double], [0 x double]* @26, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @25, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @25, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @25, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @25, i64 0, i64 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @25, i64 0, i64 0), <3 x double> zeroinitializer, <3 x double> zeroinitializer)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { alwaysinline }
attributes #4 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.531"}
!2 = !{!"64"}

;_code_end
