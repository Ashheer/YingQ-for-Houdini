;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [2 x i8] c"P\00"
@1 = private constant [1 x i8] zeroinitializer
@2 = private constant [9 x i8] c"polyline\00"
@3 = private constant [11 x i8] c"restlength\00"
@4 = private constant [10 x i8] c"__class__\00"
@5 = private constant [16 x i8] c"useconnectivity\00"
@6 = private constant [14 x i8] c"compare_class\00"
@7 = private constant [21 x i8] c"__stretchconstraints\00"
@8 = private constant [6 x i8] c"group\00"
@9 = private constant [12 x i8] c"__targetsrc\00"
@10 = private constant [11 x i8] c"stretchgrp\00"
@11 = private constant [21 x i8] c"constraint_per_point\00"
@12 = private constant [13 x i8] c"nconstraints\00"
@13 = private constant [9 x i8] c"useclump\00"
@14 = private constant [12 x i8] c"clumpattrib\00"
@15 = private constant [8 x i8] c"min_rad\00"
@16 = private constant [8 x i8] c"max_rad\00"
@17 = private constant [7 x i8] c"max_pt\00"
@18 = private constant [5 x i8] c"pref\00"
@19 = private constant [5 x i8] c"seed\00"
@20 = private constant [14 x i8] c"detach_chance\00"
@21 = private constant [13 x i8] c"point_chance\00"
@ptnum = external global i64
@22 = private constant [6 x i8] c"ptnum\00"

; Function Attrs: alwaysinline nounwind
define private void @"createGlueConstraints@IIISSSSISIFFIIFFFIS"(i64* %geo, i64* %congeo, i64* %pt, i8** %srcgrp, i8** %dstgrp, i8** %primgrp, i8** %classname, i64* %usecluster, i8** %clusterattrib, i64* %numconstraint, double* %minrad, double* %maxrad, i64* %maxpt, i64* %pref, double* %seed, double* %threshold, double* %ptthreshold, i64* %outgeo, i8** %outgrp) #0 {
__llvm_entry:
  %geo1 = load i64, i64* %geo
  %pt2 = load i64, i64* %pt
  %return = call <3 x double> @"point@VISI"(i64 %geo1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %pt2)
  %numconstraint3 = load i64, i64* %numconstraint
  %return5 = call i64 @"le@III"(i64 %numconstraint3, i64 0)
  %0 = icmp ne i64 %return5, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %end166, %cond, %end18, %true17, %__llvm_entry
  ret void

end:                                              ; preds = %__llvm_entry
  %geo6 = load i64, i64* %geo
  %classname7 = load i8*, i8** %classname
  %pt8 = load i64, i64* %pt
  %return9 = call i64 @"point@IISI"(i64 %geo6, i8* %classname7, i64 %pt8)
  %geo10 = load i64, i64* %geo
  %classname11 = load i8*, i8** %classname
  %pt12 = load i64, i64* %pt
  %return13 = call i8* @"point@SISI"(i64 %geo10, i8* %classname11, i64 %pt12)
  %return14 = call i64 @"neg@II"(i64 2)
  %clusterattrib15 = load i8*, i8** %clusterattrib
  %usecluster16 = load i64, i64* %usecluster
  %1 = icmp ne i64 %usecluster16, 0
  br i1 %1, label %true17, label %end18

true17:                                           ; preds = %end
  %geo19 = load i64, i64* %geo
  %pt21 = load i64, i64* %pt
  %return22 = call i64 @"point@IISI"(i64 %geo19, i8* %clusterattrib15, i64 %pt21)
  %geo23 = load i64, i64* %geo
  %pt25 = load i64, i64* %pt
  %return26 = call i8* @"point@SISI"(i64 %geo23, i8* %clusterattrib15, i64 %pt25)
  %return28 = call i64 @"neg@II"(i64 1)
  %return29 = call i64 @"eq@III"(i64 %return22, i64 %return28)
  %2 = icmp ne i64 %return29, 0
  br i1 %2, label %true, label %end18

end18:                                            ; preds = %true17, %end
  %mycluster_s.0 = phi i8* [ %return26, %true17 ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @1, i64 0, i64 0), %end ]
  %mycluster.0 = phi i64 [ %return22, %true17 ], [ %return14, %end ]
  %cast = sitofp i64 %return9 to double
  %seed33 = load double, double* %seed
  %output = fadd double %seed33, 0x400921FB4D12D84A
  %return34 = call <2 x double> @"set@UFF"(double %cast, double %output)
  %return35 = call double @"rand@FU"(<2 x double> %return34)
  %threshold36 = load double, double* %threshold
  %return37 = fcmp olt double %return35, %threshold36
  br i1 %return37, label %true, label %end40

end40:                                            ; preds = %end18
  %geo41 = load i64, i64* %geo
  %dstgrp42 = load i8*, i8** %dstgrp
  %pt43 = load i64, i64* %pt
  %return44 = call i64 @"inpointgroup@IISI"(i64 %geo41, i8* %dstgrp42, i64 %pt43)
  %primgrp45 = load i8*, i8** %primgrp
  %return46 = call i64 @"strlen@IS"(i8* %primgrp45)
  %return47 = call i64 @"gt@III"(i64 %return46, i64 0)
  %geo48 = load i64, i64* %geo
  %dstgrp49 = load i8*, i8** %dstgrp
  %maxrad51 = load double, double* %maxrad
  %maxpt52 = load i64, i64* %maxpt
  %return53 = call i64* @"nearpoints@[IISVFI"(i64 %geo48, i8* %dstgrp49, <3 x double> %return, double %maxrad51, i64 %maxpt52)
  %pref54 = load i64, i64* %pref
  %return55 = call i64 @"eq@III"(i64 %pref54, i64 1)
  %3 = icmp ne i64 %return55, 0
  br i1 %3, label %true56, label %end57

true56:                                           ; preds = %end40
  %return59 = call i64* @"reverse@[I[I"(i64* %return53)
  br label %end57

end57:                                            ; preds = %true56, %end40
  %nearpts.0 = phi i64* [ %return59, %true56 ], [ %return53, %end40 ]
  %return61 = call i64 @"len@I[I"(i64* %nearpts.0)
  br label %cond

cond:                                             ; preds = %iter, %end57
  %__impl_foreach_index_18b.0 = phi i64 [ 0, %end57 ], [ %output217, %iter ]
  %nconstraints.0 = phi i64 [ %numconstraint3, %end57 ], [ %nconstraints.1, %iter ]
  %return64 = call i64 @"lt@III"(i64 %__impl_foreach_index_18b.0, i64 %return61)
  %4 = icmp ne i64 %return64, 0
  br i1 %4, label %body, label %true

body:                                             ; preds = %cond
  %return68 = call i64 @"getcomp@I[II"(i64* %nearpts.0, i64 %__impl_foreach_index_18b.0)
  %pt69 = load i64, i64* %pt
  %return71 = call i64 @"eq@III"(i64 %pt69, i64 %return68)
  %5 = icmp ne i64 %return71, 0
  br i1 %5, label %iter, label %end73

iter:                                             ; preds = %end166, %end174, %true145, %end127, %end116, %end99, %end87, %end73, %body
  %nconstraints.1 = phi i64 [ %nconstraints.0, %body ], [ %nconstraints.0, %end73 ], [ %nconstraints.0, %end87 ], [ %nconstraints.0, %end99 ], [ %nconstraints.0, %end116 ], [ %nconstraints.0, %end127 ], [ %nconstraints.0, %true145 ], [ %nconstraints.0, %end174 ], [ %output211, %end166 ]
  %output217 = add i64 %__impl_foreach_index_18b.0, 1
  br label %cond

end73:                                            ; preds = %body
  %minrad74 = load double, double* %minrad
  %return75 = fcmp ogt double %minrad74, 0.000000e+00
  %return76 = zext i1 %return75 to i64
  %geo78 = load i64, i64* %geo
  %return80 = call <3 x double> @"point@VISI"(i64 %geo78, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %return68)
  %return81 = call double @"distance@FVV"(<3 x double> %return, <3 x double> %return80)
  %minrad82 = load double, double* %minrad
  %return83 = fcmp olt double %return81, %minrad82
  %return84 = zext i1 %return83 to i64
  %return85 = call i64 @"and@III"(i64 %return76, i64 %return84)
  %6 = icmp ne i64 %return85, 0
  br i1 %6, label %iter, label %end87

end87:                                            ; preds = %end73
  %congeo89 = load i64, i64* %congeo
  %srcgrp90 = load i8*, i8** %srcgrp
  %return92 = call i64 @"inpointgroup@IISI"(i64 %congeo89, i8* %srcgrp90, i64 %return68)
  %return93 = call i64 @"and@III"(i64 %return44, i64 %return92)
  %pt95 = load i64, i64* %pt
  %return96 = call i64 @"lt@III"(i64 %return68, i64 %pt95)
  %return97 = call i64 @"and@III"(i64 %return93, i64 %return96)
  %7 = icmp ne i64 %return97, 0
  br i1 %7, label %iter, label %end99

end99:                                            ; preds = %end87
  %geo100 = load i64, i64* %geo
  %classname101 = load i8*, i8** %classname
  %return103 = call i64 @"point@IISI"(i64 %geo100, i8* %classname101, i64 %return68)
  %geo104 = load i64, i64* %geo
  %classname105 = load i8*, i8** %classname
  %return107 = call i8* @"point@SISI"(i64 %geo104, i8* %classname105, i64 %return68)
  %return110 = call i64 @"eq@III"(i64 %return103, i64 %return9)
  %return113 = call i64 @"eq@ISS"(i8* %return107, i8* %return13)
  %return114 = call i64 @"and@III"(i64 %return110, i64 %return113)
  %8 = icmp ne i64 %return114, 0
  br i1 %8, label %iter, label %end116

end116:                                           ; preds = %end99
  %cast118 = sitofp i64 %return103 to double
  %seed119 = load double, double* %seed
  %output120 = fadd double %seed119, 0x400921FB4D12D84A
  %return121 = call <2 x double> @"set@UFF"(double %cast118, double %output120)
  %return122 = call double @"rand@FU"(<2 x double> %return121)
  %threshold123 = load double, double* %threshold
  %return124 = fcmp olt double %return122, %threshold123
  br i1 %return124, label %iter, label %end127

end127:                                           ; preds = %end116
  %pt128 = load i64, i64* %pt
  %return130 = call i64 @"min@III"(i64 %pt128, i64 %return68)
  %cast131 = sitofp i64 %return130 to double
  %return134 = call i64 @"max@III"(i64 %pt128, i64 %return68)
  %cast135 = sitofp i64 %return134 to double
  %seed136 = load double, double* %seed
  %return137 = call <3 x double> @"set@VFFF"(double %cast131, double %cast135, double %seed136)
  %return138 = call double @"rand@FV"(<3 x double> %return137)
  %ptthreshold139 = load double, double* %ptthreshold
  %return140 = fcmp olt double %return138, %ptthreshold139
  br i1 %return140, label %iter, label %end143

end143:                                           ; preds = %end127
  %usecluster144 = load i64, i64* %usecluster
  %9 = icmp ne i64 %usecluster144, 0
  br i1 %9, label %true145, label %end146

true145:                                          ; preds = %end143
  %geo147 = load i64, i64* %geo
  %return150 = call i64 @"point@IISI"(i64 %geo147, i8* %clusterattrib15, i64 %return68)
  %geo151 = load i64, i64* %geo
  %return154 = call i8* @"point@SISI"(i64 %geo151, i8* %clusterattrib15, i64 %return68)
  %return157 = call i64 @"ne@III"(i64 %return150, i64 %mycluster.0)
  %return160 = call i64 @"ne@ISS"(i8* %return154, i8* %mycluster_s.0)
  %return161 = call i64 @"or@III"(i64 %return157, i64 %return160)
  %10 = icmp ne i64 %return161, 0
  br i1 %10, label %iter, label %end146

end146:                                           ; preds = %true145, %end143
  %11 = icmp ne i64 %return47, 0
  br i1 %11, label %true165, label %end166

true165:                                          ; preds = %end146
  %congeo167 = load i64, i64* %congeo
  %pt168 = load i64, i64* %pt
  %return170 = call i64 @"pointhedge@IIII"(i64 %congeo167, i64 %pt168, i64 %return68)
  %return172 = call i64 @"lt@III"(i64 %return170, i64 0)
  %12 = icmp ne i64 %return172, 0
  br i1 %12, label %true173, label %end174

end166:                                           ; preds = %end174, %end146
  %geo190 = load i64, i64* %geo
  %return192 = call <3 x double> @"point@VISI"(i64 %geo190, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %return68)
  %outgeo193 = load i64, i64* %outgeo
  %pt194 = load i64, i64* %pt
  %return196 = call i64* @"array@[I:II"(i64 %pt194, i64 %return68)
  %return197 = call i64 @"addprim@IIS[I"(i64 %outgeo193, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @2, i64 0, i64 0), i64* %return196)
  %return198 = call i64 @"geoself@I"()
  %outgrp199 = load i8*, i8** %outgrp
  %return201 = call i64 @"setprimgroup@IISII"(i64 %return198, i8* %outgrp199, i64 %return197, i64 1)
  %return204 = call double @"distance@FVV"(<3 x double> %return, <3 x double> %return192)
  %return205 = call i64 @"geoself@I"()
  %return208 = call i64 @"setprimattrib@IISIF"(i64 %return205, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @3, i64 0, i64 0), i64 %return197, double %return204)
  %output211 = sub i64 %nconstraints.0, 1
  %return213 = call i64 @"le@III"(i64 %output211, i64 0)
  %13 = icmp ne i64 %return213, 0
  br i1 %13, label %true, label %iter

true173:                                          ; preds = %true165
  %congeo175 = load i64, i64* %congeo
  %pt177 = load i64, i64* %pt
  %return178 = call i64 @"pointhedge@IIII"(i64 %congeo175, i64 %return68, i64 %pt177)
  br label %end174

end174:                                           ; preds = %true173, %true165
  %h.0 = phi i64 [ %return178, %true173 ], [ %return170, %true165 ]
  %return180 = call i64 @"ge@III"(i64 %h.0, i64 0)
  %congeo181 = load i64, i64* %congeo
  %primgrp182 = load i8*, i8** %primgrp
  %return185 = call i64 @"hedge_prim@III"(i64 %congeo181, i64 %h.0)
  %return186 = call i64 @"inprimgroup@IISI"(i64 %congeo181, i8* %primgrp182, i64 %return185)
  %return187 = call i64 @"and@III"(i64 %return180, i64 %return186)
  %14 = icmp ne i64 %return187, 0
  br i1 %14, label %iter, label %end166
}

; Function Attrs: nounwind
declare <3 x double> @"point@VISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"le@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"point@IISI"(i64, i8*, i64) #1

; Function Attrs: nounwind
declare i8* @"point@SISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"neg@II"(i64) #2

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare <2 x double> @"set@UFF"(double, double) #2

; Function Attrs: nounwind
declare double @"rand@FU"(<2 x double>) #1

; Function Attrs: nounwind
declare i64 @"inpointgroup@IISI"(i64, i8*, i64) #1

; Function Attrs: nounwind
declare i64 @"strlen@IS"(i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"gt@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64* @"nearpoints@[IISVFI"(i64, i8*, <3 x double>, double, i64) #1

; Function Attrs: nounwind
declare i64* @"reverse@[I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #2

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #2

; Function Attrs: nounwind
declare double @"distance@FVV"(<3 x double>, <3 x double>) #1

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"eq@ISS"(i8*, i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"min@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"max@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VFFF"(double, double, double) #2

; Function Attrs: nounwind
declare double @"rand@FV"(<3 x double>) #1

; Function Attrs: nounwind readnone
declare i64 @"ne@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"ne@ISS"(i8*, i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"pointhedge@IIII"(i64, i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"ge@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"hedge_prim@III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"inprimgroup@IISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64* @"array@[I:II"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"addprim@IIS[I"(i64, i8*, i64*) #1

; Function Attrs: nounwind
declare i64 @"geoself@I"() #1

; Function Attrs: nounwind
declare i64 @"setprimgroup@IISII"(i64, i8*, i64, i64) #1

; Function Attrs: nounwind
declare i64 @"setprimattrib@IISIF"(i64, i8*, i64, double) #1

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@I"(i64* %_bound_ptnum) #0 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64
  %2 = alloca i64
  %3 = alloca i8*
  %4 = alloca i8*
  %5 = alloca i8*
  %6 = alloca i8*
  %7 = alloca i64
  %8 = alloca i8*
  %9 = alloca i64
  %10 = alloca double
  %11 = alloca double
  %12 = alloca i64
  %13 = alloca i64
  %14 = alloca double
  %15 = alloca double
  %16 = alloca double
  %17 = alloca i64
  %18 = alloca i8*
  %return = call i64 @"chi@IS"(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @5, i64 0, i64 0))
  %return1 = call i64 @"not@II"(i64 %return)
  %19 = icmp ne i64 %return1, 0
  br i1 %19, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %return2 = call i8* @"chs@SS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @6, i64 0, i64 0))
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %classname.0 = phi i8* [ %return2, %true ], [ getelementptr inbounds ([10 x i8], [10 x i8]* @4, i64 0, i64 0), %__llvm_entry ]
  %return3 = call i8* @"chs@SS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @8, i64 0, i64 0))
  %return4 = call i8* @"chs@SS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @10, i64 0, i64 0))
  %return5 = call i64 @"chi@IS"(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @11, i64 0, i64 0))
  %_bound_ptnum7 = load i64, i64* %_bound_ptnum
  %return8 = call i64 @"point@IISI"(i64 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @12, i64 0, i64 0), i64 %_bound_ptnum7)
  %output = sub i64 %return5, %return8
  %return10 = call i64 @"gt@III"(i64 %output, i64 0)
  %20 = icmp ne i64 %return10, 0
  br i1 %20, label %true11, label %end12

true11:                                           ; preds = %end
  store i64 1, i64* %0
  store i64 0, i64* %1
  %_bound_ptnum13 = load i64, i64* %_bound_ptnum
  store i64 %_bound_ptnum13, i64* %2
  store i8* %return3, i8** %3
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @9, i64 0, i64 0), i8** %4
  store i8* %return4, i8** %5
  store i8* %classname.0, i8** %6
  %return18 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @13, i64 0, i64 0))
  store i64 %return18, i64* %7
  %return19 = call i8* @"chs@SS"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @14, i64 0, i64 0))
  store i8* %return19, i8** %8
  store i64 %output, i64* %9
  %return21 = call double @"chf@FS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @15, i64 0, i64 0))
  store double %return21, double* %10
  %return22 = call double @"chf@FS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @16, i64 0, i64 0))
  store double %return22, double* %11
  %return23 = call i64 @"chi@IS"(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @17, i64 0, i64 0))
  store i64 %return23, i64* %12
  %return24 = call i64 @"chi@IS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @18, i64 0, i64 0))
  store i64 %return24, i64* %13
  %return25 = call double @"chf@FS"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @19, i64 0, i64 0))
  store double %return25, double* %14
  %return26 = call double @"chf@FS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @20, i64 0, i64 0))
  store double %return26, double* %15
  %return27 = call double @"chf@FS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @21, i64 0, i64 0))
  store double %return27, double* %16
  %return28 = call i64 @"geoself@I"()
  store i64 %return28, i64* %17
  store i8* getelementptr inbounds ([21 x i8], [21 x i8]* @7, i64 0, i64 0), i8** %18
  call void @"createGlueConstraints@IIISSSSISIFFIIFFFIS"(i64* %0, i64* %1, i64* %2, i8** %3, i8** %4, i8** %5, i8** %6, i64* %7, i8** %8, i64* %9, double* %10, double* %11, i64* %12, i64* %13, double* %14, double* %15, double* %16, i64* %17, i8** %18)
  br label %end12

end12:                                            ; preds = %true11, %end
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #2

; Function Attrs: nounwind readnone
declare i8* @"chs@SS"(i8*) #2

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #2

; Function Attrs: nounwind
define void @__vex_snippet(i64 %ptnum) #1 {
__llvm_entry:
  %0 = alloca i64
  store i64 %ptnum, i64* %0
  call void @"__vex_snippet_snippet@I"(i64* %0)
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @22, i64 0, i64 0), i64 %ptnum) #3
  store i64 %gvalue, i64* @ptnum
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}

;_code_end
