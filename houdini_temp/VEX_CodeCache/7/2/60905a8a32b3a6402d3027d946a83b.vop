;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [0 x i64] zeroinitializer
@1 = private constant [14 x i8] c"../closeloops\00"
@2 = private constant [5 x i8] c"poly\00"
@3 = private constant [9 x i8] c"polyline\00"
@ptnum = external global i64
@4 = private constant [6 x i8] c"ptnum\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@I"(i64* %_bound_ptnum) #0 {
__llvm_entry:
  %path0 = alloca i64*
  %path1 = alloca i64*
  %0 = alloca i64
  %1 = alloca i64
  %2 = alloca i64
  %3 = alloca i64
  %path = alloca i64*
  %4 = alloca i64
  %5 = alloca i64
  %adj = alloca i64*
  %_bound_ptnum1 = load i64, i64* %_bound_ptnum
  %return = call i64* @"neighbours@[III"(i64 0, i64 %_bound_ptnum1)
  %return3 = call i64* @"sort@[I[I"(i64* %return)
  store i64* %return3, i64** %adj
  call void @"sortedRemoveDuplicates@[I"(i64** %adj)
  %adj4 = load i64*, i64** %adj
  %_bound_ptnum5 = load i64, i64* %_bound_ptnum
  %return6 = call { i64, i64* } @"removevalue@I[II"(i64* %adj4, i64 %_bound_ptnum5)
  %output = extractvalue { i64, i64* } %return6, 1
  store i64* %output, i64** %adj
  %return9 = call i64 @"len@I[I"(i64* %output)
  %return11 = call i64 @"eq@III"(i64 %return9, i64 0)
  %6 = icmp ne i64 %return11, 0
  br i1 %6, label %true, label %end

true:                                             ; preds = %cond120, %cond105, %true59, %true43, %end32, %end20, %end, %__llvm_entry
  ret void

end:                                              ; preds = %__llvm_entry
  %return13 = call i64 @"eq@III"(i64 %return9, i64 1)
  %_bound_ptnum14 = load i64, i64* %_bound_ptnum
  %return16 = call i64 @"getcomp@I[II"(i64* %output, i64 0)
  %return17 = call i64 @"gt@III"(i64 %_bound_ptnum14, i64 %return16)
  %return18 = call i64 @"and@III"(i64 %return13, i64 %return17)
  %7 = icmp ne i64 %return18, 0
  br i1 %7, label %true, label %end20

end20:                                            ; preds = %end
  %return22 = call i64 @"eq@III"(i64 %return9, i64 2)
  %return27 = call i64 @"getcomp@I[II"(i64* %output, i64 1)
  %return28 = call i64 @"min@III"(i64 %return16, i64 %return27)
  %return29 = call i64 @"gt@III"(i64 %_bound_ptnum14, i64 %return28)
  %return30 = call i64 @"and@III"(i64 %return22, i64 %return29)
  %8 = icmp ne i64 %return30, 0
  br i1 %8, label %true, label %end32

end32:                                            ; preds = %end20
  %output36 = sub i64 %return9, 1
  %return37 = call i64 @"getcomp@I[II"(i64* %output, i64 %output36)
  %return38 = call i64 @"gt@III"(i64 %_bound_ptnum14, i64 %return37)
  %9 = icmp ne i64 %return38, 0
  br i1 %9, label %true, label %end40

end40:                                            ; preds = %end32
  %10 = icmp ne i64 %return22, 0
  br i1 %10, label %true43, label %false

true43:                                           ; preds = %end40
  %return47 = call i64* @"array@[I:I"(i64 %return16)
  store i64* %return47, i64** %path0
  store i64* getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), i64** %path1, !vex-initializer-store !3
  %_bound_ptnum48 = load i64, i64* %_bound_ptnum
  store i64 %_bound_ptnum48, i64* %0
  %adj49 = load i64*, i64** %adj
  %return50 = call i64 @"getcomp@I[II"(i64* %adj49, i64 0)
  store i64 %return50, i64* %1
  %traceEdges = call i64 @"traceEdges@III[I"(i64* %0, i64* %1, i64** %path0)
  %return52 = call i64 @"eq@III"(i64 %traceEdges, i64 0)
  %11 = icmp ne i64 %return52, 0
  br i1 %11, label %true, label %end54

false:                                            ; preds = %end40
  br label %cond120

end54:                                            ; preds = %true43
  %return56 = call i64 @"eq@III"(i64 %traceEdges, i64 2)
  %return58 = call i64 @"not@II"(i64 %return56)
  %12 = icmp ne i64 %return58, 0
  br i1 %12, label %true59, label %end60

true59:                                           ; preds = %end54
  %adj61 = load i64*, i64** %adj
  %return62 = call i64 @"getcomp@I[II"(i64* %adj61, i64 1)
  %return63 = call i64* @"array@[I:I"(i64 %return62)
  store i64* %return63, i64** %path1
  %_bound_ptnum64 = load i64, i64* %_bound_ptnum
  store i64 %_bound_ptnum64, i64* %2
  %adj65 = load i64*, i64** %adj
  %return66 = call i64 @"getcomp@I[II"(i64* %adj65, i64 1)
  store i64 %return66, i64* %3
  %traceEdges67 = call i64 @"traceEdges@III[I"(i64* %2, i64* %3, i64** %path1)
  %return69 = call i64 @"eq@III"(i64 %traceEdges67, i64 0)
  %13 = icmp ne i64 %return69, 0
  br i1 %13, label %true, label %end60

end60:                                            ; preds = %true59, %end54
  %return72 = call i64 @"chi@IS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @1, i64 0, i64 0))
  %return74 = call i64 @"and@III"(i64 %return72, i64 %return56)
  %return75 = call i64 @"geoself@I"()
  %14 = icmp ne i64 %return74, 0
  %. = select i1 %14, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @2, i64 0, i64 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @3, i64 0, i64 0)
  %return80 = call i64 @"addprim@IIS"(i64 %return75, i8* %.)
  %path081 = load i64*, i64** %path0
  %return82 = call i64 @"len@I[I"(i64* %path081)
  %output84 = sub i64 %return82, %return74
  %path185 = load i64*, i64** %path1
  %return86 = call i64 @"len@I[I"(i64* %path185)
  %output88 = sub i64 %return86, 1
  br label %cond

cond:                                             ; preds = %body, %end60
  %i.0 = phi i64 [ %output88, %end60 ], [ %output99, %body ]
  %return90 = call i64 @"ge@III"(i64 %i.0, i64 0)
  %15 = icmp ne i64 %return90, 0
  %return92 = call i64 @"geoself@I"()
  br i1 %15, label %body, label %end91

body:                                             ; preds = %cond
  %path194 = load i64*, i64** %path1
  %return96 = call i64 @"getcomp@I[II"(i64* %path194, i64 %i.0)
  %return97 = call i64 @"addvertex@IIII"(i64 %return92, i64 %return80, i64 %return96)
  %output99 = sub i64 %i.0, 1
  br label %cond

end91:                                            ; preds = %cond
  %_bound_ptnum102 = load i64, i64* %_bound_ptnum
  %return103 = call i64 @"addvertex@IIII"(i64 %return92, i64 %return80, i64 %_bound_ptnum102)
  br label %cond105

cond105:                                          ; preds = %body106, %end91
  %i104.0 = phi i64 [ 0, %end91 ], [ %output119, %body106 ]
  %return109 = call i64 @"lt@III"(i64 %i104.0, i64 %output84)
  %16 = icmp ne i64 %return109, 0
  br i1 %16, label %body106, label %true

body106:                                          ; preds = %cond105
  %return112 = call i64 @"geoself@I"()
  %path0114 = load i64*, i64** %path0
  %return116 = call i64 @"getcomp@I[II"(i64* %path0114, i64 %i104.0)
  %return117 = call i64 @"addvertex@IIII"(i64 %return112, i64 %return80, i64 %return116)
  %output119 = add i64 %i104.0, 1
  br label %cond105

cond120:                                          ; preds = %iter126, %false
  %j.0 = phi i64 [ 0, %false ], [ %output189, %iter126 ]
  %n.0 = phi i64 [ %return9, %false ], [ %n.1, %iter126 ]
  %return124 = call i64 @"lt@III"(i64 %j.0, i64 %n.0)
  %17 = icmp ne i64 %return124, 0
  br i1 %17, label %body121, label %true

body121:                                          ; preds = %cond120
  %adj127 = load i64*, i64** %adj
  %return129 = call i64 @"getcomp@I[II"(i64* %adj127, i64 %j.0)
  %_bound_ptnum130 = load i64, i64* %_bound_ptnum
  %return131 = call i64 @"lt@III"(i64 %return129, i64 %_bound_ptnum130)
  %18 = icmp ne i64 %return131, 0
  br i1 %18, label %iter126, label %end133

iter126:                                          ; preds = %cond173, %end133, %body121
  %n.1 = phi i64 [ %n.0, %body121 ], [ %n.0, %end133 ], [ %n.2, %cond173 ]
  %output189 = add i64 %j.0, 1
  br label %cond120

end133:                                           ; preds = %body121
  %return137 = call i64* @"array@[I:I"(i64 %return129)
  store i64* %return137, i64** %path
  %_bound_ptnum139 = load i64, i64* %_bound_ptnum
  store i64 %_bound_ptnum139, i64* %4
  %adj140 = load i64*, i64** %adj
  %return142 = call i64 @"getcomp@I[II"(i64* %adj140, i64 %j.0)
  store i64 %return142, i64* %5
  %traceEdges143 = call i64 @"traceEdges@III[I"(i64* %4, i64* %5, i64** %path)
  %return145 = call i64 @"eq@III"(i64 %traceEdges143, i64 0)
  %19 = icmp ne i64 %return145, 0
  br i1 %19, label %iter126, label %end147

end147:                                           ; preds = %end133
  %path148 = load i64*, i64** %path
  %return149 = call i64 @"len@I[I"(i64* %path148)
  %return151 = call i64 @"eq@III"(i64 %traceEdges143, i64 2)
  %20 = icmp ne i64 %return151, 0
  br i1 %20, label %true152, label %end153

true152:                                          ; preds = %end147
  %output156 = sub i64 %return149, 2
  %return157 = call i64 @"getcomp@I[II"(i64* %path148, i64 %output156)
  %adj158 = load i64*, i64** %adj
  %return160 = call { i64, i64* } @"removevalue@I[II"(i64* %adj158, i64 %return157)
  %output162 = extractvalue { i64, i64* } %return160, 1
  store i64* %output162, i64** %adj
  %output164 = sub i64 %n.0, 1
  br label %end153

end153:                                           ; preds = %true152, %end147
  %n.2 = phi i64 [ %output164, %true152 ], [ %n.0, %end147 ]
  %return166 = call i64 @"geoself@I"()
  %return167 = call i64 @"addprim@IIS"(i64 %return166, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @3, i64 0, i64 0))
  %return168 = call i64 @"geoself@I"()
  %_bound_ptnum170 = load i64, i64* %_bound_ptnum
  %return171 = call i64 @"addvertex@IIII"(i64 %return168, i64 %return167, i64 %_bound_ptnum170)
  br label %cond173

cond173:                                          ; preds = %body174, %end153
  %i172.0 = phi i64 [ 0, %end153 ], [ %output187, %body174 ]
  %return177 = call i64 @"lt@III"(i64 %i172.0, i64 %return149)
  %21 = icmp ne i64 %return177, 0
  br i1 %21, label %body174, label %iter126

body174:                                          ; preds = %cond173
  %return180 = call i64 @"geoself@I"()
  %path182 = load i64*, i64** %path
  %return184 = call i64 @"getcomp@I[II"(i64* %path182, i64 %i172.0)
  %return185 = call i64 @"addvertex@IIII"(i64 %return180, i64 %return167, i64 %return184)
  %output187 = add i64 %i172.0, 1
  br label %cond173
}

; Function Attrs: alwaysinline nounwind
define private void @"sortedRemoveDuplicates@[I"(i64** %a) #0 {
__llvm_entry:
  %a1 = load i64*, i64** %a
  %return = call i64 @"len@I[I"(i64* %a1)
  %return3 = call i64 @"le@III"(i64 %return, i64 1)
  %0 = icmp ne i64 %return3, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %__llvm_entry
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  %return5 = call i64 @"getcomp@I[II"(i64* %a1, i64 0)
  br label %cond

cond:                                             ; preds = %end16, %end
  %prev.0 = phi i64 [ %return5, %end ], [ %prev.1, %end16 ]
  %desti.0 = phi i64 [ 1, %end ], [ %desti.1, %end16 ]
  %i.0 = phi i64 [ 1, %end ], [ %output34, %end16 ]
  %return8 = call i64 @"lt@III"(i64 %i.0, i64 %return)
  %1 = icmp ne i64 %return8, 0
  %a10 = load i64*, i64** %a
  br i1 %1, label %body, label %end9

body:                                             ; preds = %cond
  %return12 = call i64 @"getcomp@I[II"(i64* %a10, i64 %i.0)
  %return14 = call i64 @"ne@III"(i64 %return12, i64 %prev.0)
  %2 = icmp ne i64 %return14, 0
  br i1 %2, label %true15, label %end16

end9:                                             ; preds = %cond
  %output37 = call i64* @"resize@[II"(i64* %a10, i64 %desti.0)
  store i64* %output37, i64** %a
  br label %UnifiedReturnBlock

true15:                                           ; preds = %body
  %return19 = call i64 @"ne@III"(i64 %i.0, i64 %desti.0)
  %3 = icmp ne i64 %return19, 0
  br i1 %3, label %true20, label %end21

end16:                                            ; preds = %end21, %body
  %prev.1 = phi i64 [ %return32, %end21 ], [ %prev.0, %body ]
  %desti.1 = phi i64 [ %output29, %end21 ], [ %desti.0, %body ]
  %output34 = add i64 %i.0, 1
  br label %cond

true20:                                           ; preds = %true15
  %return26 = call { i64, i64* } @"setcomp@I[III"(i64* %a10, i64 %return12, i64 %desti.0)
  %output = extractvalue { i64, i64* } %return26, 1
  store i64* %output, i64** %a
  br label %end21

end21:                                            ; preds = %true20, %true15
  %output29 = add i64 %desti.0, 1
  %a30 = load i64*, i64** %a
  %return32 = call i64 @"getcomp@I[II"(i64* %a30, i64 %i.0)
  br label %end16

UnifiedReturnBlock:                               ; preds = %end9, %true
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare i64 @"le@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"ne@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare { i64, i64* } @"setcomp@I[III"(i64*, i64, i64) #1

; Function Attrs: nounwind readnone
declare i64* @"resize@[II"(i64*, i64) #1

; Function Attrs: alwaysinline nounwind
define private i64 @"traceEdges@III[I"(i64* %ifirst, i64* %inext, i64** %path) #0 {
__llvm_entry:
  %adj = alloca i64*
  %ifirst1 = load i64, i64* %ifirst
  %inext2 = load i64, i64* %inext
  br label %cond

cond:                                             ; preds = %end26, %__llvm_entry
  %next.0 = phi i64 [ %inext2, %__llvm_entry ], [ %return21, %end26 ]
  %prev.0 = phi i64 [ %ifirst1, %__llvm_entry ], [ %next.0, %end26 ]
  store i64* getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), i64** %adj, !vex-initializer-store !3
  %return = call i64* @"neighbours@[III"(i64 0, i64 %next.0)
  store i64* %return, i64** %adj
  %return5 = call i64* @"sort@[I[I"(i64* %return)
  store i64* %return5, i64** %adj
  call void @"sortedRemoveDuplicates@[I"(i64** %adj)
  %adj6 = load i64*, i64** %adj
  %return8 = call { i64, i64* } @"removevalue@I[II"(i64* %adj6, i64 %next.0)
  %output = extractvalue { i64, i64* } %return8, 1
  store i64* %output, i64** %adj
  %return12 = call { i64, i64* } @"removevalue@I[II"(i64* %output, i64 %prev.0)
  %output14 = extractvalue { i64, i64* } %return12, 1
  store i64* %output14, i64** %adj
  %return16 = call i64 @"len@I[I"(i64* %output14)
  %return18 = call i64 @"ne@III"(i64 %return16, i64 1)
  %0 = icmp ne i64 %return18, 0
  br i1 %0, label %end, label %end19

end:                                              ; preds = %end26, %end19, %cond
  %merge = phi i64 [ 1, %cond ], [ 0, %end19 ], [ 2, %end26 ]
  ret i64 %merge

end19:                                            ; preds = %cond
  %return21 = call i64 @"getcomp@I[II"(i64* %output14, i64 0)
  %ifirst23 = load i64, i64* %ifirst
  %return24 = call i64 @"lt@III"(i64 %return21, i64 %ifirst23)
  %1 = icmp ne i64 %return24, 0
  br i1 %1, label %end, label %end26

end26:                                            ; preds = %end19
  %path27 = load i64*, i64** %path
  %output29 = call i64* @"append@[II"(i64* %path27, i64 %return21)
  store i64* %output29, i64** %path
  %ifirst33 = load i64, i64* %ifirst
  %return34 = call i64 @"eq@III"(i64 %return21, i64 %ifirst33)
  %2 = icmp ne i64 %return34, 0
  br i1 %2, label %end, label %cond
}

; Function Attrs: nounwind
declare i64* @"neighbours@[III"(i64, i64) #2

; Function Attrs: nounwind
declare i64* @"sort@[I[I"(i64*) #2

; Function Attrs: nounwind
declare { i64, i64* } @"removevalue@I[II"(i64*, i64) #2

; Function Attrs: nounwind
declare i64* @"append@[II"(i64*, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"gt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"min@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64* @"array@[I:I"(i64) #1

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #1

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #1

; Function Attrs: nounwind
declare i64 @"geoself@I"() #2

; Function Attrs: nounwind
declare i64 @"addprim@IIS"(i64, i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"ge@III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"addvertex@IIII"(i64, i64, i64) #2

; Function Attrs: nounwind
define void @__vex_snippet(i64 %ptnum) #2 {
__llvm_entry:
  %0 = alloca i64
  store i64 %ptnum, i64* %0
  call void @"__vex_snippet_snippet@I"(i64* %0)
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @4, i64 0, i64 0), i64 %ptnum) #3
  store i64 %gvalue, i64* @ptnum
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}
!3 = !{!""}

;_code_end
