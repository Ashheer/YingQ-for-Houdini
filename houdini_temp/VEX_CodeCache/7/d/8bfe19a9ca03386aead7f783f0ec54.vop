;_name	/obj/geo1/polyexpand_fee1/grouppromote_fee1/attribwrangle1/attribvop1
; ModuleID = 'obj_geo1_polyexpand_fee1_grouppromote_fee1_attribwrangle1_attribvop1'

@0 = private constant [0 x i64] zeroinitializer
@1 = private constant [37 x i8] c"fee ingroup func error invalid class\00"
@2 = private constant [9 x i8] c"../group\00"
@3 = private constant [10 x i8] c"../totype\00"
@4 = private constant [12 x i8] c"../fromtype\00"
@5 = private constant [37 x i8] c"FeE Group Promote: same type promote\00"
@6 = private constant [18 x i8] c"../usematchattrib\00"
@7 = private constant [15 x i8] c"../matchattrib\00"
@8 = private constant [13 x i8] c"../matchtype\00"
@9 = private constant [12 x i8] c"../onlyfull\00"
@10 = private constant [18 x i8] c"../nummatchattrib\00"
@11 = private constant [19 x i8] c"vex_selectiongroup\00"
@12 = private constant [19 x i8] c"../onlyfirstvertex\00"
@13 = private constant [18 x i8] c"no this operation\00"
@elemnum = external global i64
@14 = private constant [8 x i8] c"elemnum\00"

declare i64* @"pointprims@[III"(i64, i64) nounwind

declare i64 @"len@I[I"(i64*) nounwind readnone

declare i64 @"lt@III"(i64, i64) nounwind readnone

declare i64 @"getcomp@I[II"(i64*, i64) nounwind readnone

declare { i64, i64* } @"removevalue@I[II"(i64*, i64) nounwind

declare i64* @"push@[II"(i64*, i64) nounwind readnone

declare i64 @"vertexindex@IIII"(i64, i64, i64) nounwind

declare i64 @"vertexpoint@III"(i64, i64) nounwind

define private i64* @"primhedges@[III"(i64* %geo, i64* %primnum) nounwind alwaysinline {
__llvm_entry:
  %geo1 = load i64* %geo
  %primnum2 = load i64* %primnum
  %return = call i64 @"primhedge@III"(i64 %geo1, i64 %primnum2)
  br label %body

body:                                             ; preds = %body, %__llvm_entry
  %hnums.0 = phi i64* [ getelementptr inbounds ([0 x i64]* @0, i64 0, i64 0), %__llvm_entry ], [ %output, %body ]
  %hnext.0 = phi i64 [ %return, %__llvm_entry ], [ %return15, %body ]
  %output = call i64* @"push@[II"(i64* %hnums.0, i64 %hnext.0)
  %geo13 = load i64* %geo
  %return15 = call i64 @"hedge_next@III"(i64 %geo13, i64 %hnext.0)
  %return6 = call i64 @"ne@III"(i64 %return15, i64 %return)
  %return8 = call i64 @"neg@II"(i64 1)
  %return9 = call i64 @"ne@III"(i64 %return15, i64 %return8)
  %return10 = call i64 @"and@III"(i64 %return6, i64 %return9)
  %0 = icmp ne i64 %return10, 0
  br i1 %0, label %body, label %end

end:                                              ; preds = %body
  ret i64* %output
}

declare i64 @"primhedge@III"(i64, i64) nounwind

declare i64 @"ne@III"(i64, i64) nounwind readnone

declare i64 @"neg@II"(i64) nounwind readnone

declare i64 @"and@III"(i64, i64) nounwind readnone

declare i64 @"hedge_next@III"(i64, i64) nounwind

define private i64* @"hedge_prim@[II[I"(i64* %geo, i64** %hnums) nounwind alwaysinline {
__llvm_entry:
  %hnums2 = load i64** %hnums
  %return = call i64 @"len@I[I"(i64* %hnums2)
  %output = call i64* @"resize@[II"(i64* getelementptr inbounds ([0 x i64]* @0, i64 0, i64 0), i64 %return)
  %output5 = sub i64 %return, 1
  br label %cond

cond:                                             ; preds = %body, %__llvm_entry
  %result.0 = phi i64* [ %output, %__llvm_entry ], [ %output17, %body ]
  %i.0 = phi i64 [ %output5, %__llvm_entry ], [ %output19, %body ]
  %return7 = call i64 @"neg@II"(i64 1)
  %return8 = call i64 @"gt@III"(i64 %i.0, i64 %return7)
  %0 = icmp ne i64 %return8, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %geo10 = load i64* %geo
  %hnums11 = load i64** %hnums
  %return13 = call i64 @"getcomp@I[II"(i64* %hnums11, i64 %i.0)
  %return14 = call i64 @"hedge_prim@III"(i64 %geo10, i64 %return13)
  %return15 = call { i64, i64* } @"setcomp@I[III"(i64* %result.0, i64 %return14, i64 %i.0)
  %output17 = extractvalue { i64, i64* } %return15, 1
  %output19 = sub i64 %i.0, 1
  br label %cond

end:                                              ; preds = %cond
  ret i64* %result.0
}

declare i64* @"resize@[II"(i64*, i64) nounwind readnone

declare i64 @"gt@III"(i64, i64) nounwind readnone

declare i64 @"hedge_prim@III"(i64, i64) nounwind

declare { i64, i64* } @"setcomp@I[III"(i64*, i64, i64) nounwind readnone

define private i64* @"hedge_equivs@[III"(i64* %geo, i64* %hnum) nounwind alwaysinline {
__llvm_entry:
  %geo1 = load i64* %geo
  %hnum2 = load i64* %hnum
  %return = call i64 @"hedge_equivcount@III"(i64 %geo1, i64 %hnum2)
  %return4 = call i64 @"neg@II"(i64 1)
  %return5 = call i64 @"eq@III"(i64 %return, i64 %return4)
  %0 = icmp ne i64 %return5, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %return6 = call i64* @"array@[I"()
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  %output = call i64* @"resize@[II"(i64* getelementptr inbounds ([0 x i64]* @0, i64 0, i64 0), i64 %return)
  %hnum9 = load i64* %hnum
  %return10 = call { i64, i64* } @"setcomp@I[III"(i64* %output, i64 %hnum9, i64 0)
  %output12 = extractvalue { i64, i64* } %return10, 1
  br label %cond

cond:                                             ; preds = %body, %end
  %i.0 = phi i64 [ 1, %end ], [ %output29, %body ]
  %hedges.0 = phi i64* [ %output12, %end ], [ %output27, %body ]
  %return15 = call i64 @"lt@III"(i64 %i.0, i64 %return)
  %1 = icmp ne i64 %return15, 0
  br i1 %1, label %body, label %end16

body:                                             ; preds = %cond
  %geo18 = load i64* %geo
  %output21 = sub i64 %i.0, 1
  %return22 = call i64 @"getcomp@I[II"(i64* %hedges.0, i64 %output21)
  %return23 = call i64 @"hedge_nextequiv@III"(i64 %geo18, i64 %return22)
  %return25 = call { i64, i64* } @"setcomp@I[III"(i64* %hedges.0, i64 %return23, i64 %i.0)
  %output27 = extractvalue { i64, i64* } %return25, 1
  %output29 = add i64 %i.0, 1
  br label %cond

end16:                                            ; preds = %cond
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end16, %true
  %UnifiedRetVal = phi i64* [ %return6, %true ], [ %hedges.0, %end16 ]
  ret i64* %UnifiedRetVal
}

declare i64 @"hedge_equivcount@III"(i64, i64) nounwind

declare i64 @"eq@III"(i64, i64) nounwind readnone

declare i64* @"array@[I"() nounwind readnone

declare i64 @"hedge_nextequiv@III"(i64, i64) nounwind

define private void @"_obj_geo1_polyexpand_fee1_grouppromote_fee1_attribwrangle1_attribvop1_snippet1@I"(i64* %_bound_elemnum) nounwind alwaysinline {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64
  %2 = alloca i64
  %3 = alloca i64*
  %4 = alloca i64
  %5 = alloca i64
  %6 = alloca i64
  %7 = alloca i64
  %times = alloca i64
  %8 = alloca i64*
  %9 = alloca i64
  %10 = alloca i64
  %11 = alloca i8*
  %12 = alloca i64
  %13 = alloca i64
  %14 = alloca i64
  %15 = alloca i8*
  %16 = alloca i64
  %return = call i8* @"chs@SS"(i8* getelementptr inbounds ([9 x i8]* @2, i64 0, i64 0))
  %return1 = call i8** @"split@[SS"(i8* %return)
  %return2 = call i64 @"chi@IS"(i8* getelementptr inbounds ([10 x i8]* @3, i64 0, i64 0))
  %return3 = call i64 @"eq@III"(i64 %return2, i64 0)
  %17 = icmp ne i64 %return3, 0
  br i1 %17, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %return4 = call i64 @"chi@IS"(i8* getelementptr inbounds ([12 x i8]* @4, i64 0, i64 0))
  %return5 = call i64 @"eq@III"(i64 %return4, i64 0)
  %18 = icmp ne i64 %return5, 0
  br i1 %18, label %true6, label %false7

false:                                            ; preds = %__llvm_entry
  %return29 = call i64 @"eq@III"(i64 %return2, i64 1)
  %19 = icmp ne i64 %return29, 0
  br i1 %19, label %true30, label %false31

true6:                                            ; preds = %true
  call void @"error@S"(i8* getelementptr inbounds ([37 x i8]* @5, i64 0, i64 0))
  br label %true72

false7:                                           ; preds = %true
  %return10 = call i64 @"eq@III"(i64 %return4, i64 1)
  %20 = icmp ne i64 %return10, 0
  br i1 %20, label %true11, label %false12

true11:                                           ; preds = %false7
  %_bound_elemnum14 = load i64* %_bound_elemnum
  %return15 = call i64* @"primpoints@[III"(i64 0, i64 %_bound_elemnum14)
  br label %true72

false12:                                          ; preds = %false7
  %return17 = call i64 @"eq@III"(i64 %return4, i64 2)
  %21 = icmp ne i64 %return17, 0
  br i1 %21, label %true18, label %false19

true18:                                           ; preds = %false12
  store i64 0, i64* %0
  %_bound_elemnum21 = load i64* %_bound_elemnum
  store i64 %_bound_elemnum21, i64* %1
  %primhedges = call i64* @"primhedges@[III"(i64* %0, i64* %1)
  br label %true72

false19:                                          ; preds = %false12
  %return23 = call i64 @"eq@III"(i64 %return4, i64 3)
  %22 = icmp ne i64 %return23, 0
  br i1 %22, label %true24, label %true72

true24:                                           ; preds = %false19
  %_bound_elemnum26 = load i64* %_bound_elemnum
  %return27 = call i64* @"primvertices@[III"(i64 0, i64 %_bound_elemnum26)
  br label %true72

true30:                                           ; preds = %false
  %return33 = call i64 @"chi@IS"(i8* getelementptr inbounds ([12 x i8]* @4, i64 0, i64 0))
  %return34 = call i64 @"eq@III"(i64 %return33, i64 0)
  %23 = icmp ne i64 %return34, 0
  br i1 %23, label %true35, label %false36

false31:                                          ; preds = %false
  %return59 = call i64 @"eq@III"(i64 %return2, i64 2)
  %24 = icmp ne i64 %return59, 0
  br i1 %24, label %true60, label %false61

true35:                                           ; preds = %true30
  %_bound_elemnum38 = load i64* %_bound_elemnum
  %return39 = call i64* @"pointprims@[III"(i64 0, i64 %_bound_elemnum38)
  br label %true72

false36:                                          ; preds = %true30
  %return41 = call i64 @"eq@III"(i64 %return33, i64 1)
  %25 = icmp ne i64 %return41, 0
  br i1 %25, label %true42, label %false43

true42:                                           ; preds = %false36
  call void @"error@S"(i8* getelementptr inbounds ([37 x i8]* @5, i64 0, i64 0))
  br label %true72

false43:                                          ; preds = %false36
  %return46 = call i64 @"eq@III"(i64 %return33, i64 2)
  %26 = icmp ne i64 %return46, 0
  br i1 %26, label %true47, label %false48

true47:                                           ; preds = %false43
  %_bound_elemnum50 = load i64* %_bound_elemnum
  %return51 = call i64* @"neighbours@[III"(i64 0, i64 %_bound_elemnum50)
  br label %true72

false48:                                          ; preds = %false43
  %return53 = call i64 @"eq@III"(i64 %return33, i64 3)
  %27 = icmp ne i64 %return53, 0
  br i1 %27, label %true54, label %true72

true54:                                           ; preds = %false48
  %_bound_elemnum56 = load i64* %_bound_elemnum
  %return57 = call i64* @"pointvertices@[III"(i64 0, i64 %_bound_elemnum56)
  br label %true72

true60:                                           ; preds = %false31
  %_bound_elemnum63 = load i64* %_bound_elemnum
  %return64 = call i64 @"hedge_nextequiv@III"(i64 0, i64 %_bound_elemnum63)
  %_bound_elemnum65 = load i64* %_bound_elemnum
  %return67 = call i64 @"lt@III"(i64 %_bound_elemnum65, i64 %return64)
  %return69 = call i64 @"neg@II"(i64 1)
  %return70 = call i64 @"eq@III"(i64 %return64, i64 %return69)
  %return71 = call i64 @"or@III"(i64 %return67, i64 %return70)
  %28 = icmp ne i64 %return71, 0
  br i1 %28, label %true72, label %end73

false61:                                          ; preds = %false31
  %return235 = call i64 @"eq@III"(i64 %return2, i64 3)
  %29 = icmp ne i64 %return235, 0
  br i1 %29, label %true236, label %true72

true72:                                           ; preds = %false272, %true279, %true271, %true263, %true255, %false61, %false48, %true54, %true47, %true42, %true35, %false19, %true24, %true18, %true11, %true6, %true239, %true60
  br label %UnifiedReturnBlock

end73:                                            ; preds = %true60
  %return75 = call i64 @"hedge_srcpoint@III"(i64 0, i64 %_bound_elemnum65)
  %_bound_elemnum76 = load i64* %_bound_elemnum
  %return77 = call i64 @"hedge_dstpoint@III"(i64 0, i64 %_bound_elemnum76)
  %return78 = call i64 @"chi@IS"(i8* getelementptr inbounds ([12 x i8]* @4, i64 0, i64 0))
  %return79 = call i64 @"eq@III"(i64 %return78, i64 0)
  %30 = icmp ne i64 %return79, 0
  br i1 %30, label %true80, label %false81

true80:                                           ; preds = %end73
  store i64 0, i64* %2
  store i64 0, i64* %4
  %_bound_elemnum83 = load i64* %_bound_elemnum
  store i64 %_bound_elemnum83, i64* %5
  %hedge_equivs = call i64* @"hedge_equivs@[III"(i64* %4, i64* %5)
  store i64* %hedge_equivs, i64** %3
  %hedge_prim = call i64* @"hedge_prim@[II[I"(i64* %2, i64** %3)
  br label %end82

false81:                                          ; preds = %end73
  %return85 = call i64 @"eq@III"(i64 %return78, i64 1)
  %31 = icmp ne i64 %return85, 0
  br i1 %31, label %true86, label %false87

end82:                                            ; preds = %false95, %true99, %true94, %true86, %true80
  %targetelems.0 = phi i64* [ %hedge_prim, %true80 ], [ %return91, %true86 ], [ getelementptr inbounds ([0 x i64]* @0, i64 0, i64 0), %true94 ], [ %hedge_equivs102, %true99 ], [ getelementptr inbounds ([0 x i64]* @0, i64 0, i64 0), %false95 ]
  %return103 = call i64 @"chi@IS"(i8* getelementptr inbounds ([18 x i8]* @6, i64 0, i64 0))
  %32 = icmp ne i64 %return103, 0
  br i1 %32, label %true104, label %false105

true86:                                           ; preds = %false81
  %return91 = call i64* @"array@[I:II"(i64 %return75, i64 %return77)
  br label %end82

false87:                                          ; preds = %false81
  %return93 = call i64 @"eq@III"(i64 %return78, i64 2)
  %33 = icmp ne i64 %return93, 0
  br i1 %33, label %true94, label %false95

true94:                                           ; preds = %false87
  call void @"error@S"(i8* getelementptr inbounds ([37 x i8]* @5, i64 0, i64 0))
  br label %end82

false95:                                          ; preds = %false87
  %return98 = call i64 @"eq@III"(i64 %return78, i64 3)
  %34 = icmp ne i64 %return98, 0
  br i1 %34, label %true99, label %end82

true99:                                           ; preds = %false95
  store i64 0, i64* %6
  %_bound_elemnum101 = load i64* %_bound_elemnum
  store i64 %_bound_elemnum101, i64* %7
  %hedge_equivs102 = call i64* @"hedge_equivs@[III"(i64* %6, i64* %7)
  br label %end82

true104:                                          ; preds = %end82
  %return109 = call i64 @"len@I[I"(i64* %targetelems.0)
  %output = call i64* @"resize@[II"(i64* getelementptr inbounds ([0 x i64]* @0, i64 0, i64 0), i64 %return109)
  %output112 = sub i64 %return109, 1
  br label %cond

false105:                                         ; preds = %end82
  br label %end106

end106:                                           ; preds = %false105, %end132
  %flag_matchattrib.0 = phi i64 [ %return141, %end132 ], [ 1, %false105 ]
  %return142 = call i64 @"chi@IS"(i8* getelementptr inbounds ([12 x i8]* @9, i64 0, i64 0))
  %35 = icmp ne i64 %return142, 0
  br i1 %35, label %true143, label %false144

cond:                                             ; preds = %body, %true104
  %i.0 = phi i64 [ %output112, %true104 ], [ %output128, %body ]
  %matchattribs.0 = phi i64* [ %output, %true104 ], [ %output126, %body ]
  %return115 = call i64 @"gt@III"(i64 %i.0, i64 %return69)
  %36 = icmp ne i64 %return115, 0
  br i1 %36, label %body, label %end116

body:                                             ; preds = %cond
  %return118 = call i8* @"chs@SS"(i8* getelementptr inbounds ([12 x i8]* @4, i64 0, i64 0))
  %return119 = call i8* @"chs@SS"(i8* getelementptr inbounds ([15 x i8]* @7, i64 0, i64 0))
  %return122 = call i64 @"getcomp@I[II"(i64* %targetelems.0, i64 %i.0)
  %return123 = call i64 @"attrib@IISSI"(i64 0, i8* %return118, i8* %return119, i64 %return122)
  %return124 = call { i64, i64* } @"setcomp@I[III"(i64* %matchattribs.0, i64 %return123, i64 %i.0)
  %output126 = extractvalue { i64, i64* } %return124, 1
  %output128 = sub i64 %i.0, 1
  br label %cond

end116:                                           ; preds = %cond
  store i64 0, i64* %times, !vex-initializer-store !3
  %return129 = call i64 @"chi@IS"(i8* getelementptr inbounds ([13 x i8]* @8, i64 0, i64 0))
  %37 = icmp ne i64 %return129, 0
  store i64* %matchattribs.0, i64** %8
  br i1 %37, label %true130, label %false131

true130:                                          ; preds = %end116
  %nuniqueval = call i64 @"nuniqueval@I[I"(i64** %8)
  store i64 %nuniqueval, i64* %times
  br label %end132

false131:                                         ; preds = %end116
  %mode = call i64 @"mode@I[II"(i64** %8, i64* %times)
  br label %end132

end132:                                           ; preds = %false131, %true130
  %times135 = load i64* %times
  %return136 = call i64 @"chi@IS"(i8* getelementptr inbounds ([12 x i8]* @9, i64 0, i64 0))
  %return139 = call i64 @"chi@IS"(i8* getelementptr inbounds ([18 x i8]* @10, i64 0, i64 0))
  %38 = icmp ne i64 %return136, 0
  %return140 = select i1 %38, i64 %return109, i64 %return139
  %return141 = call i64 @"ge@III"(i64 %times135, i64 %return140)
  br label %end106

true143:                                          ; preds = %end106
  %return147 = call i64 @"len@I[S"(i8** %return1)
  br label %cond148

false144:                                         ; preds = %end106
  %return188 = call i64 @"len@I[S"(i8** %return1)
  br label %cond189

end145:                                           ; preds = %end207, %cond189, %end165, %cond148
  %flag.0 = phi i64 [ %flag.2, %end165 ], [ %flag.1, %cond148 ], [ %flag.4, %end207 ], [ %flag.3, %cond189 ]
  %return227 = call i8* @"chs@SS"(i8* getelementptr inbounds ([19 x i8]* @11, i64 0, i64 0))
  %return232 = call i64 @"and@III"(i64 %flag.0, i64 %flag_matchattrib.0)
  %return233 = call i64 @"setedgegroup@IISIII"(i64 0, i8* %return227, i64 %return75, i64 %return77, i64 %return232)
  br label %UnifiedReturnBlock

cond148:                                          ; preds = %end183, %true143
  %__impl_foreach_index_a.0 = phi i64 [ 0, %true143 ], [ %output185, %end183 ]
  %flag.1 = phi i64 [ 1, %true143 ], [ %flag.2, %end183 ]
  %return152 = call i64 @"lt@III"(i64 %__impl_foreach_index_a.0, i64 %return147)
  %39 = icmp ne i64 %return152, 0
  br i1 %39, label %body149, label %end145

body149:                                          ; preds = %cond148
  %return157 = call i8* @"getcomp@S[SI"(i8** %return1, i64 %__impl_foreach_index_a.0)
  %return159 = call i64 @"len@I[I"(i64* %targetelems.0)
  br label %cond160

cond160:                                          ; preds = %end177, %body149
  %__impl_foreach_index_9.0 = phi i64 [ 0, %body149 ], [ %output179, %end177 ]
  %return164 = call i64 @"lt@III"(i64 %__impl_foreach_index_9.0, i64 %return159)
  %40 = icmp ne i64 %return164, 0
  br i1 %40, label %body161, label %end165

body161:                                          ; preds = %cond160
  %return169 = call i64 @"getcomp@I[II"(i64* %targetelems.0, i64 %__impl_foreach_index_9.0)
  store i64 0, i64* %9
  store i64 %return78, i64* %10
  store i8* %return157, i8** %11
  store i64 %return169, i64* %12
  %ingroup173 = call i64 @"ingroup@IIISI"(i64* %9, i64* %10, i8** %11, i64* %12)
  %return175 = call i64 @"not@II"(i64 %ingroup173)
  %41 = icmp ne i64 %return175, 0
  br i1 %41, label %true176, label %end177

end165:                                           ; preds = %true176, %cond160
  %flag.2 = phi i64 [ 0, %true176 ], [ %flag.1, %cond160 ]
  %return181 = call i64 @"not@II"(i64 %flag.2)
  %42 = icmp ne i64 %return181, 0
  br i1 %42, label %end145, label %end183

true176:                                          ; preds = %body161
  br label %end165

end177:                                           ; preds = %body161
  %output179 = add i64 %__impl_foreach_index_9.0, 1
  br label %cond160

end183:                                           ; preds = %end165
  %output185 = add i64 %__impl_foreach_index_a.0, 1
  br label %cond148

cond189:                                          ; preds = %end224, %false144
  %__impl_foreach_index_c.0 = phi i64 [ 0, %false144 ], [ %output226, %end224 ]
  %flag.3 = phi i64 [ 0, %false144 ], [ %flag.4, %end224 ]
  %return193 = call i64 @"lt@III"(i64 %__impl_foreach_index_c.0, i64 %return188)
  %43 = icmp ne i64 %return193, 0
  br i1 %43, label %body190, label %end145

body190:                                          ; preds = %cond189
  %return198 = call i8* @"getcomp@S[SI"(i8** %return1, i64 %__impl_foreach_index_c.0)
  %return201 = call i64 @"len@I[I"(i64* %targetelems.0)
  br label %cond202

cond202:                                          ; preds = %end219, %body190
  %__impl_foreach_index_b.0 = phi i64 [ 0, %body190 ], [ %output221, %end219 ]
  %return206 = call i64 @"lt@III"(i64 %__impl_foreach_index_b.0, i64 %return201)
  %44 = icmp ne i64 %return206, 0
  br i1 %44, label %body203, label %end207

body203:                                          ; preds = %cond202
  %return211 = call i64 @"getcomp@I[II"(i64* %targetelems.0, i64 %__impl_foreach_index_b.0)
  store i64 0, i64* %13
  store i64 %return78, i64* %14
  store i8* %return198, i8** %15
  store i64 %return211, i64* %16
  %ingroup216 = call i64 @"ingroup@IIISI"(i64* %13, i64* %14, i8** %15, i64* %16)
  %45 = icmp ne i64 %ingroup216, 0
  br i1 %45, label %true218, label %end219

end207:                                           ; preds = %true218, %cond202
  %flag.4 = phi i64 [ 1, %true218 ], [ %flag.3, %cond202 ]
  %46 = icmp ne i64 %flag.4, 0
  br i1 %46, label %end145, label %end224

true218:                                          ; preds = %body203
  br label %end207

end219:                                           ; preds = %body203
  %output221 = add i64 %__impl_foreach_index_b.0, 1
  br label %cond202

end224:                                           ; preds = %end207
  %output226 = add i64 %__impl_foreach_index_c.0, 1
  br label %cond189

true236:                                          ; preds = %false61
  %return238 = call i64 @"chi@IS"(i8* getelementptr inbounds ([19 x i8]* @12, i64 0, i64 0))
  %47 = icmp ne i64 %return238, 0
  br i1 %47, label %true239, label %end240

true239:                                          ; preds = %true236
  %_bound_elemnum242 = load i64* %_bound_elemnum
  %return243 = call i64 @"hedge_nextequiv@III"(i64 0, i64 %_bound_elemnum242)
  %_bound_elemnum244 = load i64* %_bound_elemnum
  %return246 = call i64 @"lt@III"(i64 %_bound_elemnum244, i64 %return243)
  %return248 = call i64 @"neg@II"(i64 1)
  %return249 = call i64 @"eq@III"(i64 %return243, i64 %return248)
  %return250 = call i64 @"or@III"(i64 %return246, i64 %return249)
  %48 = icmp ne i64 %return250, 0
  br i1 %48, label %true72, label %end240

end240:                                           ; preds = %true239, %true236
  %return253 = call i64 @"chi@IS"(i8* getelementptr inbounds ([12 x i8]* @4, i64 0, i64 0))
  %return254 = call i64 @"eq@III"(i64 %return253, i64 0)
  %49 = icmp ne i64 %return254, 0
  br i1 %49, label %true255, label %false256

true255:                                          ; preds = %end240
  call void @"error@S"(i8* getelementptr inbounds ([18 x i8]* @13, i64 0, i64 0))
  %_bound_elemnum258 = load i64* %_bound_elemnum
  %return259 = call i64 @"vertexpoint@III"(i64 0, i64 %_bound_elemnum258)
  br label %true72

false256:                                         ; preds = %end240
  %return262 = call i64 @"eq@III"(i64 %return253, i64 1)
  %50 = icmp ne i64 %return262, 0
  br i1 %50, label %true263, label %false264

true263:                                          ; preds = %false256
  call void @"error@S"(i8* getelementptr inbounds ([18 x i8]* @13, i64 0, i64 0))
  %_bound_elemnum266 = load i64* %_bound_elemnum
  %return267 = call i64 @"vertexprim@III"(i64 0, i64 %_bound_elemnum266)
  br label %true72

false264:                                         ; preds = %false256
  %return270 = call i64 @"eq@III"(i64 %return253, i64 2)
  %51 = icmp ne i64 %return270, 0
  br i1 %51, label %true271, label %false272

true271:                                          ; preds = %false264
  %_bound_elemnum274 = load i64* %_bound_elemnum
  %return275 = call i64 @"vertexhedge@III"(i64 0, i64 %_bound_elemnum274)
  br label %true72

false272:                                         ; preds = %false264
  %return278 = call i64 @"eq@III"(i64 %return253, i64 3)
  %52 = icmp ne i64 %return278, 0
  br i1 %52, label %true279, label %true72

true279:                                          ; preds = %false272
  call void @"error@S"(i8* getelementptr inbounds ([37 x i8]* @5, i64 0, i64 0))
  br label %true72

UnifiedReturnBlock:                               ; preds = %end145, %true72
  ret void
}

define private i64 @"nuniqueval@I[I"(i64** %arr) nounwind alwaysinline {
__llvm_entry:
  %arr1 = load i64** %arr
  %return = call i64 @"len@I[I"(i64* %arr1)
  %output = sub i64 %return, 1
  br label %cond

cond:                                             ; preds = %end26, %__llvm_entry
  %result.0 = phi i64 [ 0, %__llvm_entry ], [ %result.1, %end26 ]
  %i.0 = phi i64 [ %output, %__llvm_entry ], [ %output6, %end26 ]
  %return3 = call i64 @"neg@II"(i64 1)
  %return4 = call i64 @"gt@III"(i64 %i.0, i64 %return3)
  %0 = icmp ne i64 %return4, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %output6 = sub i64 %i.0, 1
  br label %cond7

end:                                              ; preds = %cond
  ret i64 %result.0

cond7:                                            ; preds = %end21, %body
  %j.0 = phi i64 [ %output6, %body ], [ %output23, %end21 ]
  %return11 = call i64 @"gt@III"(i64 %j.0, i64 %return3)
  %1 = icmp ne i64 %return11, 0
  br i1 %1, label %body8, label %end12

body8:                                            ; preds = %cond7
  %arr14 = load i64** %arr
  %return16 = call i64 @"getcomp@I[II"(i64* %arr14, i64 %i.0)
  %return19 = call i64 @"getcomp@I[II"(i64* %arr14, i64 %j.0)
  %return20 = call i64 @"eq@III"(i64 %return16, i64 %return19)
  %2 = icmp ne i64 %return20, 0
  br i1 %2, label %true, label %end21

end12:                                            ; preds = %true, %cond7
  %flag.0 = phi i64 [ 0, %true ], [ 1, %cond7 ]
  %3 = icmp ne i64 %flag.0, 0
  br i1 %3, label %true25, label %end26

true:                                             ; preds = %body8
  br label %end12

end21:                                            ; preds = %body8
  %output23 = sub i64 %j.0, 1
  br label %cond7

true25:                                           ; preds = %end12
  %output28 = add i64 %result.0, 1
  br label %end26

end26:                                            ; preds = %true25, %end12
  %result.1 = phi i64 [ %output28, %true25 ], [ %result.0, %end12 ]
  br label %cond
}

define private i64 @"mode@I[II"(i64** %arr, i64* %times) nounwind alwaysinline {
__llvm_entry:
  %arr1 = load i64** %arr
  %return = call i64 @"len@I[I"(i64* %arr1)
  %output = call i64* @"resize@[II"(i64* getelementptr inbounds ([0 x i64]* @0, i64 0, i64 0), i64 %return)
  br label %cond

cond:                                             ; preds = %iter, %__llvm_entry
  %mask.0 = phi i64* [ %output, %__llvm_entry ], [ %mask.1, %iter ]
  %i.0 = phi i64 [ 0, %__llvm_entry ], [ %output57, %iter ]
  %return6 = call i64 @"lt@III"(i64 %i.0, i64 %return)
  %0 = icmp ne i64 %return6, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %return9 = call i64 @"getcomp@I[II"(i64* %mask.0, i64 %i.0)
  %return10 = call i64 @"gt@III"(i64 %return9, i64 0)
  %1 = icmp ne i64 %return10, 0
  br i1 %1, label %iter, label %end11

end:                                              ; preds = %cond
  %return59 = call i64 @"max@I[I"(i64* %mask.0)
  store i64 %return59, i64* %times
  %arr60 = load i64** %arr
  %return63 = call i64 @"find@I[II"(i64* %mask.0, i64 %return59)
  %return64 = call i64 @"getcomp@I[II"(i64* %arr60, i64 %return63)
  ret i64 %return64

iter:                                             ; preds = %cond18, %body
  %mask.1 = phi i64* [ %mask.0, %body ], [ %mask.2, %cond18 ]
  %output57 = add i64 %i.0, 1
  br label %cond

end11:                                            ; preds = %body
  %return13 = call { i64, i64* } @"setcomp@I[III"(i64* %mask.0, i64 1, i64 %i.0)
  %output15 = extractvalue { i64, i64* } %return13, 1
  %output17 = add i64 %i.0, 1
  br label %cond18

cond18:                                           ; preds = %iter24, %end11
  %mask.2 = phi i64* [ %output15, %end11 ], [ %mask.3, %iter24 ]
  %j.0 = phi i64 [ %output17, %end11 ], [ %output55, %iter24 ]
  %return22 = call i64 @"lt@III"(i64 %j.0, i64 %return)
  %2 = icmp ne i64 %return22, 0
  br i1 %2, label %body19, label %iter

body19:                                           ; preds = %cond18
  %return27 = call i64 @"getcomp@I[II"(i64* %mask.2, i64 %j.0)
  %return28 = call i64 @"gt@III"(i64 %return27, i64 0)
  %arr29 = load i64** %arr
  %return31 = call i64 @"getcomp@I[II"(i64* %arr29, i64 %i.0)
  %return34 = call i64 @"getcomp@I[II"(i64* %arr29, i64 %j.0)
  %output35 = sub i64 %return31, %return34
  %return36 = call i64 @"ne@III"(i64 %output35, i64 0)
  %return37 = call i64 @"or@III"(i64 %return28, i64 %return36)
  %3 = icmp ne i64 %return37, 0
  br i1 %3, label %iter24, label %end39

iter24:                                           ; preds = %body19, %end39
  %mask.3 = phi i64* [ %mask.2, %body19 ], [ %output53, %end39 ]
  %output55 = add i64 %j.0, 1
  br label %cond18

end39:                                            ; preds = %body19
  %return42 = call { i64, i64* } @"setcomp@I[III"(i64* %mask.2, i64 1, i64 %j.0)
  %output44 = extractvalue { i64, i64* } %return42, 1
  %return48 = call i64 @"getcomp@I[II"(i64* %output44, i64 %i.0)
  %output49 = add i64 %return48, 1
  %return51 = call { i64, i64* } @"setcomp@I[III"(i64* %output44, i64 %output49, i64 %i.0)
  %output53 = extractvalue { i64, i64* } %return51, 1
  br label %iter24
}

declare i64 @"or@III"(i64, i64) nounwind readnone

declare i64 @"max@I[I"(i64*) nounwind

declare i64 @"find@I[II"(i64*, i64) nounwind

define private i64 @"ingroup@IIISI"(i64* %geo, i64* %elemclass, i8** %groupname, i64* %elemnum) nounwind alwaysinline {
__llvm_entry:
  %elemclass1 = load i64* %elemclass
  %return = call i64 @"eq@III"(i64 %elemclass1, i64 0)
  %0 = icmp ne i64 %return, 0
  br i1 %0, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %geo2 = load i64* %geo
  %groupname3 = load i8** %groupname
  %elemnum4 = load i64* %elemnum
  %return5 = call i64 @"inprimgroup@IISI"(i64 %geo2, i8* %groupname3, i64 %elemnum4)
  br label %UnifiedReturnBlock

false:                                            ; preds = %__llvm_entry
  %return7 = call i64 @"eq@III"(i64 %elemclass1, i64 1)
  %1 = icmp ne i64 %return7, 0
  br i1 %1, label %true8, label %false9

true8:                                            ; preds = %false
  %geo11 = load i64* %geo
  %groupname12 = load i8** %groupname
  %elemnum13 = load i64* %elemnum
  %return14 = call i64 @"inpointgroup@IISI"(i64 %geo11, i8* %groupname12, i64 %elemnum13)
  br label %UnifiedReturnBlock

false9:                                           ; preds = %false
  %return16 = call i64 @"eq@III"(i64 %elemclass1, i64 2)
  %2 = icmp ne i64 %return16, 0
  br i1 %2, label %true17, label %false18

true17:                                           ; preds = %false9
  %geo20 = load i64* %geo
  %groupname21 = load i8** %groupname
  %elemnum22 = load i64* %elemnum
  %return23 = call i64 @"invertexgroup@IISI"(i64 %geo20, i8* %groupname21, i64 %elemnum22)
  br label %UnifiedReturnBlock

false18:                                          ; preds = %false9
  call void @"error@S"(i8* getelementptr inbounds ([37 x i8]* @1, i64 0, i64 0))
  %return24 = call i64 @"neg@II"(i64 1)
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %false18, %true17, %true8, %true
  %UnifiedRetVal = phi i64 [ %return5, %true ], [ %return14, %true8 ], [ %return23, %true17 ], [ %return24, %false18 ]
  ret i64 %UnifiedRetVal
}

declare i64 @"inprimgroup@IISI"(i64, i8*, i64) nounwind

declare i64 @"inpointgroup@IISI"(i64, i8*, i64) nounwind

declare i64 @"invertexgroup@IISI"(i64, i8*, i64) nounwind

declare void @"error@S"(i8*) nounwind

declare i8* @"chs@SS"(i8*) nounwind readnone

declare i8** @"split@[SS"(i8*) nounwind readnone

declare i64 @"chi@IS"(i8*) nounwind readnone

declare i64* @"primpoints@[III"(i64, i64) nounwind

declare i64* @"primvertices@[III"(i64, i64) nounwind

declare i64* @"neighbours@[III"(i64, i64) nounwind

declare i64* @"pointvertices@[III"(i64, i64) nounwind

declare i64 @"hedge_srcpoint@III"(i64, i64) nounwind

declare i64 @"hedge_dstpoint@III"(i64, i64) nounwind

declare i64* @"array@[I:II"(i64, i64) nounwind readnone

declare i64 @"attrib@IISSI"(i64, i8*, i8*, i64) nounwind

declare i64 @"ge@III"(i64, i64) nounwind readnone

declare i64 @"len@I[S"(i8**) nounwind readnone

declare i8* @"getcomp@S[SI"(i8**, i64) nounwind readnone

declare i64 @"not@II"(i64) nounwind readnone

declare i64 @"setedgegroup@IISIII"(i64, i8*, i64, i64, i64) nounwind

declare i64* @"array@[I:I"(i64) nounwind readnone

declare i64 @"vertexprim@III"(i64, i64) nounwind

declare i64 @"vertexhedge@III"(i64, i64) nounwind

define void @obj_geo1_polyexpand_fee1_grouppromote_fee1_attribwrangle1_attribvop1(i64 %elemnum) nounwind {
__llvm_entry:
  %0 = alloca i64
  store i64 %elemnum, i64* %0
  call void @"_obj_geo1_polyexpand_fee1_grouppromote_fee1_attribwrangle1_attribvop1_snippet1@I"(i64* %0)
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([8 x i8]* @14, i64 0, i64 0), i64 %elemnum) nounwind readonly
  store i64 %gvalue, i64* @elemnum
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @obj_geo1_polyexpand_fee1_grouppromote_fee1_attribwrangle1_attribvop1(i64 0)
  ret void
}

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = metadata !{metadata !"cvex"}
!1 = metadata !{metadata !"18.5.633"}
!2 = metadata !{metadata !"64"}
!3 = metadata !{metadata !""}

;_code_end
