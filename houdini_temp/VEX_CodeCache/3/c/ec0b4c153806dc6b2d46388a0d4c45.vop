;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [2 x i8] c"P\00"
@1 = private constant [0 x i64] zeroinitializer
@2 = private constant [7 x i8] c"typeid\00"
@3 = private constant [7 x i8] c"closed\00"
@4 = private constant [11 x i8] c"opinput:%d\00"
@5 = private constant [9 x i8] c"polyline\00"
@6 = private constant [11 x i8] c"restlength\00"
@7 = private constant [11 x i8] c"restvector\00"
@8 = private constant [5 x i8] c"type\00"
@9 = private constant [7 x i8] c"ptprim\00"
@10 = private constant [7 x i8] c"stitch\00"
@11 = private constant [13 x i8] c"useclosestpt\00"
@12 = private constant [15 x i8] c"useclosestprim\00"
@13 = private constant [11 x i8] c"usemaxdist\00"
@14 = private constant [8 x i8] c"maxdist\00"
@15 = private constant [12 x i8] c"__targetsrc\00"
@16 = private constant [21 x i8] c"__stretchconstraints\00"
@ptnum = external global i64
@__srcidx = external global i64
@17 = private constant [6 x i8] c"ptnum\00"
@18 = private constant [9 x i8] c"__srcidx\00"

; Function Attrs: alwaysinline nounwind
define private double @"computeDistanceRestLength@FIII"(i64* %geo, i64* %p0, i64* %p1) #0 {
__llvm_entry:
  %geo1 = load i64, i64* %geo
  %p02 = load i64, i64* %p0
  %return = call <3 x double> @"point@VISI"(i64 %geo1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %p02)
  %geo3 = load i64, i64* %geo
  %p14 = load i64, i64* %p1
  %return5 = call <3 x double> @"point@VISI"(i64 %geo3, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %p14)
  %return6 = call double @"distance@FVV"(<3 x double> %return, <3 x double> %return5)
  ret double %return6
}

; Function Attrs: nounwind
declare <3 x double> @"point@VISI"(i64, i8*, i64) #1

; Function Attrs: nounwind
declare double @"distance@FVV"(<3 x double>, <3 x double>) #1

; Function Attrs: alwaysinline nounwind
define private <3 x double> @"pointPrimTargetPos@VI[IFF"(i64* %geo, i64** %pts, double* %u, double* %v) #0 {
__llvm_entry:
  %geo1 = load i64, i64* %geo
  %pts2 = load i64*, i64** %pts
  %return = call i64 @"getcomp@I[II"(i64* %pts2, i64 0)
  %return3 = call <3 x double> @"point@VISI"(i64 %geo1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %return)
  %geo4 = load i64, i64* %geo
  %pts5 = load i64*, i64** %pts
  %return6 = call i64 @"getcomp@I[II"(i64* %pts5, i64 1)
  %return7 = call <3 x double> @"point@VISI"(i64 %geo4, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %return6)
  %pts8 = load i64*, i64** %pts
  %return9 = call i64 @"len@I[I"(i64* %pts8)
  %return11 = call i64 @"eq@III"(i64 %return9, i64 2)
  %0 = icmp ne i64 %return11, 0
  br i1 %0, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %u12 = load double, double* %u
  %output = fsub double 1.000000e+00, %u12
  %cast = call <3 x double> @"set@VF"(double %output)
  %output16 = call <3 x double> @"mul@VV"(<3 x double> %cast, <3 x double> %return3)
  %cast19 = call <3 x double> @"set@VF"(double %u12)
  %output20 = call <3 x double> @"mul@VV"(<3 x double> %cast19, <3 x double> %return7)
  %output21 = call <3 x double> @"add@VV"(<3 x double> %output16, <3 x double> %output20)
  br label %UnifiedReturnBlock

false:                                            ; preds = %__llvm_entry
  %return23 = call i64 @"eq@III"(i64 %return9, i64 3)
  %1 = icmp ne i64 %return23, 0
  br i1 %1, label %true24, label %false25

true24:                                           ; preds = %false
  %geo27 = load i64, i64* %geo
  %return29 = call i64 @"getcomp@I[II"(i64* %pts8, i64 2)
  %return30 = call <3 x double> @"point@VISI"(i64 %geo27, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %return29)
  %u32 = load double, double* %u
  %output33 = fsub double 1.000000e+00, %u32
  %v34 = load double, double* %v
  %output35 = fsub double %output33, %v34
  %cast41 = call <3 x double> @"set@VF"(double %output35)
  %output42 = call <3 x double> @"mul@VV"(<3 x double> %cast41, <3 x double> %return3)
  %cast45 = call <3 x double> @"set@VF"(double %u32)
  %output46 = call <3 x double> @"mul@VV"(<3 x double> %cast45, <3 x double> %return7)
  %output47 = call <3 x double> @"add@VV"(<3 x double> %output42, <3 x double> %output46)
  %cast50 = call <3 x double> @"set@VF"(double %v34)
  %output51 = call <3 x double> @"mul@VV"(<3 x double> %cast50, <3 x double> %return30)
  %output52 = call <3 x double> @"add@VV"(<3 x double> %output47, <3 x double> %output51)
  br label %UnifiedReturnBlock

false25:                                          ; preds = %false
  %return54 = call i64 @"eq@III"(i64 %return9, i64 4)
  %2 = icmp ne i64 %return54, 0
  br i1 %2, label %true55, label %end56

true55:                                           ; preds = %false25
  %geo58 = load i64, i64* %geo
  %return60 = call i64 @"getcomp@I[II"(i64* %pts8, i64 2)
  %return61 = call <3 x double> @"point@VISI"(i64 %geo58, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %return60)
  %geo62 = load i64, i64* %geo
  %pts63 = load i64*, i64** %pts
  %return64 = call i64 @"getcomp@I[II"(i64* %pts63, i64 3)
  %return65 = call <3 x double> @"point@VISI"(i64 %geo62, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %return64)
  %u66 = load double, double* %u
  %output67 = fsub double 1.000000e+00, %u66
  %v68 = load double, double* %v
  %output69 = fsub double 1.000000e+00, %v68
  %output73 = fmul double %output67, %output69
  %output77 = fmul double %output67, %v68
  %output81 = fmul double %u66, %v68
  %output84 = fmul double %u66, %output69
  %cast87 = call <3 x double> @"set@VF"(double %output73)
  %output88 = call <3 x double> @"mul@VV"(<3 x double> %cast87, <3 x double> %return3)
  %cast91 = call <3 x double> @"set@VF"(double %output77)
  %output92 = call <3 x double> @"mul@VV"(<3 x double> %cast91, <3 x double> %return7)
  %output93 = call <3 x double> @"add@VV"(<3 x double> %output88, <3 x double> %output92)
  %cast96 = call <3 x double> @"set@VF"(double %output81)
  %output97 = call <3 x double> @"mul@VV"(<3 x double> %cast96, <3 x double> %return61)
  %output98 = call <3 x double> @"add@VV"(<3 x double> %output93, <3 x double> %output97)
  %cast101 = call <3 x double> @"set@VF"(double %output84)
  %output102 = call <3 x double> @"mul@VV"(<3 x double> %cast101, <3 x double> %return65)
  %output103 = call <3 x double> @"add@VV"(<3 x double> %output98, <3 x double> %output102)
  br label %UnifiedReturnBlock

end56:                                            ; preds = %false25
  %cast104 = call <3 x double> @"set@VI"(i64 0)
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end56, %true55, %true24, %true
  %UnifiedRetVal = phi <3 x double> [ %output21, %true ], [ %output52, %true24 ], [ %output103, %true55 ], [ %cast104, %end56 ]
  ret <3 x double> %UnifiedRetVal
}

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #2

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VF"(double) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"mul@VV"(<3 x double>, <3 x double>) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"add@VV"(<3 x double>, <3 x double>) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VI"(i64) #2

; Function Attrs: alwaysinline nounwind
define private double @"computePointPrimRestLength@FII[IP"(i64* %geo, i64* %pt, i64** %tgtpts, <4 x double>* %restvector) #0 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64*
  %2 = alloca double
  %3 = alloca double
  %tgtpts1 = load i64*, i64** %tgtpts
  %return = call i64 @"len@I[I"(i64* %tgtpts1)
  %return3 = call i64 @"lt@III"(i64 %return, i64 2)
  %return5 = call i64 @"gt@III"(i64 %return, i64 4)
  %return6 = call i64 @"or@III"(i64 %return3, i64 %return5)
  %4 = icmp ne i64 %return6, 0
  br i1 %4, label %true, label %end

true:                                             ; preds = %__llvm_entry
  br label %UnifiedReturnBlock

end:                                              ; preds = %__llvm_entry
  %geo7 = load i64, i64* %geo
  %pt8 = load i64, i64* %pt
  %return9 = call <3 x double> @"point@VISI"(i64 %geo7, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %pt8)
  %geo10 = load i64, i64* %geo
  store i64 %geo10, i64* %0
  %tgtpts11 = load i64*, i64** %tgtpts
  store i64* %tgtpts11, i64** %1
  %restvector12 = load <4 x double>, <4 x double>* %restvector
  %return13 = call double @"getcomp@FPI"(<4 x double> %restvector12, i64 0)
  store double %return13, double* %2
  %restvector14 = load <4 x double>, <4 x double>* %restvector
  %return15 = call double @"getcomp@FPI"(<4 x double> %restvector14, i64 1)
  store double %return15, double* %3
  %pointPrimTargetPos = call <3 x double> @"pointPrimTargetPos@VI[IFF"(i64* %0, i64** %1, double* %2, double* %3)
  %return18 = call double @"distance@FVV"(<3 x double> %return9, <3 x double> %pointPrimTargetPos)
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end, %true
  %UnifiedRetVal = phi double [ 0.000000e+00, %true ], [ %return18, %end ]
  ret double %UnifiedRetVal
}

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"gt@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare double @"getcomp@FPI"(<4 x double>, i64) #2

; Function Attrs: alwaysinline nounwind
define private void @"remapPolyLineUVs@SI[IV"(i8** %geo, i64* %targetprim, i64** %targetpts, <3 x double>* %targetuv) #0 {
__llvm_entry:
  %targetuv1 = load <3 x double>, <3 x double>* %targetuv
  %return = call double @"getcomp@FVI"(<3 x double> %targetuv1, i64 0)
  %return2 = call <2 x double> @"set@UFF"(double %return, double 0.000000e+00)
  %geo3 = load i8*, i8** %geo
  %targetprim5 = load i64, i64* %targetprim
  %return6 = call <2 x double> @"primuvconvert@USUII"(i8* %geo3, <2 x double> %return2, i64 %targetprim5, i64 3)
  %return8 = call double @"getcomp@FUI"(<2 x double> %return6, i64 0)
  %return9 = call i64 @"floor@IF"(double %return8)
  %targetpts11 = load i64*, i64** %targetpts
  %return12 = call i64 @"len@I[I"(i64* %targetpts11)
  %output = sub i64 %return12, 1
  %return13 = call i64 @"ge@III"(i64 %return9, i64 %output)
  %0 = icmp ne i64 %return13, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %output15 = sub i64 %return9, 1
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %pt0.0 = phi i64 [ %output15, %true ], [ %return9, %__llvm_entry ]
  %cast = sitofp i64 %pt0.0 to double
  %output19 = fsub double %return8, %cast
  %return20 = call { double, <2 x double> } @"setcomp@FUFI"(<2 x double> %return6, double %output19, i64 0)
  %output22 = extractvalue { double, <2 x double> } %return20, 1
  %targetpts23 = load i64*, i64** %targetpts
  %return25 = call i64 @"getcomp@I[II"(i64* %targetpts23, i64 %pt0.0)
  %output28 = add i64 %pt0.0, 1
  %return29 = call i64 @"getcomp@I[II"(i64* %targetpts23, i64 %output28)
  %return30 = call i64* @"array@[I:II"(i64 %return25, i64 %return29)
  store i64* %return30, i64** %targetpts
  %return32 = call double @"getcomp@FUI"(<2 x double> %output22, i64 0)
  %return33 = call <3 x double> @"set@VFFF"(double %return32, double 0.000000e+00, double 0.000000e+00)
  store <3 x double> %return33, <3 x double>* %targetuv
  ret void
}

; Function Attrs: nounwind readnone
declare double @"getcomp@FVI"(<3 x double>, i64) #2

; Function Attrs: nounwind readnone
declare <2 x double> @"set@UFF"(double, double) #2

; Function Attrs: nounwind readnone
declare <2 x double> @"primuvconvert@USUII"(i8*, <2 x double>, i64, i64) #2

; Function Attrs: nounwind readnone
declare double @"getcomp@FUI"(<2 x double>, i64) #2

; Function Attrs: nounwind
declare i64 @"floor@IF"(double) #1

; Function Attrs: nounwind readnone
declare i64 @"ge@III"(i64, i64) #2

; Function Attrs: alwaysinline
define private { double, <2 x double> } @"setcomp@FUFI"(<2 x double> %rw11, double %rw22, i64 %rw33) #3 {
__llvm_entry:
  %rw16 = call <2 x double> @"setcomp@UFI"(<2 x double> %rw11, double %rw22, i64 0)
  %mrv = insertvalue { double, <2 x double> } undef, double %rw22, 0
  %mrv9 = insertvalue { double, <2 x double> } %mrv, <2 x double> %rw16, 1
  ret { double, <2 x double> } %mrv9
}

; Function Attrs: nounwind readnone
declare <2 x double> @"setcomp@UFI"(<2 x double>, double, i64) #2

; Function Attrs: nounwind readnone
declare i64* @"array@[I:II"(i64, i64) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VFFF"(double, double, double) #2

; Function Attrs: alwaysinline nounwind
define private void @"createStitchConstraint@IIISIIIFIS"(i64* %geo, i64* %ptnum, i64* %srcidx, i8** %targetgrp, i64* %useclosestpt, i64* %useclosestprim, i64* %maxdistcheck, double* %maxdist, i64* %outgeo, i8** %outgrp) #0 {
__llvm_entry:
  %targetuv = alloca <3 x double>
  %tgtpts = alloca i64*
  %0 = alloca i8*
  %1 = alloca i64
  %2 = alloca i64
  %3 = alloca i64
  %4 = alloca i64*
  %5 = alloca <4 x double>
  %6 = alloca i64
  %7 = alloca i64
  %8 = alloca i64
  %return = call i64 @"neg@II"(i64 1)
  store <3 x double> zeroinitializer, <3 x double>* %targetuv, !vex-initializer-store !3
  store i64* getelementptr inbounds ([0 x i64], [0 x i64]* @1, i64 0, i64 0), i64** %tgtpts, !vex-initializer-store !3
  %geo2 = load i64, i64* %geo
  %ptnum3 = load i64, i64* %ptnum
  %return4 = call <3 x double> @"point@VISI"(i64 %geo2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @0, i64 0, i64 0), i64 %ptnum3)
  %useclosestpt5 = load i64, i64* %useclosestpt
  %9 = icmp ne i64 %useclosestpt5, 0
  br i1 %9, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %useclosestprim6 = load i64, i64* %useclosestprim
  %10 = icmp ne i64 %useclosestprim6, 0
  %maxdistcheck10 = load i64, i64* %maxdistcheck
  %11 = icmp ne i64 %maxdistcheck10, 0
  %geo14 = load i64, i64* %geo
  %targetgrp15 = load i8*, i8** %targetgrp
  br i1 %10, label %true7, label %false8

false:                                            ; preds = %__llvm_entry
  %geo72 = load i64, i64* %geo
  %targetgrp73 = load i8*, i8** %targetgrp
  %return74 = call i64* @"expandpointgroup@[IIS"(i64 %geo72, i8* %targetgrp73)
  store i64* %return74, i64** %tgtpts
  %srcidx75 = load i64, i64* %srcidx
  %return77 = call i64 @"len@I[I"(i64* %return74)
  %return78 = call i64 @"lt@III"(i64 %srcidx75, i64 %return77)
  %12 = icmp ne i64 %return78, 0
  br i1 %12, label %true79, label %end

end:                                              ; preds = %false, %true79, %true60, %false61, %end46
  %targetpt.0 = phi i64 [ %return, %end46 ], [ %return67, %true60 ], [ %return71, %false61 ], [ %return83, %true79 ], [ %return, %false ]
  %targetprim.0 = phi i64 [ %targetprim.1, %end46 ], [ %return, %true60 ], [ %return, %false61 ], [ %return, %true79 ], [ %return, %false ]
  %return85 = call i64 @"lt@III"(i64 %targetprim.0, i64 0)
  %return87 = call i64 @"lt@III"(i64 %targetpt.0, i64 0)
  %return88 = call i64 @"and@III"(i64 %return85, i64 %return87)
  %13 = icmp ne i64 %return88, 0
  br i1 %13, label %true30, label %end90

true7:                                            ; preds = %true
  br i1 %11, label %true11, label %false12

false8:                                           ; preds = %true
  br i1 %11, label %true60, label %false61

true11:                                           ; preds = %true7
  %maxdist17 = load double, double* %maxdist
  %return18 = call { double, i64, <3 x double> } @"xyzdist@FISVIVF"(i64 %geo14, i8* %targetgrp15, <3 x double> %return4, double %maxdist17)
  %output = extractvalue { double, i64, <3 x double> } %return18, 1
  %output20 = extractvalue { double, i64, <3 x double> } %return18, 2
  store <3 x double> %output20, <3 x double>* %targetuv
  br label %end13

false12:                                          ; preds = %true7
  %return24 = call { double, i64, <3 x double> } @"xyzdist@FISVIV"(i64 %geo14, i8* %targetgrp15, <3 x double> %return4)
  %output26 = extractvalue { double, i64, <3 x double> } %return24, 1
  %output27 = extractvalue { double, i64, <3 x double> } %return24, 2
  store <3 x double> %output27, <3 x double>* %targetuv
  br label %end13

end13:                                            ; preds = %false12, %true11
  %targetprim.1 = phi i64 [ %output, %true11 ], [ %output26, %false12 ]
  %return29 = call i64 @"lt@III"(i64 %targetprim.1, i64 0)
  %14 = icmp ne i64 %return29, 0
  br i1 %14, label %true30, label %end31

true30:                                           ; preds = %end, %end46, %end31, %end13
  br label %UnifiedReturnBlock

end31:                                            ; preds = %end13
  %geo32 = load i64, i64* %geo
  %return34 = call i64 @"primintrinsic@IISI"(i64 %geo32, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @2, i64 0, i64 0), i64 %targetprim.1)
  %return35 = call i64 @"ne@III"(i64 %return34, i64 1)
  %15 = icmp ne i64 %return35, 0
  br i1 %15, label %true30, label %end37

end37:                                            ; preds = %end31
  %geo38 = load i64, i64* %geo
  %return40 = call i64* @"primpoints@[III"(i64 %geo38, i64 %targetprim.1)
  store i64* %return40, i64** %tgtpts
  %geo41 = load i64, i64* %geo
  %return43 = call i64 @"primintrinsic@IISI"(i64 %geo41, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @3, i64 0, i64 0), i64 %targetprim.1)
  %return44 = call i64 @"not@II"(i64 %return43)
  %16 = icmp ne i64 %return44, 0
  br i1 %16, label %true45, label %end46

true45:                                           ; preds = %end37
  %geo47 = load i64, i64* %geo
  %return48 = call i8* @"sprintf@SS:I"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @4, i64 0, i64 0), i64 %geo47)
  store i8* %return48, i8** %0
  store i64 %targetprim.1, i64* %1
  call void @"remapPolyLineUVs@SI[IV"(i8** %0, i64* %1, i64** %tgtpts, <3 x double>* %targetuv)
  br label %end46

end46:                                            ; preds = %true45, %end37
  %tgtpts50 = load i64*, i64** %tgtpts
  %return51 = call i64 @"len@I[I"(i64* %tgtpts50)
  %return53 = call i64 @"lt@III"(i64 %return51, i64 2)
  %return55 = call i64 @"gt@III"(i64 %return51, i64 4)
  %return56 = call i64 @"or@III"(i64 %return53, i64 %return55)
  %17 = icmp ne i64 %return56, 0
  br i1 %17, label %true30, label %end

true60:                                           ; preds = %false8
  %maxdist66 = load double, double* %maxdist
  %return67 = call i64 @"nearpoint@IISVF"(i64 %geo14, i8* %targetgrp15, <3 x double> %return4, double %maxdist66)
  br label %end

false61:                                          ; preds = %false8
  %return71 = call i64 @"nearpoint@IISV"(i64 %geo14, i8* %targetgrp15, <3 x double> %return4)
  br label %end

true79:                                           ; preds = %false
  %return83 = call i64 @"getcomp@I[II"(i64* %return74, i64 %srcidx75)
  br label %end

end90:                                            ; preds = %end
  %return93 = call i64 @"ge@III"(i64 %targetprim.0, i64 0)
  %18 = icmp ne i64 %return93, 0
  br i1 %18, label %true94, label %false95

true94:                                           ; preds = %end90
  %ptnum98 = load i64, i64* %ptnum
  %output99 = call i64* @"append@[II"(i64* getelementptr inbounds ([0 x i64], [0 x i64]* @1, i64 0, i64 0), i64 %ptnum98)
  %tgtpts101 = load i64*, i64** %tgtpts
  %output102 = call i64* @"append@[I[I"(i64* %output99, i64* %tgtpts101)
  %targetuv103 = load <3 x double>, <3 x double>* %targetuv
  %return104 = call double @"getcomp@FVI"(<3 x double> %targetuv103, i64 0)
  %return106 = call double @"getcomp@FVI"(<3 x double> %targetuv103, i64 1)
  %return107 = call <4 x double> @"set@PFFFF"(double %return104, double %return106, double 0.000000e+00, double 0.000000e+00)
  %outgeo108 = load i64, i64* %outgeo
  %return110 = call i64 @"addprim@IIS[I"(i64 %outgeo108, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @5, i64 0, i64 0), i64* %output102)
  %geo111 = load i64, i64* %geo
  store i64 %geo111, i64* %2
  %ptnum112 = load i64, i64* %ptnum
  store i64 %ptnum112, i64* %3
  %tgtpts113 = load i64*, i64** %tgtpts
  store i64* %tgtpts113, i64** %4
  store <4 x double> %return107, <4 x double>* %5
  %computePointPrimRestLength = call double @"computePointPrimRestLength@FII[IP"(i64* %2, i64* %3, i64** %4, <4 x double>* %5)
  %outgeo115 = load i64, i64* %outgeo
  %return118 = call i64 @"setprimattrib@IISIF"(i64 %outgeo115, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @6, i64 0, i64 0), i64 %return110, double %computePointPrimRestLength)
  %outgeo119 = load i64, i64* %outgeo
  %return122 = call i64 @"setprimattrib@IISIP"(i64 %outgeo119, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @7, i64 0, i64 0), i64 %return110, <4 x double> %return107)
  %outgeo123 = load i64, i64* %outgeo
  %return125 = call i64 @"setprimattrib@IISIS"(i64 %outgeo123, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @8, i64 0, i64 0), i64 %return110, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @9, i64 0, i64 0))
  br label %end96

false95:                                          ; preds = %end90
  %return127 = call i64 @"ge@III"(i64 %targetpt.0, i64 0)
  %19 = icmp ne i64 %return127, 0
  br i1 %19, label %true128, label %end96

end96:                                            ; preds = %false95, %true128, %true94
  %prim.0 = phi i64 [ %return110, %true94 ], [ %return134, %true128 ], [ %return, %false95 ]
  %outgeo144 = load i64, i64* %outgeo
  %outgrp145 = load i8*, i8** %outgrp
  %return147 = call i64 @"setprimgroup@IISII"(i64 %outgeo144, i8* %outgrp145, i64 %prim.0, i64 1)
  br label %UnifiedReturnBlock

true128:                                          ; preds = %false95
  %outgeo130 = load i64, i64* %outgeo
  %ptnum131 = load i64, i64* %ptnum
  %return133 = call i64* @"array@[I:II"(i64 %ptnum131, i64 %targetpt.0)
  %return134 = call i64 @"addprim@IIS[I"(i64 %outgeo130, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @5, i64 0, i64 0), i64* %return133)
  %outgeo135 = load i64, i64* %outgeo
  %geo137 = load i64, i64* %geo
  store i64 %geo137, i64* %6
  %ptnum138 = load i64, i64* %ptnum
  store i64 %ptnum138, i64* %7
  store i64 %targetpt.0, i64* %8
  %computeDistanceRestLength = call double @"computeDistanceRestLength@FIII"(i64* %6, i64* %7, i64* %8)
  %return140 = call i64 @"setprimattrib@IISIF"(i64 %outgeo135, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @6, i64 0, i64 0), i64 %return134, double %computeDistanceRestLength)
  %outgeo141 = load i64, i64* %outgeo
  %return143 = call i64 @"setprimattrib@IISIS"(i64 %outgeo141, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @8, i64 0, i64 0), i64 %return134, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @10, i64 0, i64 0))
  br label %end96

UnifiedReturnBlock:                               ; preds = %end96, %true30
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"neg@II"(i64) #2

; Function Attrs: nounwind
declare { double, i64, <3 x double> } @"xyzdist@FISVIVF"(i64, i8*, <3 x double>, double) #1

; Function Attrs: nounwind
declare { double, i64, <3 x double> } @"xyzdist@FISVIV"(i64, i8*, <3 x double>) #1

; Function Attrs: nounwind
declare i64 @"primintrinsic@IISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"ne@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64* @"primpoints@[III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #2

; Function Attrs: nounwind readnone
declare i8* @"sprintf@SS:I"(i8*, i64) #2

; Function Attrs: nounwind
declare i64 @"nearpoint@IISVF"(i64, i8*, <3 x double>, double) #1

; Function Attrs: nounwind
declare i64 @"nearpoint@IISV"(i64, i8*, <3 x double>) #1

; Function Attrs: nounwind
declare i64* @"expandpointgroup@[IIS"(i64, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64* @"append@[II"(i64*, i64) #1

; Function Attrs: nounwind
declare i64* @"append@[I[I"(i64*, i64*) #1

; Function Attrs: nounwind readnone
declare <4 x double> @"set@PFFFF"(double, double, double, double) #2

; Function Attrs: nounwind
declare i64 @"addprim@IIS[I"(i64, i8*, i64*) #1

; Function Attrs: nounwind
declare i64 @"setprimattrib@IISIF"(i64, i8*, i64, double) #1

; Function Attrs: nounwind
declare i64 @"setprimattrib@IISIP"(i64, i8*, i64, <4 x double>) #1

; Function Attrs: nounwind
declare i64 @"setprimattrib@IISIS"(i64, i8*, i64, i8*) #1

; Function Attrs: nounwind
declare i64 @"setprimgroup@IISII"(i64, i8*, i64, i64) #1

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@II"(i64* %_bound_ptnum, i64* %_bound___srcidx) #0 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64
  %2 = alloca i64
  %3 = alloca i8*
  %4 = alloca i64
  %5 = alloca i64
  %6 = alloca i64
  %7 = alloca double
  %8 = alloca i64
  %9 = alloca i8*
  %return = call i64 @"chi@IS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @11, i64 0, i64 0))
  %return1 = call i64 @"chi@IS"(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @12, i64 0, i64 0))
  %return2 = call i64 @"chi@IS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @13, i64 0, i64 0))
  %return3 = call double @"chf@FS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @14, i64 0, i64 0))
  store i64 1, i64* %0
  %_bound_ptnum4 = load i64, i64* %_bound_ptnum
  store i64 %_bound_ptnum4, i64* %1
  %_bound___srcidx5 = load i64, i64* %_bound___srcidx
  store i64 %_bound___srcidx5, i64* %2
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @15, i64 0, i64 0), i8** %3
  store i64 %return, i64* %4
  store i64 %return1, i64* %5
  store i64 %return2, i64* %6
  store double %return3, double* %7
  %return10 = call i64 @"geoself@I"()
  store i64 %return10, i64* %8
  store i8* getelementptr inbounds ([21 x i8], [21 x i8]* @16, i64 0, i64 0), i8** %9
  call void @"createStitchConstraint@IIISIIIFIS"(i64* %0, i64* %1, i64* %2, i8** %3, i64* %4, i64* %5, i64* %6, double* %7, i64* %8, i8** %9)
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #2

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #2

; Function Attrs: nounwind
declare i64 @"geoself@I"() #1

; Function Attrs: nounwind
define void @__vex_snippet(i64 %ptnum, i64 %__srcidx) #1 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64
  store i64 %ptnum, i64* %0
  store i64 %__srcidx, i64* %1
  call void @"__vex_snippet_snippet@II"(i64* %0, i64* %1)
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @17, i64 0, i64 0), i64 %ptnum) #4
  %gvalue4 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @18, i64 0, i64 0), i64 %__srcidx) #4
  store i64 %gvalue, i64* @ptnum
  store i64 %gvalue4, i64* @__srcidx
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0, i64 0)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind }
attributes #2 = { nounwind readnone }
attributes #3 = { alwaysinline }
attributes #4 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}
!3 = !{!""}

;_code_end
