;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [11 x i8] c"branchweld\00"
@1 = private constant [5 x i8] c"type\00"
@2 = private constant [10 x i8] c"bendtwist\00"

; Function Attrs: alwaysinline nounwind
define private i64 @"findBranchBendPoints@IIIIII"(i64* %geo, i64* %ptnum, i64* %weld, i64* %pt0, i64* %pt1) #0 {
__llvm_entry:
  %geo1 = load i64, i64* %geo
  %weld2 = load i64, i64* %weld
  %return = call i64* @"neighbours@[III"(i64 %geo1, i64 %weld2)
  %return4 = call i64 @"len@I[I"(i64* %return)
  br label %cond

cond:                                             ; preds = %end16, %__llvm_entry
  %__impl_foreach_index_21f.0 = phi i64 [ 0, %__llvm_entry ], [ %output, %end16 ]
  %return7 = call i64 @"lt@III"(i64 %__impl_foreach_index_21f.0, i64 %return4)
  %0 = icmp ne i64 %return7, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %return10 = call i64 @"getcomp@I[II"(i64* %return, i64 %__impl_foreach_index_21f.0)
  %geo11 = load i64, i64* %geo
  %weld13 = load i64, i64* %weld
  %return14 = call i64 @"pointhedge@IIII"(i64 %geo11, i64 %return10, i64 %weld13)
  %return15 = call i64 @"ge@III"(i64 %return14, i64 0)
  %1 = icmp ne i64 %return15, 0
  br i1 %1, label %true, label %end16

end:                                              ; preds = %cond
  %return22 = call i64 @"eq@III"(i64 %return4, i64 1)
  %2 = icmp ne i64 %return22, 0
  br i1 %2, label %true23, label %end24

true:                                             ; preds = %body
  store i64 %return10, i64* %pt0
  %ptnum18 = load i64, i64* %ptnum
  store i64 %ptnum18, i64* %pt1
  br label %UnifiedReturnBlock

end16:                                            ; preds = %body
  %output = add i64 %__impl_foreach_index_21f.0, 1
  br label %cond

true23:                                           ; preds = %end
  %weld25 = load i64, i64* %weld
  store i64 %weld25, i64* %pt0
  %ptnum26 = load i64, i64* %ptnum
  store i64 %ptnum26, i64* %pt1
  br label %UnifiedReturnBlock

end24:                                            ; preds = %end
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end24, %true23, %true
  %UnifiedRetVal = phi i64 [ 1, %true ], [ 1, %true23 ], [ 0, %end24 ]
  ret i64 %UnifiedRetVal
}

; Function Attrs: nounwind
declare i64* @"neighbours@[III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #2

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #2

; Function Attrs: nounwind
declare i64 @"pointhedge@IIII"(i64, i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"ge@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #2

; Function Attrs: alwaysinline nounwind
define private void @"removeBranchWeldConstraints@IIII"(i64* %congeo, i64* %ptgeo, i64* %primnum, i64* %outgeo) #0 {
__llvm_entry:
  %bendpt0 = alloca i64
  %bendpt1 = alloca i64
  %0 = alloca i64
  %1 = alloca i64
  %2 = alloca i64
  %congeo1 = load i64, i64* %congeo
  %primnum2 = load i64, i64* %primnum
  %return = call i64* @"primpoints@[III"(i64 %congeo1, i64 %primnum2)
  %return4 = call i64 @"getcomp@I[II"(i64* %return, i64 0)
  %return6 = call i64 @"getcomp@I[II"(i64* %return, i64 1)
  %ptgeo7 = load i64, i64* %ptgeo
  %return9 = call i64 @"point@IISI"(i64 %ptgeo7, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @0, i64 0, i64 0), i64 %return6)
  %return11 = call i64 @"ge@III"(i64 %return9, i64 0)
  %3 = icmp ne i64 %return11, 0
  br i1 %3, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %ptgeo12 = load i64, i64* %ptgeo
  %return14 = call i64 @"idtopoint@III"(i64 %ptgeo12, i64 %return9)
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %bw.0 = phi i64 [ %return14, %true ], [ %return9, %__llvm_entry ]
  %return17 = call i64 @"eq@III"(i64 %return4, i64 %bw.0)
  %4 = icmp ne i64 %return17, 0
  br i1 %4, label %true18, label %end19

true18:                                           ; preds = %cond, %end19, %end
  ret void

end19:                                            ; preds = %end
  %outgeo20 = load i64, i64* %outgeo
  %primnum21 = load i64, i64* %primnum
  %return22 = call i64 @"removeprim@IIII"(i64 %outgeo20, i64 %primnum21, i64 0)
  store i64 0, i64* %bendpt0, !vex-initializer-store !3
  store i64 0, i64* %bendpt1, !vex-initializer-store !3
  %ptgeo23 = load i64, i64* %ptgeo
  store i64 %ptgeo23, i64* %0
  store i64 %return6, i64* %1
  store i64 %return4, i64* %2
  %findBranchBendPoints = call i64 @"findBranchBendPoints@IIIIII"(i64* %0, i64* %1, i64* %2, i64* %bendpt0, i64* %bendpt1)
  %return26 = call i64 @"not@II"(i64 %findBranchBendPoints)
  %5 = icmp ne i64 %return26, 0
  br i1 %5, label %true18, label %end28

end28:                                            ; preds = %end19
  %congeo29 = load i64, i64* %congeo
  %return31 = call i64* @"pointprims@[III"(i64 %congeo29, i64 %return6)
  %return33 = call i64 @"len@I[I"(i64* %return31)
  br label %cond

cond:                                             ; preds = %iter, %end28
  %__impl_foreach_index_220.0 = phi i64 [ 0, %end28 ], [ %output, %iter ]
  %return36 = call i64 @"lt@III"(i64 %__impl_foreach_index_220.0, i64 %return33)
  %6 = icmp ne i64 %return36, 0
  br i1 %6, label %body, label %true18

body:                                             ; preds = %cond
  %return40 = call i64 @"getcomp@I[II"(i64* %return31, i64 %__impl_foreach_index_220.0)
  %congeo41 = load i64, i64* %congeo
  %return43 = call i8* @"prim@SISI"(i64 %congeo41, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @1, i64 0, i64 0), i64 %return40)
  %return45 = call i64 @"ne@ISS"(i8* %return43, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @2, i64 0, i64 0))
  %7 = icmp ne i64 %return45, 0
  br i1 %7, label %iter, label %end47

iter:                                             ; preds = %end47, %true60, %body
  %output = add i64 %__impl_foreach_index_220.0, 1
  br label %cond

end47:                                            ; preds = %body
  %congeo48 = load i64, i64* %congeo
  %return50 = call i64* @"primpoints@[III"(i64 %congeo48, i64 %return40)
  %bendpt051 = load i64, i64* %bendpt0
  %return53 = call i64 @"getcomp@I[II"(i64* %return50, i64 0)
  %return54 = call i64 @"eq@III"(i64 %bendpt051, i64 %return53)
  %bendpt155 = load i64, i64* %bendpt1
  %return57 = call i64 @"getcomp@I[II"(i64* %return50, i64 1)
  %return58 = call i64 @"eq@III"(i64 %bendpt155, i64 %return57)
  %return59 = call i64 @"and@III"(i64 %return54, i64 %return58)
  %8 = icmp ne i64 %return59, 0
  br i1 %8, label %true60, label %iter

true60:                                           ; preds = %end47
  %outgeo62 = load i64, i64* %outgeo
  %return64 = call i64 @"removeprim@IIII"(i64 %outgeo62, i64 %return40, i64 0)
  br label %iter
}

; Function Attrs: nounwind
declare i64* @"primpoints@[III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"point@IISI"(i64, i8*, i64) #1

; Function Attrs: nounwind
declare i64 @"idtopoint@III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"removeprim@IIII"(i64, i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #2

; Function Attrs: nounwind
declare i64* @"pointprims@[III"(i64, i64) #1

; Function Attrs: nounwind
declare i8* @"prim@SISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"ne@ISS"(i8*, i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #2

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@I"(i64* %_bound_primnum) #0 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64
  %2 = alloca i64
  %3 = alloca i64
  store i64 0, i64* %3
  store i64 1, i64* %0
  %_bound_primnum1 = load i64, i64* %_bound_primnum
  store i64 %_bound_primnum1, i64* %1
  %return = call i64 @"geoself@I"()
  store i64 %return, i64* %2
  call void @"removeBranchWeldConstraints@IIII"(i64* %3, i64* %0, i64* %1, i64* %2)
  ret void
}

; Function Attrs: nounwind
declare i64 @"geoself@I"() #1

; Function Attrs: nounwind
define void @__vex_snippet(i64 %primnum) #1 {
__llvm_entry:
  %0 = alloca i64
  store i64 %primnum, i64* %0
  call void @"__vex_snippet_snippet@I"(i64* %0)
  ret void
}

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind }
attributes #2 = { nounwind readnone }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}
!3 = !{!""}

;_code_end
