;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [5 x i8] c"init\00"
@1 = private constant [4 x i8] c"set\00"
@2 = private constant [4 x i8] c"add\00"
@3 = private constant [4 x i8] c"sub\00"
@4 = private constant [4 x i8] c"min\00"
@5 = private constant [7 x i8] c"clampa\00"
@6 = private constant [4 x i8] c"max\00"
@7 = private constant [7 x i8] c"clampb\00"
@8 = private constant [5 x i8] c"mult\00"
@9 = private constant [17 x i8] c"separationmethod\00"
@10 = private constant [7 x i8] c"custom\00"
@11 = private constant [12 x i8] c"singlevalue\00"
@12 = private constant [18 x i8] c"enable_unitadjust\00"
@13 = private constant [6 x i8] c"unitd\00"
@14 = private constant [6 x i8] c"unitc\00"
@15 = private constant [6 x i8] c"class\00"
@16 = private constant [7 x i8] c"attrib\00"
@17 = private constant [10 x i8] c"operation\00"
@18 = private constant [8 x i8] c"doblend\00"
@19 = private constant [12 x i8] c"blendweight\00"
@20 = private constant [10 x i8] c"blendmode\00"
@output = external global double
@elemnum = external global i64
@separation = external global double
@blendattrib = external global double
@21 = private constant [7 x i8] c"output\00"
@22 = private constant [8 x i8] c"elemnum\00"
@23 = private constant [11 x i8] c"separation\00"
@24 = private constant [12 x i8] c"blendattrib\00"

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #0

; Function Attrs: nounwind readnone
declare <3 x double> @"spline@VSFV:VVV"(i8*, double, <3 x double>, <3 x double>, <3 x double>, <3 x double>) #0

; Function Attrs: nounwind readnone
declare double @"smooth@FFFF"(double, double, double) #0

; Function Attrs: nounwind
declare <3 x double> @"lerp@VVVF"(<3 x double>, <3 x double>, double) #1

; Function Attrs: nounwind
declare double @"clamp@FFFF"(double, double, double) #1

; Function Attrs: alwaysinline nounwind
define private double @"aa_applyFloatOperation@FFFIS"(double* %original_value, double* %new_value, i64* %has_attrib, i8** %operation) #2 {
__llvm_entry:
  %operation1 = load i8*, i8** %operation
  %return = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @0, i64 0, i64 0))
  %0 = icmp ne i64 %return, 0
  br i1 %0, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %has_attrib2 = load i64, i64* %has_attrib
  %1 = icmp ne i64 %has_attrib2, 0
  br i1 %1, label %true3, label %false4

false:                                            ; preds = %__llvm_entry
  %return9 = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @1, i64 0, i64 0))
  %has_attrib10 = load i64, i64* %has_attrib
  %return11 = call i64 @"not@II"(i64 %has_attrib10)
  %return12 = call i64 @"or@III"(i64 %return9, i64 %return11)
  %2 = icmp ne i64 %return12, 0
  br i1 %2, label %true13, label %false14

true3:                                            ; preds = %true
  %original_value6 = load double, double* %original_value
  br label %UnifiedReturnBlock

false4:                                           ; preds = %true
  %new_value7 = load double, double* %new_value
  br label %UnifiedReturnBlock

true13:                                           ; preds = %false
  %new_value16 = load double, double* %new_value
  br label %UnifiedReturnBlock

false14:                                          ; preds = %false
  %return18 = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @2, i64 0, i64 0))
  %3 = icmp ne i64 %return18, 0
  br i1 %3, label %true19, label %false20

true19:                                           ; preds = %false14
  %original_value22 = load double, double* %original_value
  %new_value23 = load double, double* %new_value
  %output = fadd double %original_value22, %new_value23
  br label %UnifiedReturnBlock

false20:                                          ; preds = %false14
  %return25 = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @3, i64 0, i64 0))
  %4 = icmp ne i64 %return25, 0
  br i1 %4, label %true26, label %false27

true26:                                           ; preds = %false20
  %original_value29 = load double, double* %original_value
  %new_value30 = load double, double* %new_value
  %output31 = fsub double %original_value29, %new_value30
  br label %UnifiedReturnBlock

false27:                                          ; preds = %false20
  %return33 = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @4, i64 0, i64 0))
  %return35 = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @5, i64 0, i64 0))
  %return36 = call i64 @"or@III"(i64 %return33, i64 %return35)
  %5 = icmp ne i64 %return36, 0
  br i1 %5, label %true37, label %false38

true37:                                           ; preds = %false27
  %original_value40 = load double, double* %original_value
  %new_value41 = load double, double* %new_value
  %return42 = call double @"min@FFF"(double %original_value40, double %new_value41)
  br label %UnifiedReturnBlock

false38:                                          ; preds = %false27
  %return44 = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @6, i64 0, i64 0))
  %return46 = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @7, i64 0, i64 0))
  %return47 = call i64 @"or@III"(i64 %return44, i64 %return46)
  %6 = icmp ne i64 %return47, 0
  br i1 %6, label %true48, label %false49

true48:                                           ; preds = %false38
  %original_value51 = load double, double* %original_value
  %new_value52 = load double, double* %new_value
  %return53 = call double @"max@FFF"(double %original_value51, double %new_value52)
  br label %UnifiedReturnBlock

false49:                                          ; preds = %false38
  %return55 = call i64 @"eq@ISS"(i8* %operation1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @8, i64 0, i64 0))
  %7 = icmp ne i64 %return55, 0
  br i1 %7, label %true56, label %end57

true56:                                           ; preds = %false49
  %original_value58 = load double, double* %original_value
  %new_value59 = load double, double* %new_value
  %output60 = fmul double %original_value58, %new_value59
  br label %UnifiedReturnBlock

end57:                                            ; preds = %false49
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end57, %true56, %true48, %true37, %true26, %true19, %true13, %false4, %true3
  %UnifiedRetVal = phi double [ %original_value6, %true3 ], [ %new_value7, %false4 ], [ %new_value16, %true13 ], [ %output, %true19 ], [ %output31, %true26 ], [ %return42, %true37 ], [ %return53, %true48 ], [ %output60, %true56 ], [ 0.000000e+00, %end57 ]
  ret double %UnifiedRetVal
}

; Function Attrs: nounwind readnone
declare i64 @"eq@ISS"(i8*, i8*) #0

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #0

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #0

; Function Attrs: nounwind readnone
declare double @"min@FFF"(double, double) #0

; Function Attrs: nounwind readnone
declare double @"max@FFF"(double, double) #0

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VF"(double) #0

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VFFF"(double, double, double) #0

; Function Attrs: nounwind
declare <3 x double> @"normalize@VV"(<3 x double>) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"mul@VV"(<3 x double>, <3 x double>) #0

; Function Attrs: nounwind readnone
declare <3 x double> @"add@VV"(<3 x double>, <3 x double>) #0

; Function Attrs: nounwind readnone
declare <3 x double> @"sub@VV"(<3 x double>, <3 x double>) #0

; Function Attrs: nounwind
declare double @"length@FV"(<3 x double>) #1

; Function Attrs: nounwind readnone
declare <2 x double> @"set@UF"(double) #0

; Function Attrs: nounwind readnone
declare <2 x double> @"set@UFF"(double, double) #0

; Function Attrs: nounwind
declare <2 x double> @"normalize@UU"(<2 x double>) #1

; Function Attrs: nounwind readnone
declare <2 x double> @"mul@UU"(<2 x double>, <2 x double>) #0

; Function Attrs: nounwind readnone
declare <2 x double> @"add@UU"(<2 x double>, <2 x double>) #0

; Function Attrs: nounwind readnone
declare <2 x double> @"sub@UU"(<2 x double>, <2 x double>) #0

; Function Attrs: nounwind
declare double @"length@FU"(<2 x double>) #1

; Function Attrs: alwaysinline nounwind
define private double @"aa_blend@FFFF"(double* %original_value, double* %new_value, double* %blend_amount) #2 {
__llvm_entry:
  %original_value1 = load double, double* %original_value
  %new_value2 = load double, double* %new_value
  %blend_amount3 = load double, double* %blend_amount
  %return = call double @"lerp@FFFF"(double %original_value1, double %new_value2, double %blend_amount3)
  ret double %return
}

; Function Attrs: nounwind
declare double @"lerp@FFFF"(double, double, double) #1

; Function Attrs: nounwind readnone
declare double @"rint@FF"(double) #0

; Function Attrs: nounwind readnone
declare <3 x double> @"rgbtohsv@VV"(<3 x double>) #0

; Function Attrs: nounwind readnone
declare <3 x double> @"hsvtorgb@VV"(<3 x double>) #0

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@FIFF"(double* %_bound_output, i64* %_bound_elemnum, double* %_bound_separation, double* %_bound_blendattrib) #2 {
__llvm_entry:
  %0 = alloca double
  %1 = alloca double
  %2 = alloca i64
  %3 = alloca i8*
  %4 = alloca double
  %5 = alloca double
  %6 = alloca double
  %_bound_output2 = load double, double* %_bound_output
  %return = call i8* @"chs@SS"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @9, i64 0, i64 0))
  %return4 = call i64 @"eq@ISS"(i8* %return, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @10, i64 0, i64 0))
  %7 = icmp ne i64 %return4, 0
  br i1 %7, label %true, label %end

true:                                             ; preds = %__llvm_entry
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %return6 = call double @"chf@FS"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @11, i64 0, i64 0))
  %return7 = call i64 @"chi@IS"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @12, i64 0, i64 0))
  %8 = icmp ne i64 %return7, 0
  br i1 %8, label %true8, label %end9

true8:                                            ; preds = %end
  %return11 = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @13, i64 0, i64 0))
  %output = fmul double %return6, %return11
  %return12 = call double @"chf@FS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @14, i64 0, i64 0))
  %output13 = fadd double %output, %return12
  br label %end9

end9:                                             ; preds = %true8, %end
  %value.0 = phi double [ %output13, %true8 ], [ %return6, %end ]
  %return14 = call i8* @"chs@SS"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @15, i64 0, i64 0))
  %return15 = call i8* @"chs@SS"(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @16, i64 0, i64 0))
  %return16 = call i64 @"hasattrib@IISS"(i64 2, i8* %return14, i8* %return15)
  store double %_bound_output2, double* %0
  store double %value.0, double* %1
  store i64 %return16, i64* %2
  %return20 = call i8* @"chs@SS"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @17, i64 0, i64 0))
  store i8* %return20, i8** %3
  %aa_applyFloatOperation = call double @"aa_applyFloatOperation@FFFIS"(double* %0, double* %1, i64* %2, i8** %3)
  %return21 = call i64 @"chi@IS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @18, i64 0, i64 0))
  %9 = icmp ne i64 %return21, 0
  br i1 %9, label %true22, label %end23

true22:                                           ; preds = %end9
  %return24 = call double @"chf@FS"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @19, i64 0, i64 0))
  %return25 = call i8* @"chs@SS"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @20, i64 0, i64 0))
  %return26 = call i64 @"eq@ISS"(i8* %return25, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @16, i64 0, i64 0))
  %10 = icmp ne i64 %return26, 0
  br i1 %10, label %true27, label %end28

end23:                                            ; preds = %end28, %end9
  %value_output.0 = phi double [ %aa_blend, %end28 ], [ %aa_applyFloatOperation, %end9 ]
  store double %value_output.0, double* %_bound_output
  ret void

true27:                                           ; preds = %true22
  %_bound_blendattrib29 = load double, double* %_bound_blendattrib
  br label %end28

end28:                                            ; preds = %true27, %true22
  %blend.0 = phi double [ %_bound_blendattrib29, %true27 ], [ %return24, %true22 ]
  store double %_bound_output2, double* %4
  store double %aa_applyFloatOperation, double* %5
  store double %blend.0, double* %6
  %aa_blend = call double @"aa_blend@FFFF"(double* %4, double* %5, double* %6)
  br label %end23
}

; Function Attrs: nounwind readnone
declare i8* @"chs@SS"(i8*) #0

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #0

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #0

; Function Attrs: nounwind
declare i64 @"hasattrib@IISS"(i64, i8*, i8*) #1

; Function Attrs: nounwind
define void @__vex_snippet(double %output, i64 %elemnum, double %separation, double %blendattrib) #1 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca double
  %2 = alloca double
  %"<output>" = alloca double
  store double %output, double* %"<output>"
  store i64 %elemnum, i64* %0
  store double %separation, double* %1
  store double %blendattrib, double* %2
  call void @"__vex_snippet_snippet@FIFF"(double* %"<output>", i64* %0, double* %1, double* %2)
  %evalue = load double, double* %"<output>"
  %gvalue = call double @"_export@FSF"(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @21, i64 0, i64 0), double %evalue) #3
  %gvalue5 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @22, i64 0, i64 0), i64 %elemnum) #3
  %gvalue7 = call double @"_export@FSF"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @23, i64 0, i64 0), double %separation) #3
  %gvalue9 = call double @"_export@FSF"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @24, i64 0, i64 0), double %blendattrib) #3
  store double %gvalue, double* @output
  store i64 %gvalue5, i64* @elemnum
  store double %gvalue7, double* @separation
  store double %gvalue9, double* @blendattrib
  ret void
}

declare double @"_export@FSF"(i8*, double)

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(double 0.000000e+00, i64 0, double 0.000000e+00, double 0.000000e+00)
  ret void
}

attributes #0 = { nounwind readnone }
attributes #1 = { nounwind }
attributes #2 = { alwaysinline nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.451"}
!2 = !{!"64"}

;_code_end
