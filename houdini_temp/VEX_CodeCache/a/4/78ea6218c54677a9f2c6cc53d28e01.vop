;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [9 x i8] c"typename\00"
@1 = private constant [5 x i8] c"Poly\00"
@2 = private constant [7 x i8] c"closed\00"
@3 = private constant [7 x i8] c"orient\00"
@4 = private constant [0 x <4 x double>] zeroinitializer
@5 = private constant [0 x double] zeroinitializer
@6 = private constant [2 x i8] c"P\00"
@7 = private constant [8 x i8] c"inertia\00"
@8 = private constant [16 x i8] c"__constraintsrc\00"
@primnum = external global i64
@9 = private constant [8 x i8] c"primnum\00"

; Function Attrs: alwaysinline nounwind
define private void @"computeOrientRodlengths@IISI"(i64* %geo, i64* %primnum, i8** %srcgrp, i64* %outgeo) #0 {
__llvm_entry:
  %geo1 = load i64, i64* %geo
  %primnum2 = load i64, i64* %primnum
  %return = call i8* @"primintrinsic@SISI"(i64 %geo1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @0, i64 0, i64 0), i64 %primnum2)
  %return3 = call i64 @"ne@ISS"(i8* %return, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @1, i64 0, i64 0))
  %geo4 = load i64, i64* %geo
  %primnum5 = load i64, i64* %primnum
  %return6 = call i64 @"primintrinsic@IISI"(i64 %geo4, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @2, i64 0, i64 0), i64 %primnum5)
  %return7 = call i64 @"eq@III"(i64 %return6, i64 1)
  %return8 = call i64 @"or@III"(i64 %return3, i64 %return7)
  %0 = icmp ne i64 %return8, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %end112, %end193, %__llvm_entry
  ret void

end:                                              ; preds = %__llvm_entry
  %geo9 = load i64, i64* %geo
  %srcgrp10 = load i8*, i8** %srcgrp
  %return11 = call i64 @"npointsgroup@IIS"(i64 %geo9, i8* %srcgrp10)
  %geo12 = load i64, i64* %geo
  %return13 = call i64 @"npoints@II"(i64 %geo12)
  %return14 = call i64 @"lt@III"(i64 %return11, i64 %return13)
  %geo15 = load i64, i64* %geo
  %return16 = call i64 @"haspointattrib@IIS"(i64 %geo15, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @3, i64 0, i64 0))
  %geo17 = load i64, i64* %geo
  %primnum18 = load i64, i64* %primnum
  %return19 = call i64* @"primpoints@[III"(i64 %geo17, i64 %primnum18)
  %return21 = call i64 @"len@I[I"(i64* %return19)
  %output = sub i64 %return21, 1
  %output24 = call <4 x double>* @"resize@[PI"(<4 x double>* getelementptr inbounds ([0 x <4 x double>], [0 x <4 x double>]* @4, i64 0, i64 0), i64 %output)
  %output28 = call double* @"resize@[FI"(double* getelementptr inbounds ([0 x double], [0 x double]* @5, i64 0, i64 0), i64 %output)
  %return32 = call i64 @"getcomp@I[II"(i64* %return19, i64 %output)
  br label %cond

cond:                                             ; preds = %end70, %end
  %orients.0 = phi <4 x double>* [ %output24, %end ], [ %orients.1, %end70 ]
  %rodlens.0 = phi double* [ %output28, %end ], [ %output93, %end70 ]
  %loop.0 = phi i64 [ 0, %end ], [ %return101, %end70 ]
  %i.0 = phi i64 [ 0, %end ], [ %output41, %end70 ]
  %from.0 = phi <3 x double> [ <double 0.000000e+00, double 0.000000e+00, double 1.000000e+00>, %end ], [ %to.0, %end70 ]
  %return36 = call i64 @"lt@III"(i64 %i.0, i64 %output)
  %1 = icmp ne i64 %return36, 0
  br i1 %1, label %body, label %end37

body:                                             ; preds = %cond
  %geo38 = load i64, i64* %geo
  %output41 = add i64 %i.0, 1
  %return42 = call i64 @"getcomp@I[II"(i64* %return19, i64 %output41)
  %return43 = call <3 x double> @"point@VISI"(i64 %geo38, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @6, i64 0, i64 0), i64 %return42)
  %geo44 = load i64, i64* %geo
  %return47 = call i64 @"getcomp@I[II"(i64* %return19, i64 %i.0)
  %return48 = call <3 x double> @"point@VISI"(i64 %geo44, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @6, i64 0, i64 0), i64 %return47)
  %output49 = call <3 x double> @"sub@VV"(<3 x double> %return43, <3 x double> %return48)
  %return51 = call <3 x double> @"normalize@VV"(<3 x double> %output49)
  %2 = icmp ne i64 %return16, 0
  br i1 %2, label %true53, label %end54

end37:                                            ; preds = %cond
  br label %cond106

true53:                                           ; preds = %body
  %geo55 = load i64, i64* %geo
  %return59 = call <4 x double> @"point@PISI"(i64 %geo55, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @3, i64 0, i64 0), i64 %return47)
  %return61 = call <4 x double> @"qinvert@PP"(<4 x double> %return59)
  %return63 = call <3 x double> @"qrotate@VPV"(<4 x double> %return61, <3 x double> %return51)
  br label %end54

end54:                                            ; preds = %true53, %body
  %to.0 = phi <3 x double> [ %return63, %true53 ], [ %return51, %body ]
  %return66 = call <4 x double> @"dihedral@PVV"(<3 x double> %from.0, <3 x double> %to.0)
  %return68 = call i64 @"eq@III"(i64 %i.0, i64 0)
  %3 = icmp ne i64 %return68, 0
  br i1 %3, label %true69, label %false

true69:                                           ; preds = %end54
  %return73 = call { <4 x double>, <4 x double>* } @"setcomp@P[PPI"(<4 x double>* %orients.0, <4 x double> %return66, i64 %i.0)
  %output75 = extractvalue { <4 x double>, <4 x double>* } %return73, 1
  br label %end70

false:                                            ; preds = %end54
  %output80 = sub i64 %i.0, 1
  %return81 = call <4 x double> @"getcomp@P[PI"(<4 x double>* %orients.0, i64 %output80)
  %return82 = call <4 x double> @"qmultiply@PPP"(<4 x double> %return66, <4 x double> %return81)
  %return84 = call { <4 x double>, <4 x double>* } @"setcomp@P[PPI"(<4 x double>* %orients.0, <4 x double> %return82, i64 %i.0)
  %output86 = extractvalue { <4 x double>, <4 x double>* } %return84, 1
  br label %end70

end70:                                            ; preds = %false, %true69
  %orients.1 = phi <4 x double>* [ %output75, %true69 ], [ %output86, %false ]
  %return89 = call double @"length@FV"(<3 x double> %output49)
  %return91 = call { double, double* } @"setcomp@F[FFI"(double* %rodlens.0, double %return89, i64 %i.0)
  %output93 = extractvalue { double, double* } %return91, 1
  %return100 = call i64 @"eq@III"(i64 %return47, i64 %return32)
  %return101 = or i64 %loop.0, %return100
  br label %cond

cond106:                                          ; preds = %iter113, %end37
  %orients.2 = phi <4 x double>* [ %orients.0, %end37 ], [ %orients.3, %iter113 ]
  %i105.0 = phi i64 [ 0, %end37 ], [ %output172, %iter113 ]
  %return111 = call i64 @"lt@III"(i64 %i105.0, i64 %output)
  %4 = icmp ne i64 %return111, 0
  br i1 %4, label %body107, label %end112

body107:                                          ; preds = %cond106
  %5 = icmp ne i64 %return16, 0
  br i1 %5, label %true115, label %end116

end112:                                           ; preds = %cond106
  %return174 = call i64 @"gt@III"(i64 %return21, i64 1)
  %geo175 = load i64, i64* %geo
  %srcgrp176 = load i8*, i8** %srcgrp
  %return178 = call i64 @"inpointgroup@IISI"(i64 %geo175, i8* %srcgrp176, i64 %return32)
  %return179 = call i64 @"and@III"(i64 %return174, i64 %return178)
  %return181 = call i64 @"not@II"(i64 %loop.0)
  %return182 = call i64 @"and@III"(i64 %return179, i64 %return181)
  %6 = icmp ne i64 %return182, 0
  br i1 %6, label %true183, label %true

iter113:                                          ; preds = %end143, %end116, %end161
  %output172 = add i64 %i105.0, 1
  br label %cond106

true115:                                          ; preds = %body107
  %geo118 = load i64, i64* %geo
  %return121 = call i64 @"getcomp@I[II"(i64* %return19, i64 %i105.0)
  %return122 = call <4 x double> @"point@PISI"(i64 %geo118, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @3, i64 0, i64 0), i64 %return121)
  %return127 = call <4 x double> @"getcomp@P[PI"(<4 x double>* %orients.2, i64 %i105.0)
  %return128 = call <4 x double> @"qmultiply@PPP"(<4 x double> %return122, <4 x double> %return127)
  %return130 = call { <4 x double>, <4 x double>* } @"setcomp@P[PPI"(<4 x double>* %orients.2, <4 x double> %return128, i64 %i105.0)
  %output132 = extractvalue { <4 x double>, <4 x double>* } %return130, 1
  br label %end116

end116:                                           ; preds = %true115, %body107
  %orients.3 = phi <4 x double>* [ %output132, %true115 ], [ %orients.2, %body107 ]
  %geo134 = load i64, i64* %geo
  %srcgrp135 = load i8*, i8** %srcgrp
  %return138 = call i64 @"getcomp@I[II"(i64* %return19, i64 %i105.0)
  %return139 = call i64 @"inpointgroup@IISI"(i64 %geo134, i8* %srcgrp135, i64 %return138)
  %return140 = call i64 @"not@II"(i64 %return139)
  %return141 = call i64 @"and@III"(i64 %return14, i64 %return140)
  %7 = icmp ne i64 %return141, 0
  br i1 %7, label %iter113, label %end143

end143:                                           ; preds = %end116
  %return144 = call i64 @"geoself@I"()
  %return150 = call <4 x double> @"getcomp@P[PI"(<4 x double>* %orients.3, i64 %i105.0)
  %return151 = call i64 @"setpointattrib@IISIP"(i64 %return144, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @3, i64 0, i64 0), i64 %return138, <4 x double> %return150)
  %geo152 = load i64, i64* %geo
  %return156 = call double @"point@FISI"(i64 %geo152, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @7, i64 0, i64 0), i64 %return138)
  %return158 = fcmp oeq double %return156, 0.000000e+00
  br i1 %return158, label %iter113, label %end161

end161:                                           ; preds = %end143
  %return162 = call i64 @"geoself@I"()
  %return168 = call double @"getcomp@F[FI"(double* %rodlens.0, i64 %i105.0)
  %return169 = call i64 @"setpointattrib@IISIF"(i64 %return162, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @7, i64 0, i64 0), i64 %return138, double %return168)
  br label %iter113

true183:                                          ; preds = %end112
  %geo186 = load i64, i64* %geo
  %return188 = call double @"point@FISI"(i64 %geo186, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @7, i64 0, i64 0), i64 %return32)
  %return190 = fcmp one double %return188, 0.000000e+00
  br i1 %return190, label %true192, label %end193

true192:                                          ; preds = %true183
  %return194 = call i64 @"geoself@I"()
  %output198 = sub i64 %return21, 2
  %return199 = call double @"getcomp@F[FI"(double* %rodlens.0, i64 %output198)
  %return200 = call i64 @"setpointattrib@IISIF"(i64 %return194, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @7, i64 0, i64 0), i64 %return32, double %return199)
  br label %end193

end193:                                           ; preds = %true192, %true183
  %return201 = call i64 @"geoself@I"()
  %output205 = sub i64 %return21, 2
  %return206 = call <4 x double> @"getcomp@P[PI"(<4 x double>* %orients.2, i64 %output205)
  %return207 = call i64 @"setpointattrib@IISIP"(i64 %return201, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @3, i64 0, i64 0), i64 %return32, <4 x double> %return206)
  br label %true
}

; Function Attrs: nounwind
declare i8* @"primintrinsic@SISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"ne@ISS"(i8*, i8*) #2

; Function Attrs: nounwind
declare i64 @"primintrinsic@IISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"npointsgroup@IIS"(i64, i8*) #1

; Function Attrs: nounwind
declare i64 @"npoints@II"(i64) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"haspointattrib@IIS"(i64, i8*) #1

; Function Attrs: nounwind
declare i64* @"primpoints@[III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #2

; Function Attrs: nounwind readnone
declare <4 x double>* @"resize@[PI"(<4 x double>*, i64) #2

; Function Attrs: nounwind readnone
declare double* @"resize@[FI"(double*, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #2

; Function Attrs: nounwind
declare <3 x double> @"point@VISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"sub@VV"(<3 x double>, <3 x double>) #2

; Function Attrs: nounwind
declare <3 x double> @"normalize@VV"(<3 x double>) #1

; Function Attrs: nounwind
declare <4 x double> @"point@PISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare <4 x double> @"qinvert@PP"(<4 x double>) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"qrotate@VPV"(<4 x double>, <3 x double>) #2

; Function Attrs: nounwind readnone
declare <4 x double> @"dihedral@PVV"(<3 x double>, <3 x double>) #2

; Function Attrs: nounwind readnone
declare { <4 x double>, <4 x double>* } @"setcomp@P[PPI"(<4 x double>*, <4 x double>, i64) #2

; Function Attrs: nounwind readnone
declare <4 x double> @"getcomp@P[PI"(<4 x double>*, i64) #2

; Function Attrs: nounwind readnone
declare <4 x double> @"qmultiply@PPP"(<4 x double>, <4 x double>) #2

; Function Attrs: nounwind
declare double @"length@FV"(<3 x double>) #1

; Function Attrs: nounwind readnone
declare { double, double* } @"setcomp@F[FFI"(double*, double, i64) #2

; Function Attrs: nounwind
declare i64 @"inpointgroup@IISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #2

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"geoself@I"() #1

; Function Attrs: nounwind
declare i64 @"setpointattrib@IISIP"(i64, i8*, i64, <4 x double>) #1

; Function Attrs: nounwind
declare double @"point@FISI"(i64, i8*, i64) #1

; Function Attrs: nounwind readnone
declare double @"getcomp@F[FI"(double*, i64) #2

; Function Attrs: nounwind
declare i64 @"setpointattrib@IISIF"(i64, i8*, i64, double) #1

; Function Attrs: nounwind readnone
declare i64 @"gt@III"(i64, i64) #2

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@I"(i64* %_bound_primnum) #0 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i8*
  %2 = alloca i64
  %3 = alloca i64
  store i64 0, i64* %3
  %_bound_primnum1 = load i64, i64* %_bound_primnum
  store i64 %_bound_primnum1, i64* %0
  store i8* getelementptr inbounds ([16 x i8], [16 x i8]* @8, i64 0, i64 0), i8** %1
  call void @"computeOrientRodlengths@IISI"(i64* %3, i64* %0, i8** %1, i64* %2)
  ret void
}

; Function Attrs: nounwind
define void @__vex_snippet(i64 %primnum) #1 {
__llvm_entry:
  %0 = alloca i64
  store i64 %primnum, i64* %0
  call void @"__vex_snippet_snippet@I"(i64* %0)
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @9, i64 0, i64 0), i64 %primnum) #3
  store i64 %gvalue, i64* @primnum
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind }
attributes #2 = { nounwind readnone }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.498"}
!2 = !{!"64"}

;_code_end
