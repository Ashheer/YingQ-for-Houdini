;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [14 x i8] c"areathreshold\00"
@1 = private constant [13 x i8] c"mops_falloff\00"
@2 = private constant [0 x i64] zeroinitializer
@3 = private constant [2 x i8] c"P\00"
@4 = private constant [14 x i8] c"extrude_depth\00"
@5 = private constant [27 x i8] c"extrusion_falloff_Exponent\00"
@6 = private constant [10 x i8] c"iteration\00"
@7 = private constant [5 x i8] c"poly\00"
@area = external global double
@mops_falloff = external global double
@primnum = external global i64
@N = external global <3 x double>
@8 = private constant [5 x i8] c"area\00"
@9 = private constant [8 x i8] c"primnum\00"
@10 = private constant [2 x i8] c"N\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@FFIV"(double* %_bound_area, double* %_bound_mops_falloff, i64* %_bound_primnum, <3 x double>* %_bound_N) #0 {
__llvm_entry:
  %_bound_area1 = load double, double* %_bound_area
  %return = call double @"chf@FS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @0, i64 0, i64 0))
  %return2 = fcmp ogt double %_bound_area1, %return
  br i1 %return2, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %return4 = call i64 @"hasprimattrib@IIS"(i64 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @1, i64 0, i64 0))
  %0 = icmp ne i64 %return4, 0
  br i1 %0, label %true5, label %end6

end:                                              ; preds = %end6, %end159, %__llvm_entry
  ret void

true5:                                            ; preds = %true
  %_bound_mops_falloff7 = load double, double* %_bound_mops_falloff
  %return8 = fcmp ogt double %_bound_mops_falloff7, 1.000000e+00
  br i1 %return8, label %true10, label %false

end6:                                             ; preds = %true10, %false, %true
  %weight.0 = phi double [ %return13, %true10 ], [ %_bound_mops_falloff7, %false ], [ 0.000000e+00, %true ]
  %usefalloff.0 = phi i64 [ 1, %true10 ], [ 1, %false ], [ 0, %true ]
  %_bound_mops_falloff15 = load double, double* %_bound_mops_falloff
  %return16 = fcmp oge double %_bound_mops_falloff15, 0.000000e+00
  br i1 %return16, label %true18, label %end

true10:                                           ; preds = %true5
  %return13 = call double @"clamp@FFFF"(double %_bound_mops_falloff7, double 0.000000e+00, double 1.000000e+00)
  br label %end6

false:                                            ; preds = %true5
  br label %end6

true18:                                           ; preds = %end6
  %_bound_primnum20 = load i64, i64* %_bound_primnum
  %return21 = call i64* @"primpoints@[III"(i64 0, i64 %_bound_primnum20)
  %return23 = call i64 @"len@I[I"(i64* %return21)
  br label %cond

cond:                                             ; preds = %body, %true18
  %__impl_foreach_index.0 = phi i64 [ 0, %true18 ], [ %output38, %body ]
  %ctr.0 = phi <3 x double> [ zeroinitializer, %true18 ], [ %output, %body ]
  %return28 = call i64 @"lt@III"(i64 %__impl_foreach_index.0, i64 %return23)
  %1 = icmp ne i64 %return28, 0
  br i1 %1, label %body, label %end29

body:                                             ; preds = %cond
  %return32 = call i64 @"getcomp@I[II"(i64* %return21, i64 %__impl_foreach_index.0)
  %return34 = call <3 x double> @"point@VISI"(i64 0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @3, i64 0, i64 0), i64 %return32)
  %output = call <3 x double> @"add@VV"(<3 x double> %ctr.0, <3 x double> %return34)
  %output38 = add i64 %__impl_foreach_index.0, 1
  br label %cond

end29:                                            ; preds = %cond
  %cast = call <3 x double> @"set@VI"(i64 %return23)
  %output41 = call <3 x double> @"div@VV"(<3 x double> %ctr.0, <3 x double> %cast)
  %return42 = call double @"chf@FS"(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @4, i64 0, i64 0))
  %return43 = call double @"chf@FS"(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @5, i64 0, i64 0))
  %return44 = call double @"detail@FIS"(i64 1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @6, i64 0, i64 0))
  %return45 = call double @"pow@FFF"(double %return43, double %return44)
  %output46 = call double @"div@FF"(double %return42, double %return45)
  %_bound_area47 = load double, double* %_bound_area
  %output48 = call double @"div@FF"(double 1.000000e+00, double %_bound_area47)
  %output49 = fmul double %output46, %output48
  %_bound_N51 = load <3 x double>, <3 x double>* %_bound_N
  %cast53 = call <3 x double> @"set@VF"(double %output49)
  %output54 = call <3 x double> @"mul@VV"(<3 x double> %_bound_N51, <3 x double> %cast53)
  %output55 = call <3 x double> @"sub@VV"(<3 x double> %output41, <3 x double> %output54)
  br label %cond56

cond56:                                           ; preds = %end103, %end29
  %i.0 = phi i64 [ 0, %end29 ], [ %output69, %end103 ]
  %addpts.0 = phi i64* [ getelementptr inbounds ([0 x i64], [0 x i64]* @2, i64 0, i64 0), %end29 ], [ %output95, %end103 ]
  %return60 = call i64 @"lt@III"(i64 %i.0, i64 %return23)
  %2 = icmp ne i64 %return60, 0
  br i1 %2, label %body57, label %end61

body57:                                           ; preds = %cond56
  %return65 = call i64 @"getcomp@I[II"(i64* %return21, i64 %i.0)
  %return66 = call <3 x double> @"point@VISI"(i64 0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @3, i64 0, i64 0), i64 %return65)
  %output69 = add i64 %i.0, 1
  %return71 = call i64 @"mod@III"(i64 %output69, i64 %return23)
  %return72 = call i64 @"getcomp@I[II"(i64* %return21, i64 %return71)
  %return73 = call <3 x double> @"point@VISI"(i64 0, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @3, i64 0, i64 0), i64 %return72)
  %return77 = call <3 x double> @"lerp@VVVF"(<3 x double> %return66, <3 x double> %return73, double %weight.0)
  %return90 = call <3 x double> @"lerp@VVVF"(<3 x double> %return77, <3 x double> %output55, double %weight.0)
  %return92 = call i64 @"addpoint@IIV"(i64 0, <3 x double> %return90)
  %output95 = call i64* @"push@[II"(i64* %addpts.0, i64 %return92)
  %return99 = call i64 @"addprim@IISIII"(i64 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @7, i64 0, i64 0), i64 %return65, i64 %return72, i64 %return92)
  %return101 = call i64 @"eq@III"(i64 %usefalloff.0, i64 1)
  %3 = icmp ne i64 %return101, 0
  br i1 %3, label %true102, label %end103

end61:                                            ; preds = %cond56
  br label %cond112

true102:                                          ; preds = %body57
  %_bound_mops_falloff105 = load double, double* %_bound_mops_falloff
  %output106 = fsub double %_bound_mops_falloff105, 1.000000e+00
  %return107 = call i64 @"setprimattrib@IISIF"(i64 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @1, i64 0, i64 0), i64 %return99, double %output106)
  br label %end103

end103:                                           ; preds = %true102, %body57
  br label %cond56

cond112:                                          ; preds = %end145, %end61
  %i111.0 = phi i64 [ 0, %end61 ], [ %output126, %end145 ]
  %return116 = call i64 @"lt@III"(i64 %i111.0, i64 %return23)
  %4 = icmp ne i64 %return116, 0
  br i1 %4, label %body113, label %end117

body113:                                          ; preds = %cond112
  %return122 = call i64 @"getcomp@I[II"(i64* %addpts.0, i64 %i111.0)
  %output126 = add i64 %i111.0, 1
  %return128 = call i64 @"mod@III"(i64 %output126, i64 %return23)
  %return129 = call i64 @"getcomp@I[II"(i64* %addpts.0, i64 %return128)
  %return136 = call i64 @"getcomp@I[II"(i64* %return21, i64 %return128)
  %return141 = call i64 @"addprim@IISIII"(i64 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @7, i64 0, i64 0), i64 %return122, i64 %return129, i64 %return136)
  %return143 = call i64 @"eq@III"(i64 %usefalloff.0, i64 1)
  %5 = icmp ne i64 %return143, 0
  br i1 %5, label %true144, label %end145

end117:                                           ; preds = %cond112
  %return155 = call i64 @"addprim@IIS[I"(i64 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @7, i64 0, i64 0), i64* %addpts.0)
  %return157 = call i64 @"eq@III"(i64 %usefalloff.0, i64 1)
  %6 = icmp ne i64 %return157, 0
  br i1 %6, label %true158, label %end159

true144:                                          ; preds = %body113
  %_bound_mops_falloff147 = load double, double* %_bound_mops_falloff
  %output148 = fsub double %_bound_mops_falloff147, 1.000000e+00
  %return149 = call i64 @"setprimattrib@IISIF"(i64 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @1, i64 0, i64 0), i64 %return141, double %output148)
  br label %end145

end145:                                           ; preds = %true144, %body113
  br label %cond112

true158:                                          ; preds = %end117
  %_bound_mops_falloff161 = load double, double* %_bound_mops_falloff
  %output162 = fsub double %_bound_mops_falloff161, 1.000000e+00
  %return163 = call i64 @"setprimattrib@IISIF"(i64 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @1, i64 0, i64 0), i64 %return155, double %output162)
  br label %end159

end159:                                           ; preds = %true158, %end117
  %_bound_primnum164 = load i64, i64* %_bound_primnum
  %return165 = call i64 @"removeprim@IIII"(i64 0, i64 %_bound_primnum164, i64 0)
  br label %end
}

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #1

; Function Attrs: nounwind
declare i64 @"hasprimattrib@IIS"(i64, i8*) #2

; Function Attrs: nounwind
declare double @"clamp@FFFF"(double, double, double) #2

; Function Attrs: nounwind
declare i64* @"primpoints@[III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #1

; Function Attrs: nounwind
declare <3 x double> @"point@VISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare <3 x double> @"add@VV"(<3 x double>, <3 x double>) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VI"(i64) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"div@VV"(<3 x double>, <3 x double>) #1

; Function Attrs: nounwind
declare double @"detail@FIS"(i64, i8*) #2

; Function Attrs: nounwind readnone
declare double @"pow@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VF"(double) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"mul@VV"(<3 x double>, <3 x double>) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"sub@VV"(<3 x double>, <3 x double>) #1

; Function Attrs: nounwind readnone
declare i64 @"mod@III"(i64, i64) #1

; Function Attrs: nounwind
declare <3 x double> @"lerp@VVVF"(<3 x double>, <3 x double>, double) #2

; Function Attrs: nounwind
declare i64 @"addpoint@IIV"(i64, <3 x double>) #2

; Function Attrs: nounwind readnone
declare i64* @"push@[II"(i64*, i64) #1

; Function Attrs: nounwind
declare i64 @"addprim@IISIII"(i64, i8*, i64, i64, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"setprimattrib@IISIF"(i64, i8*, i64, double) #2

; Function Attrs: nounwind
declare i64 @"addprim@IIS[I"(i64, i8*, i64*) #2

; Function Attrs: nounwind
declare i64 @"removeprim@IIII"(i64, i64, i64) #2

; Function Attrs: nounwind
define void @__vex_snippet(double %area, double %mops_falloff, i64 %primnum, <3 x double> %N) #2 {
__llvm_entry:
  %0 = alloca double
  %1 = alloca double
  %2 = alloca i64
  %3 = alloca <3 x double>
  store double %area, double* %0
  store double %mops_falloff, double* %1
  store i64 %primnum, i64* %2
  store <3 x double> %N, <3 x double>* %3
  call void @"__vex_snippet_snippet@FFIV"(double* %0, double* %1, i64* %2, <3 x double>* %3)
  %gvalue = call double @"_export@FSF"(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @8, i64 0, i64 0), double %area) #3
  %gvalue6 = call double @"_export@FSF"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @1, i64 0, i64 0), double %mops_falloff) #3
  %gvalue8 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @9, i64 0, i64 0), i64 %primnum) #3
  %gvalue10 = call <3 x double> @"_export@VSV"(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @10, i64 0, i64 0), <3 x double> %N) #3
  store double %gvalue, double* @area
  store double %gvalue6, double* @mops_falloff
  store i64 %gvalue8, i64* @primnum
  store <3 x double> %gvalue10, <3 x double>* @N
  ret void
}

declare double @"_export@FSF"(i8*, double)

declare i64 @"_export@ISI"(i8*, i64)

declare <3 x double> @"_export@VSV"(i8*, <3 x double>)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(double 0.000000e+00, double 0.000000e+00, i64 0, <3 x double> zeroinitializer)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.451"}
!2 = !{!"64"}

;_code_end
