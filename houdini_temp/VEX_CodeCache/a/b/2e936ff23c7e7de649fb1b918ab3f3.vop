;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [4 x i8] c"\0A%d\00"

; Function Attrs: alwaysinline nounwind
define private i64 @"square@II"(i64* %value) #0 {
__llvm_entry:
  %value1 = load i64, i64* %value
  %output = mul i64 %value1, %value1
  ret i64 %output
}

; Function Attrs: nounwind readnone
declare <2 x double> @"mul@UU"(<2 x double>, <2 x double>) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"mul@VV"(<3 x double>, <3 x double>) #1

; Function Attrs: nounwind readnone
declare <4 x double> @"mul@PP"(<4 x double>, <4 x double>) #1

; Function Attrs: alwaysinline nounwind
define private i64 @"cubic@II"(i64* %value) #0 {
__llvm_entry:
  %value1 = load i64, i64* %value
  %output = mul i64 %value1, %value1
  %output4 = mul i64 %output, %value1
  ret i64 %output4
}

; Function Attrs: nounwind readnone
declare double @"getcomp@FVI"(<3 x double>, i64) #1

; Function Attrs: nounwind readnone
declare double @"pow@FFF"(double, double) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VFFF"(double, double, double) #1

; Function Attrs: nounwind readnone
declare double @"getcomp@FPI"(<4 x double>, i64) #1

; Function Attrs: nounwind readnone
declare <4 x double> @"set@PFFFF"(double, double, double, double) #1

; Function Attrs: alwaysinline nounwind
define private i64 @"pow@III"(i64* %num, i64* %exp) #0 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64
  %exp1 = load i64, i64* %exp
  %return = call i64 @"eq@III"(i64 %exp1, i64 0)
  %2 = icmp ne i64 %return, 0
  br i1 %2, label %true, label %false

true:                                             ; preds = %__llvm_entry
  br label %UnifiedReturnBlock

false:                                            ; preds = %__llvm_entry
  %return3 = call i64 @"eq@III"(i64 %exp1, i64 1)
  %3 = icmp ne i64 %return3, 0
  br i1 %3, label %true4, label %false5

true4:                                            ; preds = %false
  %num7 = load i64, i64* %num
  br label %UnifiedReturnBlock

false5:                                           ; preds = %false
  %return9 = call i64 @"eq@III"(i64 %exp1, i64 2)
  %4 = icmp ne i64 %return9, 0
  br i1 %4, label %true10, label %false11

true10:                                           ; preds = %false5
  %num13 = load i64, i64* %num
  store i64 %num13, i64* %0
  %square = call i64 @"square@II"(i64* %0)
  br label %UnifiedReturnBlock

false11:                                          ; preds = %false5
  %return15 = call i64 @"eq@III"(i64 %exp1, i64 3)
  %5 = icmp ne i64 %return15, 0
  br i1 %5, label %true16, label %false17

true16:                                           ; preds = %false11
  %num19 = load i64, i64* %num
  store i64 %num19, i64* %1
  %cubic = call i64 @"cubic@II"(i64* %1)
  br label %UnifiedReturnBlock

false17:                                          ; preds = %false11
  %num20 = load i64, i64* %num
  %cast = sitofp i64 %num20 to double
  %cast22 = sitofp i64 %exp1 to double
  %return23 = call double @"pow@FFF"(double %cast, double %cast22)
  %cast24 = fptosi double %return23 to i64
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %false17, %true16, %true10, %true4, %true
  %UnifiedRetVal = phi i64 [ 1, %true ], [ %num7, %true4 ], [ %square, %true10 ], [ %cubic, %true16 ], [ %cast24, %false17 ]
  ret i64 %UnifiedRetVal
}

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare <2 x double> @"set@UI"(i64) #1

; Function Attrs: nounwind readnone
declare <2 x double> @"pow@UUF"(<2 x double>, double) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"set@VI"(i64) #1

; Function Attrs: nounwind readnone
declare <3 x double> @"pow@VVF"(<3 x double>, double) #1

; Function Attrs: nounwind readnone
declare <4 x double> @"set@PI"(i64) #1

; Function Attrs: nounwind readnone
declare <4 x double> @"pow@PPF"(<4 x double>, double) #1

; Function Attrs: alwaysinline nounwind
define private void @__vex_snippet_snippet() #0 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64
  store i64 2, i64* %0
  store i64 31, i64* %1
  %pow = call i64 @"pow@III"(i64* %0, i64* %1)
  call void @"printf@S:I"(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @0, i64 0, i64 0), i64 %pow)
  ret void
}

; Function Attrs: nounwind
declare void @"printf@S:I"(i8*, i64) #2

; Function Attrs: nounwind
define void @__vex_snippet() #2 {
__llvm_entry:
  call void @__vex_snippet_snippet()
  ret void
}

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet()
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.531"}
!2 = !{!"64"}

;_code_end
