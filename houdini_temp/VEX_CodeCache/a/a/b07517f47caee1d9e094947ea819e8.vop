;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [0 x i64] zeroinitializer
@1 = private constant [13 x i8] c"../edgegroup\00"
@2 = private constant [1 x i8] zeroinitializer
@3 = private constant [15 x i8] c"../excludenebs\00"
@4 = private constant [84 x i8] c"excludenebs: One or more of the specified point attributes has an unsupported type.\00"
@5 = private constant [15 x i8] c"../includenebs\00"
@6 = private constant [84 x i8] c"includenebs: One or more of the specified point attributes has an unsupported type.\00"
@7 = private constant [12 x i8] c"../primtype\00"
@ptnum = external global i64
@elemnum = external global i64
@8 = private constant [6 x i8] c"ptnum\00"
@9 = private constant [8 x i8] c"elemnum\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@II"(i64* %_bound_ptnum, i64* %_bound_elemnum) #0 {
__llvm_entry:
  %0 = alloca i64*
  %1 = alloca i64
  %2 = alloca i64
  %3 = alloca i64*
  %4 = alloca i64
  %nebs = alloca i64*
  %_bound_ptnum1 = load i64, i64* %_bound_ptnum
  %return = call i64* @"neighbours@[III"(i64 1, i64 %_bound_ptnum1)
  store i64* %return, i64** %nebs
  %return2 = call i8* @"chs@SS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @1, i64 0, i64 0))
  %return3 = call i64 @"ne@ISS"(i8* %return2, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @2, i64 0, i64 0))
  %5 = icmp ne i64 %return3, 0
  br i1 %5, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %return6 = call i64 @"len@I[I"(i64* %return)
  %output = sub i64 %return6, 1
  br label %cond

end:                                              ; preds = %cond, %__llvm_entry
  %return26 = call i8* @"chs@SS"(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @3, i64 0, i64 0))
  %return27 = call i64 @"ne@ISS"(i8* %return26, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @2, i64 0, i64 0))
  %6 = icmp ne i64 %return27, 0
  br i1 %6, label %true28, label %end29

cond:                                             ; preds = %iter, %true
  %i.0 = phi i64 [ %output, %true ], [ %output25, %iter ]
  %return8 = call i64 @"neg@II"(i64 1)
  %return9 = call i64 @"gt@III"(i64 %i.0, i64 %return8)
  %7 = icmp ne i64 %return9, 0
  br i1 %7, label %body, label %end

body:                                             ; preds = %cond
  %_bound_ptnum12 = load i64, i64* %_bound_ptnum
  %nebs13 = load i64*, i64** %nebs
  %return15 = call i64 @"getcomp@I[II"(i64* %nebs13, i64 %i.0)
  %return16 = call i64 @"inedgegroup@IISII"(i64 1, i8* %return2, i64 %_bound_ptnum12, i64 %return15)
  %8 = icmp ne i64 %return16, 0
  br i1 %8, label %iter, label %end18

iter:                                             ; preds = %body, %end18
  %output25 = sub i64 %i.0, 1
  br label %cond

end18:                                            ; preds = %body
  %nebs19 = load i64*, i64** %nebs
  %return21 = call { i64, i64* } @"pop@I[II"(i64* %nebs19, i64 %i.0)
  %output23 = extractvalue { i64, i64* } %return21, 1
  store i64* %output23, i64** %nebs
  br label %iter

true28:                                           ; preds = %end
  %return31 = call i64 @"pointattribtype@IIS"(i64 0, i8* %return26)
  %return33 = call i64 @"eq@III"(i64 %return31, i64 0)
  %9 = icmp ne i64 %return33, 0
  br i1 %9, label %true34, label %false

end29:                                            ; preds = %false103, %false72, %cond82, %true61, %true46, %true34, %end
  %return105 = call i8* @"chs@SS"(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @5, i64 0, i64 0))
  %return106 = call i64 @"ne@ISS"(i8* %return105, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @2, i64 0, i64 0))
  %10 = icmp ne i64 %return106, 0
  br i1 %10, label %true107, label %end108

true34:                                           ; preds = %true28
  %_bound_elemnum37 = load i64, i64* %_bound_elemnum
  %return38 = call i64 @"point@IISI"(i64 0, i8* %return26, i64 %_bound_elemnum37)
  %nebs39 = load i64*, i64** %nebs
  %return41 = call { i64, i64* } @"removevalue@I[II"(i64* %nebs39, i64 %return38)
  %output43 = extractvalue { i64, i64* } %return41, 1
  store i64* %output43, i64** %nebs
  br label %end29

false:                                            ; preds = %true28
  %return45 = call i64 @"eq@III"(i64 %return31, i64 2)
  %11 = icmp ne i64 %return45, 0
  br i1 %11, label %true46, label %false47

true46:                                           ; preds = %false
  %_bound_elemnum51 = load i64, i64* %_bound_elemnum
  %return52 = call i8* @"point@SISI"(i64 0, i8* %return26, i64 %_bound_elemnum51)
  %nebs53 = load i64*, i64** %nebs
  %return55 = call i64 @"atoi@IS"(i8* %return52)
  %return56 = call { i64, i64* } @"removevalue@I[II"(i64* %nebs53, i64 %return55)
  %output58 = extractvalue { i64, i64* } %return56, 1
  store i64* %output58, i64** %nebs
  br label %end29

false47:                                          ; preds = %false
  %return60 = call i64 @"eq@III"(i64 %return31, i64 3)
  %12 = icmp ne i64 %return60, 0
  br i1 %12, label %true61, label %false62

true61:                                           ; preds = %false47
  %_bound_elemnum66 = load i64, i64* %_bound_elemnum
  %return67 = call i64* @"point@[IISI"(i64 0, i8* %return26, i64 %_bound_elemnum66)
  store i64* %return67, i64** %0
  call void @"removevalue@[I[I"(i64** %nebs, i64** %0)
  br label %end29

false62:                                          ; preds = %false47
  %return70 = call i64 @"eq@III"(i64 %return31, i64 5)
  %13 = icmp ne i64 %return70, 0
  br i1 %13, label %true71, label %false72

true71:                                           ; preds = %false62
  %_bound_elemnum76 = load i64, i64* %_bound_elemnum
  %return77 = call i8** @"point@[SISI"(i64 0, i8* %return26, i64 %_bound_elemnum76)
  %return80 = call i64 @"len@I[S"(i8** %return77)
  %output81 = sub i64 %return80, 1
  br label %cond82

false72:                                          ; preds = %false62
  %return100 = call i64 @"neg@II"(i64 1)
  %return101 = call i64 @"eq@III"(i64 %return31, i64 %return100)
  %14 = icmp ne i64 %return101, 0
  br i1 %14, label %end29, label %false103

cond82:                                           ; preds = %body83, %true71
  %i78.0 = phi i64 [ %output81, %true71 ], [ %output98, %body83 ]
  %return85 = call i64 @"neg@II"(i64 1)
  %return86 = call i64 @"gt@III"(i64 %i78.0, i64 %return85)
  %15 = icmp ne i64 %return86, 0
  br i1 %15, label %body83, label %end29

body83:                                           ; preds = %cond82
  %nebs89 = load i64*, i64** %nebs
  %return92 = call i8* @"getcomp@S[SI"(i8** %return77, i64 %i78.0)
  %return93 = call i64 @"atoi@IS"(i8* %return92)
  %return94 = call { i64, i64* } @"removevalue@I[II"(i64* %nebs89, i64 %return93)
  %output96 = extractvalue { i64, i64* } %return94, 1
  store i64* %output96, i64** %nebs
  %output98 = sub i64 %i78.0, 1
  br label %cond82

false103:                                         ; preds = %false72
  call void @"warning@S"(i8* getelementptr inbounds ([84 x i8], [84 x i8]* @4, i64 0, i64 0))
  br label %end29

true107:                                          ; preds = %end29
  %return111 = call i64 @"pointattribtype@IIS"(i64 0, i8* %return105)
  %return113 = call i64 @"eq@III"(i64 %return111, i64 0)
  %16 = icmp ne i64 %return113, 0
  br i1 %16, label %true114, label %false115

end108:                                           ; preds = %false173, %false146, %cond156, %true135, %true124, %true114, %end29
  %nebs175 = load i64*, i64** %nebs
  %return176 = call i64 @"len@I[I"(i64* %nebs175)
  br label %cond177

true114:                                          ; preds = %true107
  %_bound_elemnum119 = load i64, i64* %_bound_elemnum
  %return120 = call i64 @"point@IISI"(i64 0, i8* %return105, i64 %_bound_elemnum119)
  store i64 %return120, i64* %1
  call void @"uniquepush@[II"(i64** %nebs, i64* %1)
  br label %end108

false115:                                         ; preds = %true107
  %return123 = call i64 @"eq@III"(i64 %return111, i64 2)
  %17 = icmp ne i64 %return123, 0
  br i1 %17, label %true124, label %false125

true124:                                          ; preds = %false115
  %_bound_elemnum129 = load i64, i64* %_bound_elemnum
  %return130 = call i8* @"point@SISI"(i64 0, i8* %return105, i64 %_bound_elemnum129)
  %return132 = call i64 @"atoi@IS"(i8* %return130)
  store i64 %return132, i64* %2
  call void @"uniquepush@[II"(i64** %nebs, i64* %2)
  br label %end108

false125:                                         ; preds = %false115
  %return134 = call i64 @"eq@III"(i64 %return111, i64 3)
  %18 = icmp ne i64 %return134, 0
  br i1 %18, label %true135, label %false136

true135:                                          ; preds = %false125
  %_bound_elemnum140 = load i64, i64* %_bound_elemnum
  %return141 = call i64* @"point@[IISI"(i64 0, i8* %return105, i64 %_bound_elemnum140)
  store i64* %return141, i64** %3
  call void @"uniquepush@[I[I"(i64** %nebs, i64** %3)
  br label %end108

false136:                                         ; preds = %false125
  %return144 = call i64 @"eq@III"(i64 %return111, i64 5)
  %19 = icmp ne i64 %return144, 0
  br i1 %19, label %true145, label %false146

true145:                                          ; preds = %false136
  %_bound_elemnum150 = load i64, i64* %_bound_elemnum
  %return151 = call i8** @"point@[SISI"(i64 0, i8* %return105, i64 %_bound_elemnum150)
  %return154 = call i64 @"len@I[S"(i8** %return151)
  %output155 = sub i64 %return154, 1
  br label %cond156

false146:                                         ; preds = %false136
  %return170 = call i64 @"neg@II"(i64 1)
  %return171 = call i64 @"eq@III"(i64 %return111, i64 %return170)
  %20 = icmp ne i64 %return171, 0
  br i1 %20, label %end108, label %false173

cond156:                                          ; preds = %body157, %true145
  %i152.0 = phi i64 [ %output155, %true145 ], [ %output168, %body157 ]
  %return159 = call i64 @"neg@II"(i64 1)
  %return160 = call i64 @"gt@III"(i64 %i152.0, i64 %return159)
  %21 = icmp ne i64 %return160, 0
  br i1 %21, label %body157, label %end108

body157:                                          ; preds = %cond156
  %return165 = call i8* @"getcomp@S[SI"(i8** %return151, i64 %i152.0)
  %return166 = call i64 @"atoi@IS"(i8* %return165)
  store i64 %return166, i64* %4
  call void @"uniquepush@[II"(i64** %nebs, i64* %4)
  %output168 = sub i64 %i152.0, 1
  br label %cond156

false173:                                         ; preds = %false146
  call void @"warning@S"(i8* getelementptr inbounds ([84 x i8], [84 x i8]* @6, i64 0, i64 0))
  br label %end108

cond177:                                          ; preds = %iter183, %end108
  %__impl_foreach_index_18b.0 = phi i64 [ 0, %end108 ], [ %output197, %iter183 ]
  %return181 = call i64 @"lt@III"(i64 %__impl_foreach_index_18b.0, i64 %return176)
  %22 = icmp ne i64 %return181, 0
  br i1 %22, label %body178, label %end182

body178:                                          ; preds = %cond177
  %nebs184 = load i64*, i64** %nebs
  %return186 = call i64 @"getcomp@I[II"(i64* %nebs184, i64 %__impl_foreach_index_18b.0)
  %_bound_ptnum187 = load i64, i64* %_bound_ptnum
  %return189 = call i64 @"ge@III"(i64 %_bound_ptnum187, i64 %return186)
  %23 = icmp ne i64 %return189, 0
  br i1 %23, label %iter183, label %end191

end182:                                           ; preds = %cond177
  ret void

iter183:                                          ; preds = %body178, %end191
  %output197 = add i64 %__impl_foreach_index_18b.0, 1
  br label %cond177

end191:                                           ; preds = %body178
  %return192 = call i8* @"chs@SS"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @7, i64 0, i64 0))
  %return195 = call i64 @"addprim@IISII"(i64 0, i8* %return192, i64 %_bound_ptnum187, i64 %return186)
  br label %iter183
}

; Function Attrs: alwaysinline nounwind
define private void @"removevalue@[I[I"(i64** %arr, i64** %values) #0 {
__llvm_entry:
  %values1 = load i64*, i64** %values
  %return = call i64 @"len@I[I"(i64* %values1)
  %output = sub i64 %return, 1
  br label %cond

cond:                                             ; preds = %body, %__llvm_entry
  %i.0 = phi i64 [ %output, %__llvm_entry ], [ %output13, %body ]
  %return3 = call i64 @"neg@II"(i64 1)
  %return4 = call i64 @"gt@III"(i64 %i.0, i64 %return3)
  %0 = icmp ne i64 %return4, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %arr5 = load i64*, i64** %arr
  %values6 = load i64*, i64** %values
  %return8 = call i64 @"getcomp@I[II"(i64* %values6, i64 %i.0)
  %return9 = call { i64, i64* } @"removevalue@I[II"(i64* %arr5, i64 %return8)
  %output11 = extractvalue { i64, i64* } %return9, 1
  store i64* %output11, i64** %arr
  %output13 = sub i64 %i.0, 1
  br label %cond

end:                                              ; preds = %cond
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare i64 @"neg@II"(i64) #1

; Function Attrs: nounwind readnone
declare i64 @"gt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #1

; Function Attrs: nounwind
declare { i64, i64* } @"removevalue@I[II"(i64*, i64) #2

; Function Attrs: alwaysinline nounwind
define private void @"uniquepush@[II"(i64** %arr, i64* %value) #0 {
__llvm_entry:
  %arr1 = load i64*, i64** %arr
  %value2 = load i64, i64* %value
  %return = call i64 @"find@I[II"(i64* %arr1, i64 %value2)
  %return3 = call i64 @"lt@III"(i64 %return, i64 0)
  %0 = icmp ne i64 %return3, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %arr4 = load i64*, i64** %arr
  %value5 = load i64, i64* %value
  %output = call i64* @"push@[II"(i64* %arr4, i64 %value5)
  store i64* %output, i64** %arr
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  ret void
}

; Function Attrs: nounwind
declare i64 @"find@I[II"(i64*, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64* @"push@[II"(i64*, i64) #1

; Function Attrs: alwaysinline nounwind
define private void @"uniquepush@[I[I"(i64** %arr, i64** %values) #0 {
__llvm_entry:
  %0 = alloca i64
  %values1 = load i64*, i64** %values
  %return = call i64 @"len@I[I"(i64* %values1)
  %output = sub i64 %return, 1
  br label %cond

cond:                                             ; preds = %body, %__llvm_entry
  %i.0 = phi i64 [ %output, %__llvm_entry ], [ %output9, %body ]
  %return3 = call i64 @"neg@II"(i64 1)
  %return4 = call i64 @"gt@III"(i64 %i.0, i64 %return3)
  %1 = icmp ne i64 %return4, 0
  br i1 %1, label %body, label %end

body:                                             ; preds = %cond
  %values5 = load i64*, i64** %values
  %return7 = call i64 @"getcomp@I[II"(i64* %values5, i64 %i.0)
  store i64 %return7, i64* %0
  call void @"uniquepush@[II"(i64** %arr, i64* %0)
  %output9 = sub i64 %i.0, 1
  br label %cond

end:                                              ; preds = %cond
  ret void
}

; Function Attrs: nounwind
declare i64* @"neighbours@[III"(i64, i64) #2

; Function Attrs: nounwind readnone
declare i8* @"chs@SS"(i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"ne@ISS"(i8*, i8*) #1

; Function Attrs: nounwind
declare i64 @"inedgegroup@IISII"(i64, i8*, i64, i64) #2

; Function Attrs: nounwind readnone
declare { i64, i64* } @"pop@I[II"(i64*, i64) #1

; Function Attrs: nounwind
declare i64 @"pointattribtype@IIS"(i64, i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"point@IISI"(i64, i8*, i64) #2

; Function Attrs: nounwind
declare i8* @"point@SISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"atoi@IS"(i8*) #1

; Function Attrs: nounwind
declare i64* @"point@[IISI"(i64, i8*, i64) #2

; Function Attrs: nounwind
declare i8** @"point@[SISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"len@I[S"(i8**) #1

; Function Attrs: nounwind readnone
declare i8* @"getcomp@S[SI"(i8**, i64) #1

; Function Attrs: nounwind
declare void @"warning@S"(i8*) #2

; Function Attrs: nounwind readnone
declare i64 @"ge@III"(i64, i64) #1

; Function Attrs: nounwind
declare i64 @"addprim@IISII"(i64, i8*, i64, i64) #2

; Function Attrs: nounwind
define void @__vex_snippet(i64 %ptnum, i64 %elemnum) #2 {
__llvm_entry:
  %0 = alloca i64
  %1 = alloca i64
  store i64 %ptnum, i64* %0
  store i64 %elemnum, i64* %1
  call void @"__vex_snippet_snippet@II"(i64* %0, i64* %1)
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @8, i64 0, i64 0), i64 %ptnum) #3
  %gvalue4 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @9, i64 0, i64 0), i64 %elemnum) #3
  store i64 %gvalue, i64* @ptnum
  store i64 %gvalue4, i64* @elemnum
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0, i64 0)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.451"}
!2 = !{!"64"}

;_code_end
