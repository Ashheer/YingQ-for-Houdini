;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [0 x i64] zeroinitializer
@1 = private constant [20 x i8] c"origprims_subdivide\00"
@2 = private constant [7 x i8] c"closed\00"
@3 = private constant [0 x double] zeroinitializer
@edgeneighbours = external global i64*
@facepts = external global i64*
@isclosed = external global i64
@isboundarypt = external global i64
@ptnum = external global i64
@sourcept_indices = external global i64*
@sourcept_weights = external global double*
@4 = private constant [15 x i8] c"edgeneighbours\00"
@5 = private constant [8 x i8] c"facepts\00"
@6 = private constant [9 x i8] c"isclosed\00"
@7 = private constant [13 x i8] c"isboundarypt\00"
@8 = private constant [6 x i8] c"ptnum\00"
@9 = private constant [17 x i8] c"sourcept_indices\00"
@10 = private constant [17 x i8] c"sourcept_weights\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@[I[IIII[I[F"(i64** %_bound_edgeneighbours, i64** %_bound_facepts, i64* %_bound_isclosed, i64* %_bound_isboundarypt, i64* %_bound_ptnum, i64** %_bound_sourcept_indices, double** %_bound_sourcept_weights) #0 {
__llvm_entry:
  %_bound_edgeneighbours1 = load i64*, i64** %_bound_edgeneighbours
  %_bound_facepts2 = load i64*, i64** %_bound_facepts
  %return = call i64 @"len@I[I"(i64* %_bound_edgeneighbours1)
  %output = mul i64 %return, %return
  %cast = sitofp i64 %output to double
  %output6 = call double @"div@FF"(double 1.000000e+00, double %cast)
  %output11 = call double @"div@FF"(double 2.000000e+00, double %cast)
  %cast13 = sitofp i64 %return to double
  %output14 = fsub double %cast13, 3.000000e+00
  %output17 = call double @"div@FF"(double %output14, double %cast13)
  %_bound_isclosed18 = load i64, i64* %_bound_isclosed
  %0 = icmp ne i64 %_bound_isclosed18, 0
  br i1 %0, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %_bound_isboundarypt19 = load i64, i64* %_bound_isboundarypt
  %1 = icmp ne i64 %_bound_isboundarypt19, 0
  br i1 %1, label %true20, label %end

false:                                            ; preds = %__llvm_entry
  %output22 = call double @"div@FF"(double 1.000000e+00, double 3.000000e+00)
  %output23 = call double @"div@FF"(double 2.000000e+00, double 3.000000e+00)
  br label %cond

end:                                              ; preds = %true, %true20, %end29
  %edgeweight.0 = phi double [ 2.500000e-01, %true20 ], [ %output11, %true ], [ %output70, %end29 ]
  %controlweight.0 = phi double [ 5.000000e-01, %true20 ], [ %output17, %true ], [ %output22, %end29 ]
  %edgeprimcount.0 = phi i64* [ getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), %true20 ], [ getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), %true ], [ %edgeprimcount.1, %end29 ]
  %faceweight.0 = phi double [ 0.000000e+00, %true20 ], [ %output6, %true ], [ 0.000000e+00, %end29 ]
  %_bound_ptnum71 = load i64, i64* %_bound_ptnum
  %return72 = call i64* @"array@[I:I"(i64 %_bound_ptnum71)
  %return74 = call double* @"array@[F:F"(double %controlweight.0)
  br label %cond78

true20:                                           ; preds = %true
  br label %end

cond:                                             ; preds = %end42, %false
  %edgeprimcount.1 = phi i64* [ getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), %false ], [ %output63, %end42 ]
  %__impl_foreach_index_d.0 = phi i64 [ 0, %false ], [ %output65, %end42 ]
  %return28 = call i64 @"lt@III"(i64 %__impl_foreach_index_d.0, i64 %return)
  %2 = icmp ne i64 %return28, 0
  br i1 %2, label %body, label %end29

body:                                             ; preds = %cond
  %return32 = call i64 @"getcomp@I[II"(i64* %_bound_edgeneighbours1, i64 %__impl_foreach_index_d.0)
  %return34 = call i64* @"pointprims@[III"(i64 0, i64 %return32)
  %return36 = call i64 @"len@I[I"(i64* %return34)
  br label %cond37

end29:                                            ; preds = %cond
  %return68 = call i64 @"sum@I[I"(i64* %edgeprimcount.1)
  %cast69 = sitofp i64 %return68 to double
  %output70 = call double @"div@FF"(double %output23, double %cast69)
  br label %end

cond37:                                           ; preds = %end50, %body
  %primcount.0 = phi i64 [ 0, %body ], [ %primcount.1, %end50 ]
  %__impl_foreach_index_c.0 = phi i64 [ 0, %body ], [ %output60, %end50 ]
  %return41 = call i64 @"lt@III"(i64 %__impl_foreach_index_c.0, i64 %return36)
  %3 = icmp ne i64 %return41, 0
  br i1 %3, label %body38, label %end42

body38:                                           ; preds = %cond37
  %return46 = call i64 @"getcomp@I[II"(i64* %return34, i64 %__impl_foreach_index_c.0)
  %return48 = call i64 @"inprimgroup@IISI"(i64 0, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @1, i64 0, i64 0), i64 %return46)
  %4 = icmp ne i64 %return48, 0
  br i1 %4, label %true49, label %end50

end42:                                            ; preds = %cond37
  %output63 = call i64* @"append@[II"(i64* %edgeprimcount.1, i64 %primcount.0)
  %output65 = add i64 %__impl_foreach_index_d.0, 1
  br label %cond

true49:                                           ; preds = %body38
  %return52 = call i64 @"primintrinsic@IISI"(i64 0, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @2, i64 0, i64 0), i64 %return46)
  %return54 = call i64 @"not@II"(i64 %return52)
  %5 = icmp ne i64 %return54, 0
  br i1 %5, label %true55, label %end50

end50:                                            ; preds = %true49, %true55, %body38
  %primcount.1 = phi i64 [ %output58, %true55 ], [ %primcount.0, %true49 ], [ %primcount.0, %body38 ]
  %output60 = add i64 %__impl_foreach_index_c.0, 1
  br label %cond37

true55:                                           ; preds = %true49
  %output58 = add i64 %primcount.0, 1
  br label %end50

cond78:                                           ; preds = %end94, %end
  %indices.0 = phi i64* [ %return72, %end ], [ %output90, %end94 ]
  %weights.0 = phi double* [ %return74, %end ], [ %weights.1, %end94 ]
  %i.0 = phi i64 [ 0, %end ], [ %output107, %end94 ]
  %return82 = call i64 @"lt@III"(i64 %i.0, i64 %return)
  %6 = icmp ne i64 %return82, 0
  br i1 %6, label %body79, label %end83

body79:                                           ; preds = %cond78
  %return87 = call i64 @"getcomp@I[II"(i64* %_bound_edgeneighbours1, i64 %i.0)
  %output90 = call i64* @"append@[II"(i64* %indices.0, i64 %return87)
  %_bound_isclosed91 = load i64, i64* %_bound_isclosed
  %7 = icmp ne i64 %_bound_isclosed91, 0
  br i1 %7, label %true92, label %false93

end83:                                            ; preds = %cond78
  %return110 = call i64 @"len@I[I"(i64* %_bound_facepts2)
  br label %cond111

true92:                                           ; preds = %body79
  %output97 = call double* @"append@[FF"(double* %weights.0, double %edgeweight.0)
  br label %end94

false93:                                          ; preds = %body79
  %return102 = call i64 @"getcomp@I[II"(i64* %edgeprimcount.0, i64 %i.0)
  %cast103 = sitofp i64 %return102 to double
  %output104 = fmul double %edgeweight.0, %cast103
  %output105 = call double* @"append@[FF"(double* %weights.0, double %output104)
  br label %end94

end94:                                            ; preds = %false93, %true92
  %weights.1 = phi double* [ %output97, %true92 ], [ %output105, %false93 ]
  %output107 = add i64 %i.0, 1
  br label %cond78

cond111:                                          ; preds = %body112, %end83
  %indices.1 = phi i64* [ %indices.0, %end83 ], [ %output123, %body112 ]
  %weights.2 = phi double* [ %weights.0, %end83 ], [ %output126, %body112 ]
  %__impl_foreach_index_f.0 = phi i64 [ 0, %end83 ], [ %output128, %body112 ]
  %return115 = call i64 @"lt@III"(i64 %__impl_foreach_index_f.0, i64 %return110)
  %8 = icmp ne i64 %return115, 0
  br i1 %8, label %body112, label %end116

body112:                                          ; preds = %cond111
  %return120 = call i64 @"getcomp@I[II"(i64* %_bound_facepts2, i64 %__impl_foreach_index_f.0)
  %output123 = call i64* @"append@[II"(i64* %indices.1, i64 %return120)
  %output126 = call double* @"append@[FF"(double* %weights.2, double %faceweight.0)
  %output128 = add i64 %__impl_foreach_index_f.0, 1
  br label %cond111

end116:                                           ; preds = %cond111
  store i64* %indices.1, i64** %_bound_sourcept_indices
  store double* %weights.2, double** %_bound_sourcept_weights
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #1

; Function Attrs: nounwind
declare i64* @"pointprims@[III"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"inprimgroup@IISI"(i64, i8*, i64) #2

; Function Attrs: nounwind
declare i64 @"primintrinsic@IISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #1

; Function Attrs: nounwind
declare i64* @"append@[II"(i64*, i64) #2

; Function Attrs: nounwind
declare i64 @"sum@I[I"(i64*) #2

; Function Attrs: nounwind readnone
declare i64* @"array@[I:I"(i64) #1

; Function Attrs: nounwind readnone
declare double* @"array@[F:F"(double) #1

; Function Attrs: nounwind
declare double* @"append@[FF"(double*, double) #2

; Function Attrs: nounwind
define void @__vex_snippet(i64* %edgeneighbours, i64* %facepts, i64 %isclosed, i64 %isboundarypt, i64 %ptnum, i64* %sourcept_indices, double* %sourcept_weights) #2 {
__llvm_entry:
  %"<sourcept_indices>" = alloca i64*
  %"<sourcept_weights>" = alloca double*
  %0 = alloca i64*
  %1 = alloca i64*
  %2 = alloca i64
  %3 = alloca i64
  %4 = alloca i64
  store i64* %sourcept_indices, i64** %"<sourcept_indices>"
  store double* %sourcept_weights, double** %"<sourcept_weights>"
  store i64* %edgeneighbours, i64** %0
  store i64* %facepts, i64** %1
  store i64 %isclosed, i64* %2
  store i64 %isboundarypt, i64* %3
  store i64 %ptnum, i64* %4
  call void @"__vex_snippet_snippet@[I[IIII[I[F"(i64** %0, i64** %1, i64* %2, i64* %3, i64* %4, i64** %"<sourcept_indices>", double** %"<sourcept_weights>")
  %gvalue = call i64* @"_export@[IS[I"(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @4, i64 0, i64 0), i64* %edgeneighbours) #3
  %gvalue7 = call i64* @"_export@[IS[I"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @5, i64 0, i64 0), i64* %facepts) #3
  %gvalue9 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @6, i64 0, i64 0), i64 %isclosed) #3
  %gvalue11 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @7, i64 0, i64 0), i64 %isboundarypt) #3
  %gvalue13 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @8, i64 0, i64 0), i64 %ptnum) #3
  %evalue14 = load i64*, i64** %"<sourcept_indices>"
  %gvalue15 = call i64* @"_export@[IS[I"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @9, i64 0, i64 0), i64* %evalue14) #3
  %evalue16 = load double*, double** %"<sourcept_weights>"
  %gvalue17 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @10, i64 0, i64 0), double* %evalue16) #3
  store i64* %gvalue, i64** @edgeneighbours
  store i64* %gvalue7, i64** @facepts
  store i64 %gvalue9, i64* @isclosed
  store i64 %gvalue11, i64* @isboundarypt
  store i64 %gvalue13, i64* @ptnum
  store i64* %gvalue15, i64** @sourcept_indices
  store double* %gvalue17, double** @sourcept_weights
  ret void
}

declare i64* @"_export@[IS[I"(i8*, i64*)

declare i64 @"_export@ISI"(i8*, i64)

declare double* @"_export@[FS[F"(i8*, double*)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64* getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), i64* getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), i64 0, i64 0, i64 0, i64* getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), double* getelementptr inbounds ([0 x double], [0 x double]* @3, i64 0, i64 0))
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.531"}
!2 = !{!"64"}

;_code_end
