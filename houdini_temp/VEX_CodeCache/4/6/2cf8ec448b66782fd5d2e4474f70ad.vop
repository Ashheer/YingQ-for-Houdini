;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [0 x i64] zeroinitializer
@1 = private constant [0 x double] zeroinitializer
@2 = private constant [9 x i8] c"../depth\00"
@3 = private constant [8 x i8] c"../self\00"
@4 = private constant [18 x i8] c"../computeweights\00"
@5 = private constant [16 x i8] c"../neighbouring\00"
@ptnum = external global i64
@ptindices = external global i64*
@ptweights = external global double*
@6 = private constant [6 x i8] c"ptnum\00"
@7 = private constant [10 x i8] c"ptindices\00"
@8 = private constant [10 x i8] c"ptweights\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@I[I[F"(i64* %_bound_ptnum, i64** %_bound_ptindices, double** %_bound_ptweights) #0 {
__llvm_entry:
  %weights = alloca double*
  %0 = alloca i64
  %1 = alloca i64
  %2 = alloca i64
  %3 = alloca i64
  %4 = alloca i64
  store double* getelementptr inbounds ([0 x double], [0 x double]* @1, i64 0, i64 0), double** %weights
  %return = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @2, i64 0, i64 0))
  %return1 = call i64 @"chi@IS"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @3, i64 0, i64 0))
  %return2 = call i64 @"chi@IS"(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @4, i64 0, i64 0))
  %return3 = call i64 @"chi@IS"(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @5, i64 0, i64 0))
  %return4 = call i64 @"eq@III"(i64 %return3, i64 0)
  %5 = icmp ne i64 %return4, 0
  store i64 0, i64* %0
  %_bound_ptnum5 = load i64, i64* %_bound_ptnum
  store i64 %_bound_ptnum5, i64* %1
  store i64 %return, i64* %2
  store i64 %return1, i64* %3
  store i64 %return2, i64* %4
  br i1 %5, label %true, label %false

true:                                             ; preds = %__llvm_entry
  %pointNeighboursByEdges = call i64* @"pointNeighboursByEdges@[IIIIII[F"(i64* %0, i64* %1, i64* %2, i64* %3, i64* %4, double** %weights)
  br label %end

false:                                            ; preds = %__llvm_entry
  %pointNeighboursByPrims = call i64* @"pointNeighboursByPrims@[IIIIII[F"(i64* %0, i64* %1, i64* %2, i64* %3, i64* %4, double** %weights)
  br label %end

end:                                              ; preds = %false, %true
  %pts.0 = phi i64* [ %pointNeighboursByEdges, %true ], [ %pointNeighboursByPrims, %false ]
  store i64* %pts.0, i64** %_bound_ptindices
  %weights14 = load double*, double** %weights
  store double* %weights14, double** %_bound_ptweights
  ret void
}

; Function Attrs: alwaysinline nounwind
define private i64* @"pointNeighboursByEdges@[IIIIII[F"(i64* %input, i64* %ptindex, i64* %depth, i64* %includeself, i64* %computeweights, double** %weights) #0 {
__llvm_entry:
  %ptindex1 = load i64, i64* %ptindex
  %return = call i64* @"array@[I:I"(i64 %ptindex1)
  %computeweights2 = load i64, i64* %computeweights
  %includeself3 = load i64, i64* %includeself
  %return4 = call i64 @"and@III"(i64 %computeweights2, i64 %includeself3)
  %0 = icmp ne i64 %return4, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %weights5 = load double*, double** %weights
  %output = call double* @"append@[FF"(double* %weights5, double 0.000000e+00)
  store double* %output, double** %weights
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %depth6 = load i64, i64* %depth
  %cast = sitofp i64 %depth6 to double
  %output7 = call double @"div@FF"(double 1.000000e+00, double %cast)
  br label %cond

cond:                                             ; preds = %end20, %end
  %lastpts.0 = phi i64* [ %return, %end ], [ %newpts.0, %end20 ]
  %i.0 = phi i64 [ 0, %end ], [ %output68, %end20 ]
  %pts.0 = phi i64* [ %return, %end ], [ %pts.1, %end20 ]
  %depth10 = load i64, i64* %depth
  %return11 = call i64 @"lt@III"(i64 %i.0, i64 %depth10)
  %1 = icmp ne i64 %return11, 0
  br i1 %1, label %body, label %end12

body:                                             ; preds = %cond
  %return14 = call i64 @"len@I[I"(i64* %lastpts.0)
  br label %cond15

end12:                                            ; preds = %cond
  %includeself69 = load i64, i64* %includeself
  %2 = icmp ne i64 %includeself69, 0
  br i1 %2, label %true70, label %end71

cond15:                                           ; preds = %end35, %body
  %newpts.0 = phi i64* [ getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), %body ], [ %newpts.1, %end35 ]
  %__impl_foreach_index_8.0 = phi i64 [ 0, %body ], [ %output65, %end35 ]
  %pts.1 = phi i64* [ %pts.0, %body ], [ %pts.2, %end35 ]
  %return19 = call i64 @"lt@III"(i64 %__impl_foreach_index_8.0, i64 %return14)
  %3 = icmp ne i64 %return19, 0
  br i1 %3, label %body16, label %end20

body16:                                           ; preds = %cond15
  %return24 = call i64 @"getcomp@I[II"(i64* %lastpts.0, i64 %__impl_foreach_index_8.0)
  %input25 = load i64, i64* %input
  %return27 = call i64* @"neighbours@[III"(i64 %input25, i64 %return24)
  %return29 = call i64 @"len@I[I"(i64* %return27)
  br label %cond30

end20:                                            ; preds = %cond15
  %output68 = add i64 %i.0, 1
  br label %cond

cond30:                                           ; preds = %end45, %body16
  %newpts.1 = phi i64* [ %newpts.0, %body16 ], [ %newpts.2, %end45 ]
  %__impl_foreach_index_7.0 = phi i64 [ 0, %body16 ], [ %output63, %end45 ]
  %pts.2 = phi i64* [ %pts.1, %body16 ], [ %pts.3, %end45 ]
  %return34 = call i64 @"lt@III"(i64 %__impl_foreach_index_7.0, i64 %return29)
  %4 = icmp ne i64 %return34, 0
  br i1 %4, label %body31, label %end35

body31:                                           ; preds = %cond30
  %return39 = call i64 @"getcomp@I[II"(i64* %return27, i64 %__impl_foreach_index_7.0)
  %return42 = call i64 @"find@I[II"(i64* %pts.2, i64 %return39)
  %return43 = call i64 @"lt@III"(i64 %return42, i64 0)
  %5 = icmp ne i64 %return43, 0
  br i1 %5, label %true44, label %end45

end35:                                            ; preds = %cond30
  %output65 = add i64 %__impl_foreach_index_8.0, 1
  br label %cond15

true44:                                           ; preds = %body31
  %output48 = call i64* @"append@[II"(i64* %pts.2, i64 %return39)
  %output51 = call i64* @"append@[II"(i64* %newpts.1, i64 %return39)
  %computeweights52 = load i64, i64* %computeweights
  %6 = icmp ne i64 %computeweights52, 0
  br i1 %6, label %true53, label %end45

end45:                                            ; preds = %true44, %true53, %body31
  %newpts.2 = phi i64* [ %output51, %true53 ], [ %output51, %true44 ], [ %newpts.1, %body31 ]
  %pts.3 = phi i64* [ %output48, %true53 ], [ %output48, %true44 ], [ %pts.2, %body31 ]
  %output63 = add i64 %__impl_foreach_index_7.0, 1
  br label %cond30

true53:                                           ; preds = %true44
  %weights55 = load double*, double** %weights
  %cast57 = sitofp i64 %i.0 to double
  %output58 = fadd double 1.000000e+00, %cast57
  %output60 = fmul double %output58, %output7
  %output61 = call double* @"append@[FF"(double* %weights55, double %output60)
  store double* %output61, double** %weights
  br label %end45

true70:                                           ; preds = %end12
  br label %UnifiedReturnBlock

end71:                                            ; preds = %end12
  %return74 = call i64* @"slice@[I[IIIIIII"(i64* %pts.0, i64 1, i64 1, i64 0, i64 0, i64 0, i64 0)
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end71, %true70
  %UnifiedRetVal = phi i64* [ %pts.0, %true70 ], [ %return74, %end71 ]
  ret i64* %UnifiedRetVal
}

; Function Attrs: nounwind readnone
declare i64* @"array@[I:I"(i64) #1

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #1

; Function Attrs: nounwind
declare double* @"append@[FF"(double*, double) #2

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: nounwind readnone
declare i64 @"lt@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"len@I[I"(i64*) #1

; Function Attrs: nounwind readnone
declare i64 @"getcomp@I[II"(i64*, i64) #1

; Function Attrs: nounwind
declare i64* @"neighbours@[III"(i64, i64) #2

; Function Attrs: nounwind
declare i64 @"find@I[II"(i64*, i64) #2

; Function Attrs: nounwind
declare i64* @"append@[II"(i64*, i64) #2

; Function Attrs: nounwind
declare i64* @"slice@[I[IIIIIII"(i64*, i64, i64, i64, i64, i64, i64) #2

; Function Attrs: alwaysinline nounwind
define private i64* @"pointNeighboursByPrims@[IIIIII[F"(i64* %input, i64* %ptindex, i64* %depth, i64* %includeself, i64* %computeweights, double** %weights) #0 {
__llvm_entry:
  %ptindex1 = load i64, i64* %ptindex
  %return = call i64* @"array@[I:I"(i64 %ptindex1)
  %computeweights2 = load i64, i64* %computeweights
  %includeself3 = load i64, i64* %includeself
  %return4 = call i64 @"and@III"(i64 %computeweights2, i64 %includeself3)
  %0 = icmp ne i64 %return4, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %weights5 = load double*, double** %weights
  %output = call double* @"append@[FF"(double* %weights5, double 0.000000e+00)
  store double* %output, double** %weights
  br label %end

end:                                              ; preds = %true, %__llvm_entry
  %depth6 = load i64, i64* %depth
  %cast = sitofp i64 %depth6 to double
  %output7 = call double @"div@FF"(double 1.000000e+00, double %cast)
  br label %cond

cond:                                             ; preds = %end76, %end
  %lastpts.0 = phi i64* [ %return, %end ], [ %newpts.3, %end76 ]
  %i.0 = phi i64 [ 0, %end ], [ %output143, %end76 ]
  %pts.0 = phi i64* [ %return, %end ], [ %pts.4, %end76 ]
  %depth10 = load i64, i64* %depth
  %return11 = call i64 @"lt@III"(i64 %i.0, i64 %depth10)
  %1 = icmp ne i64 %return11, 0
  br i1 %1, label %body, label %end12

body:                                             ; preds = %cond
  %return14 = call i64 @"len@I[I"(i64* %lastpts.0)
  br label %cond15

end12:                                            ; preds = %cond
  %weights144 = load double*, double** %weights
  %return145 = call double @"max@F[F"(double* %weights144)
  %output146 = call double @"div@FF"(double 1.000000e+00, double %return145)
  %weights147 = load double*, double** %weights
  %return148 = call i64 @"len@I[F"(double* %weights147)
  br label %cond150

cond15:                                           ; preds = %end35, %body
  %newpts.0 = phi i64* [ getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), %body ], [ %newpts.1, %end35 ]
  %__impl_foreach_index_a.0 = phi i64 [ 0, %body ], [ %output67, %end35 ]
  %pts.1 = phi i64* [ %pts.0, %body ], [ %pts.2, %end35 ]
  %return19 = call i64 @"lt@III"(i64 %__impl_foreach_index_a.0, i64 %return14)
  %2 = icmp ne i64 %return19, 0
  br i1 %2, label %body16, label %end20

body16:                                           ; preds = %cond15
  %return24 = call i64 @"getcomp@I[II"(i64* %lastpts.0, i64 %__impl_foreach_index_a.0)
  %input25 = load i64, i64* %input
  %return27 = call i64* @"neighbours@[III"(i64 %input25, i64 %return24)
  %return29 = call i64 @"len@I[I"(i64* %return27)
  br label %cond30

end20:                                            ; preds = %cond15
  br label %cond71

cond30:                                           ; preds = %end45, %body16
  %newpts.1 = phi i64* [ %newpts.0, %body16 ], [ %newpts.2, %end45 ]
  %__impl_foreach_index_9.0 = phi i64 [ 0, %body16 ], [ %output65, %end45 ]
  %pts.2 = phi i64* [ %pts.1, %body16 ], [ %pts.3, %end45 ]
  %return34 = call i64 @"lt@III"(i64 %__impl_foreach_index_9.0, i64 %return29)
  %3 = icmp ne i64 %return34, 0
  br i1 %3, label %body31, label %end35

body31:                                           ; preds = %cond30
  %return39 = call i64 @"getcomp@I[II"(i64* %return27, i64 %__impl_foreach_index_9.0)
  %return42 = call i64 @"find@I[II"(i64* %pts.2, i64 %return39)
  %return43 = call i64 @"lt@III"(i64 %return42, i64 0)
  %4 = icmp ne i64 %return43, 0
  br i1 %4, label %true44, label %end45

end35:                                            ; preds = %cond30
  %output67 = add i64 %__impl_foreach_index_a.0, 1
  br label %cond15

true44:                                           ; preds = %body31
  %output48 = call i64* @"append@[II"(i64* %pts.2, i64 %return39)
  %output51 = call i64* @"append@[II"(i64* %newpts.1, i64 %return39)
  %computeweights52 = load i64, i64* %computeweights
  %5 = icmp ne i64 %computeweights52, 0
  br i1 %5, label %true53, label %end45

end45:                                            ; preds = %true44, %true53, %body31
  %newpts.2 = phi i64* [ %output51, %true53 ], [ %output51, %true44 ], [ %newpts.1, %body31 ]
  %pts.3 = phi i64* [ %output48, %true53 ], [ %output48, %true44 ], [ %pts.2, %body31 ]
  %output65 = add i64 %__impl_foreach_index_9.0, 1
  br label %cond30

true53:                                           ; preds = %true44
  %weights55 = load double*, double** %weights
  %cast58 = sitofp i64 %i.0 to double
  %output59 = fadd double 1.000000e+00, %cast58
  %output60 = fmul double 0x3FE6A09E667F3BCC, %output59
  %output62 = fmul double %output60, %output7
  %output63 = call double* @"append@[FF"(double* %weights55, double %output62)
  store double* %output63, double** %weights
  br label %end45

cond71:                                           ; preds = %end91, %end20
  %newpts.3 = phi i64* [ %newpts.0, %end20 ], [ %newpts.4, %end91 ]
  %__impl_foreach_index_d.0 = phi i64 [ 0, %end20 ], [ %output140, %end91 ]
  %pts.4 = phi i64* [ %pts.1, %end20 ], [ %pts.5, %end91 ]
  %return75 = call i64 @"lt@III"(i64 %__impl_foreach_index_d.0, i64 %return14)
  %6 = icmp ne i64 %return75, 0
  br i1 %6, label %body72, label %end76

body72:                                           ; preds = %cond71
  %return80 = call i64 @"getcomp@I[II"(i64* %lastpts.0, i64 %__impl_foreach_index_d.0)
  %input81 = load i64, i64* %input
  %return83 = call i64* @"pointprims@[III"(i64 %input81, i64 %return80)
  %return85 = call i64 @"len@I[I"(i64* %return83)
  br label %cond86

end76:                                            ; preds = %cond71
  %output143 = add i64 %i.0, 1
  br label %cond

cond86:                                           ; preds = %end108, %body72
  %newpts.4 = phi i64* [ %newpts.3, %body72 ], [ %newpts.5, %end108 ]
  %__impl_foreach_index_c.0 = phi i64 [ 0, %body72 ], [ %output138, %end108 ]
  %pts.5 = phi i64* [ %pts.4, %body72 ], [ %pts.6, %end108 ]
  %return90 = call i64 @"lt@III"(i64 %__impl_foreach_index_c.0, i64 %return85)
  %7 = icmp ne i64 %return90, 0
  br i1 %7, label %body87, label %end91

body87:                                           ; preds = %cond86
  %return95 = call i64 @"getcomp@I[II"(i64* %return83, i64 %__impl_foreach_index_c.0)
  %input97 = load i64, i64* %input
  %return99 = call i64* @"primpoints@[III"(i64 %input97, i64 %return95)
  %return102 = call i64 @"len@I[I"(i64* %return99)
  br label %cond103

end91:                                            ; preds = %cond86
  %output140 = add i64 %__impl_foreach_index_d.0, 1
  br label %cond71

cond103:                                          ; preds = %end118, %body87
  %newpts.5 = phi i64* [ %newpts.4, %body87 ], [ %newpts.6, %end118 ]
  %__impl_foreach_index_b.0 = phi i64 [ 0, %body87 ], [ %output136, %end118 ]
  %pts.6 = phi i64* [ %pts.5, %body87 ], [ %pts.7, %end118 ]
  %return107 = call i64 @"lt@III"(i64 %__impl_foreach_index_b.0, i64 %return102)
  %8 = icmp ne i64 %return107, 0
  br i1 %8, label %body104, label %end108

body104:                                          ; preds = %cond103
  %return112 = call i64 @"getcomp@I[II"(i64* %return99, i64 %__impl_foreach_index_b.0)
  %return115 = call i64 @"find@I[II"(i64* %pts.6, i64 %return112)
  %return116 = call i64 @"lt@III"(i64 %return115, i64 0)
  %9 = icmp ne i64 %return116, 0
  br i1 %9, label %true117, label %end118

end108:                                           ; preds = %cond103
  %output138 = add i64 %__impl_foreach_index_c.0, 1
  br label %cond86

true117:                                          ; preds = %body104
  %output121 = call i64* @"append@[II"(i64* %pts.6, i64 %return112)
  %output124 = call i64* @"append@[II"(i64* %newpts.5, i64 %return112)
  %computeweights125 = load i64, i64* %computeweights
  %10 = icmp ne i64 %computeweights125, 0
  br i1 %10, label %true126, label %end118

end118:                                           ; preds = %true117, %true126, %body104
  %newpts.6 = phi i64* [ %output124, %true126 ], [ %output124, %true117 ], [ %newpts.5, %body104 ]
  %pts.7 = phi i64* [ %output121, %true126 ], [ %output121, %true117 ], [ %pts.6, %body104 ]
  %output136 = add i64 %__impl_foreach_index_b.0, 1
  br label %cond103

true126:                                          ; preds = %true117
  %weights128 = load double*, double** %weights
  %cast130 = sitofp i64 %i.0 to double
  %output131 = fadd double 1.000000e+00, %cast130
  %output133 = fmul double %output131, %output7
  %output134 = call double* @"append@[FF"(double* %weights128, double %output133)
  store double* %output134, double** %weights
  br label %end118

cond150:                                          ; preds = %body151, %end12
  %i149.0 = phi i64 [ 0, %end12 ], [ %output167, %body151 ]
  %return154 = call i64 @"lt@III"(i64 %i149.0, i64 %return148)
  %11 = icmp ne i64 %return154, 0
  br i1 %11, label %body151, label %end155

body151:                                          ; preds = %cond150
  %weights158 = load double*, double** %weights
  %return160 = call double @"getcomp@F[FI"(double* %weights158, i64 %i149.0)
  %output162 = fmul double %return160, %output146
  %return163 = call { double, double* } @"setcomp@F[FFI"(double* %weights158, double %output162, i64 %i149.0)
  %output165 = extractvalue { double, double* } %return163, 1
  store double* %output165, double** %weights
  %output167 = add i64 %i149.0, 1
  br label %cond150

end155:                                           ; preds = %cond150
  %includeself168 = load i64, i64* %includeself
  %12 = icmp ne i64 %includeself168, 0
  br i1 %12, label %true169, label %end170

true169:                                          ; preds = %end155
  br label %UnifiedReturnBlock

end170:                                           ; preds = %end155
  %return173 = call i64* @"slice@[I[IIIIIII"(i64* %pts.0, i64 1, i64 1, i64 0, i64 0, i64 0, i64 0)
  br label %UnifiedReturnBlock

UnifiedReturnBlock:                               ; preds = %end170, %true169
  %UnifiedRetVal = phi i64* [ %pts.0, %true169 ], [ %return173, %end170 ]
  ret i64* %UnifiedRetVal
}

; Function Attrs: nounwind
declare i64* @"pointprims@[III"(i64, i64) #2

; Function Attrs: nounwind
declare i64* @"primpoints@[III"(i64, i64) #2

; Function Attrs: nounwind
declare double @"max@F[F"(double*) #2

; Function Attrs: nounwind readnone
declare i64 @"len@I[F"(double*) #1

; Function Attrs: nounwind readnone
declare double @"getcomp@F[FI"(double*, i64) #1

; Function Attrs: nounwind readnone
declare { double, double* } @"setcomp@F[FFI"(double*, double, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #1

; Function Attrs: nounwind
define void @__vex_snippet(i64 %ptnum, i64* %ptindices, double* %ptweights) #2 {
__llvm_entry:
  %"<ptindices>" = alloca i64*
  %"<ptweights>" = alloca double*
  %0 = alloca i64
  store i64* %ptindices, i64** %"<ptindices>"
  store double* %ptweights, double** %"<ptweights>"
  store i64 %ptnum, i64* %0
  call void @"__vex_snippet_snippet@I[I[F"(i64* %0, i64** %"<ptindices>", double** %"<ptweights>")
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @6, i64 0, i64 0), i64 %ptnum) #3
  %evalue2 = load i64*, i64** %"<ptindices>"
  %gvalue3 = call i64* @"_export@[IS[I"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @7, i64 0, i64 0), i64* %evalue2) #3
  %evalue4 = load double*, double** %"<ptweights>"
  %gvalue5 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @8, i64 0, i64 0), double* %evalue4) #3
  store i64 %gvalue, i64* @ptnum
  store i64* %gvalue3, i64** @ptindices
  store double* %gvalue5, double** @ptweights
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

declare i64* @"_export@[IS[I"(i8*, i64*)

declare double* @"_export@[FS[F"(i8*, double*)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0, i64* getelementptr inbounds ([0 x i64], [0 x i64]* @0, i64 0, i64 0), double* getelementptr inbounds ([0 x double], [0 x double]* @1, i64 0, i64 0))
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.531"}
!2 = !{!"64"}

;_code_end
