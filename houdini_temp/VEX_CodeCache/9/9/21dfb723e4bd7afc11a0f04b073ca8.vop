;_name	<vexpression>
; ModuleID = '__vex_snippet'
source_filename = "__vex_snippet"

@0 = private constant [12 x i8] c"../outputwn\00"
@1 = private constant [17 x i8] c"../promotetoprim\00"
@2 = private constant [25 x i8] c"../windingnumber1/attrib\00"
@3 = private constant [16 x i8] c"../assolidangle\00"
@4 = private constant [9 x i8] c"../ingeo\00"
@5 = private constant [9 x i8] c"../ongeo\00"
@6 = private constant [13 x i8] c"../threshold\00"
@7 = private constant [16 x i8] c"../reversegroup\00"
@8 = private constant [11 x i8] c"../mergeop\00"
@9 = private constant [12 x i8] c"../outgroup\00"
@10 = private constant [10 x i8] c"../outint\00"
@elemnum = external global i64
@opinput2_winding_number = external global double
@wn = external global double
@opinput1_winding_number = external global double
@outgrp = external global i64
@outattrib = external global i64
@11 = private constant [8 x i8] c"elemnum\00"
@12 = private constant [24 x i8] c"opinput2_winding_number\00"
@13 = private constant [3 x i8] c"wn\00"
@14 = private constant [24 x i8] c"opinput1_winding_number\00"
@15 = private constant [7 x i8] c"outgrp\00"
@16 = private constant [10 x i8] c"outattrib\00"

; Function Attrs: alwaysinline nounwind
define private void @"__vex_snippet_snippet@IFFFII"(i64* %_bound_elemnum, double* %_bound_opinput2_winding_number, double* %_bound_wn, double* %_bound_opinput1_winding_number, i64* %_bound_outgrp, i64* %_bound_outattrib) #0 {
__llvm_entry:
  %return = call i64 @"chi@IS"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @0, i64 0, i64 0))
  %0 = icmp ne i64 %return, 0
  br i1 %0, label %true, label %end

true:                                             ; preds = %__llvm_entry
  %return1 = call i64 @"chi@IS"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @1, i64 0, i64 0))
  %1 = icmp ne i64 %return1, 0
  br i1 %1, label %true2, label %false

end:                                              ; preds = %end3, %__llvm_entry
  %return9 = call i64 @"chi@IS"(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @1, i64 0, i64 0))
  %2 = icmp ne i64 %return9, 0
  br i1 %2, label %true10, label %false11

true2:                                            ; preds = %true
  %return4 = call i8* @"chs@SS"(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @2, i64 0, i64 0))
  %_bound_elemnum5 = load i64, i64* %_bound_elemnum
  %return6 = call double @"point@FISI"(i64 2, i8* %return4, i64 %_bound_elemnum5)
  br label %end3

false:                                            ; preds = %true
  %_bound_opinput2_winding_number7 = load double, double* %_bound_opinput2_winding_number
  br label %end3

end3:                                             ; preds = %false, %true2
  %windingNumber.0 = phi double [ %return6, %true2 ], [ %_bound_opinput2_winding_number7, %false ]
  store double %windingNumber.0, double* %_bound_wn
  br label %end

true10:                                           ; preds = %end
  %return13 = call i8* @"chs@SS"(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @2, i64 0, i64 0))
  %_bound_elemnum14 = load i64, i64* %_bound_elemnum
  %return15 = call double @"point@FISI"(i64 1, i8* %return13, i64 %_bound_elemnum14)
  br label %end12

false11:                                          ; preds = %end
  %_bound_opinput1_winding_number16 = load double, double* %_bound_opinput1_winding_number
  br label %end12

end12:                                            ; preds = %false11, %true10
  %normalizedWindingNumber.0 = phi double [ %return15, %true10 ], [ %_bound_opinput1_winding_number16, %false11 ]
  %return17 = call i64 @"chi@IS"(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @3, i64 0, i64 0))
  %3 = icmp ne i64 %return17, 0
  br i1 %3, label %true18, label %end19

true18:                                           ; preds = %end12
  %output = call double @"div@FF"(double %normalizedWindingNumber.0, double 0x401921FB4D12D84A)
  br label %end19

end19:                                            ; preds = %true18, %end12
  %normalizedWindingNumber.1 = phi double [ %output, %true18 ], [ %normalizedWindingNumber.0, %end12 ]
  %return22 = call double @"abs@FF"(double %normalizedWindingNumber.1)
  %return23 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @4, i64 0, i64 0))
  %return24 = call i64 @"chi@IS"(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @5, i64 0, i64 0))
  %return25 = call i64 @"and@III"(i64 %return23, i64 %return24)
  %4 = icmp ne i64 %return25, 0
  br i1 %4, label %true26, label %false27

true26:                                           ; preds = %end19
  %return30 = call double @"chf@FS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @6, i64 0, i64 0))
  %output31 = fsub double 5.000000e-01, %return30
  %return32 = fcmp ogt double %return22, %output31
  %return33 = zext i1 %return32 to i64
  br label %end28

false27:                                          ; preds = %end19
  %5 = icmp ne i64 %return23, 0
  br i1 %5, label %true35, label %end36

end28:                                            ; preds = %end36, %true43, %true26
  %outval.0 = phi i64 [ %return33, %true26 ], [ %return55, %true43 ], [ %outval.1, %end36 ]
  %return57 = call i64 @"chi@IS"(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @7, i64 0, i64 0))
  %return58 = xor i64 %outval.0, %return57
  %return59 = call i64 @"chi@IS"(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @8, i64 0, i64 0))
  %return60 = call i64 @"eq@III"(i64 %return59, i64 0)
  %6 = icmp ne i64 %return60, 0
  br i1 %6, label %end63, label %false62

true35:                                           ; preds = %false27
  %return38 = call double @"chf@FS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @6, i64 0, i64 0))
  %output39 = fadd double 5.000000e-01, %return38
  %return40 = fcmp ogt double %return22, %output39
  %return41 = zext i1 %return40 to i64
  br label %end36

end36:                                            ; preds = %true35, %false27
  %outval.1 = phi i64 [ %return41, %true35 ], [ 0, %false27 ]
  %7 = icmp ne i64 %return24, 0
  br i1 %7, label %true43, label %end28

true43:                                           ; preds = %end36
  %return46 = call double @"chf@FS"(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @6, i64 0, i64 0))
  %output47 = fsub double 5.000000e-01, %return46
  %return48 = fcmp ogt double %return22, %output47
  %return49 = zext i1 %return48 to i64
  %output52 = fadd double 5.000000e-01, %return46
  %return53 = fcmp olt double %return22, %output52
  %return54 = zext i1 %return53 to i64
  %return55 = call i64 @"and@III"(i64 %return49, i64 %return54)
  br label %end28

false62:                                          ; preds = %end28
  %return65 = call i64 @"eq@III"(i64 %return59, i64 1)
  %8 = icmp ne i64 %return65, 0
  br i1 %8, label %true66, label %false67

end63:                                            ; preds = %false75, %true82, %true74, %true66, %end28
  %outval.2 = phi i64 [ %return58, %end28 ], [ %return71, %true66 ], [ %return79, %true74 ], [ %return87, %true82 ], [ %return58, %false75 ]
  %return88 = call i64 @"chi@IS"(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @9, i64 0, i64 0))
  %9 = icmp ne i64 %return88, 0
  br i1 %9, label %true89, label %end90

true66:                                           ; preds = %false62
  %_bound_outgrp70 = load i64, i64* %_bound_outgrp
  %return71 = call i64 @"or@III"(i64 %return58, i64 %_bound_outgrp70)
  br label %end63

false67:                                          ; preds = %false62
  %return73 = call i64 @"eq@III"(i64 %return59, i64 2)
  %10 = icmp ne i64 %return73, 0
  br i1 %10, label %true74, label %false75

true74:                                           ; preds = %false67
  %_bound_outgrp78 = load i64, i64* %_bound_outgrp
  %return79 = call i64 @"and@III"(i64 %return58, i64 %_bound_outgrp78)
  br label %end63

false75:                                          ; preds = %false67
  %return81 = call i64 @"eq@III"(i64 %return59, i64 3)
  %11 = icmp ne i64 %return81, 0
  br i1 %11, label %true82, label %end63

true82:                                           ; preds = %false75
  %return85 = call i64 @"not@II"(i64 %return58)
  %_bound_outgrp86 = load i64, i64* %_bound_outgrp
  %return87 = call i64 @"and@III"(i64 %return85, i64 %_bound_outgrp86)
  br label %end63

true89:                                           ; preds = %end63
  store i64 %outval.2, i64* %_bound_outgrp
  br label %end90

end90:                                            ; preds = %true89, %end63
  %return92 = call i64 @"chi@IS"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @10, i64 0, i64 0))
  %12 = icmp ne i64 %return92, 0
  br i1 %12, label %true93, label %end94

true93:                                           ; preds = %end90
  store i64 %outval.2, i64* %_bound_outattrib
  br label %end94

end94:                                            ; preds = %true93, %end90
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @"chi@IS"(i8*) #1

; Function Attrs: nounwind readnone
declare i8* @"chs@SS"(i8*) #1

; Function Attrs: nounwind
declare double @"point@FISI"(i64, i8*, i64) #2

; Function Attrs: nounwind readnone
declare double @"div@FF"(double, double) #1

; Function Attrs: nounwind
declare double @"abs@FF"(double) #2

; Function Attrs: nounwind readnone
declare i64 @"and@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare double @"chf@FS"(i8*) #1

; Function Attrs: nounwind readnone
declare i64 @"eq@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"or@III"(i64, i64) #1

; Function Attrs: nounwind readnone
declare i64 @"not@II"(i64) #1

; Function Attrs: nounwind
define void @__vex_snippet(i64 %elemnum, double %opinput2_winding_number, double %wn, double %opinput1_winding_number, i64 %outgrp, i64 %outattrib) #2 {
__llvm_entry:
  %"<wn>" = alloca double
  %"<outgrp>" = alloca i64
  %"<outattrib>" = alloca i64
  %0 = alloca i64
  %1 = alloca double
  %2 = alloca double
  store double %wn, double* %"<wn>"
  store i64 %outgrp, i64* %"<outgrp>"
  store i64 %outattrib, i64* %"<outattrib>"
  store i64 %elemnum, i64* %0
  store double %opinput2_winding_number, double* %1
  store double %opinput1_winding_number, double* %2
  call void @"__vex_snippet_snippet@IFFFII"(i64* %0, double* %1, double* %"<wn>", double* %2, i64* %"<outgrp>", i64* %"<outattrib>")
  %gvalue = call i64 @"_export@ISI"(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @11, i64 0, i64 0), i64 %elemnum) #3
  %gvalue5 = call double @"_export@FSF"(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @12, i64 0, i64 0), double %opinput2_winding_number) #3
  %evalue6 = load double, double* %"<wn>"
  %gvalue7 = call double @"_export@FSF"(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @13, i64 0, i64 0), double %evalue6) #3
  %gvalue9 = call double @"_export@FSF"(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @14, i64 0, i64 0), double %opinput1_winding_number) #3
  %evalue10 = load i64, i64* %"<outgrp>"
  %gvalue11 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @15, i64 0, i64 0), i64 %evalue10) #3
  %evalue12 = load i64, i64* %"<outattrib>"
  %gvalue13 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @16, i64 0, i64 0), i64 %evalue12) #3
  store i64 %gvalue, i64* @elemnum
  store double %gvalue5, double* @opinput2_winding_number
  store double %gvalue7, double* @wn
  store double %gvalue9, double* @opinput1_winding_number
  store i64 %gvalue11, i64* @outgrp
  store i64 %gvalue13, i64* @outattrib
  ret void
}

declare i64 @"_export@ISI"(i8*, i64)

declare double @"_export@FSF"(i8*, double)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @__vex_snippet(i64 0, double 0.000000e+00, double 0.000000e+00, double 0.000000e+00, i64 0, i64 0)
  ret void
}

attributes #0 = { alwaysinline nounwind }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind }
attributes #3 = { nounwind readonly }

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = !{!"cvex"}
!1 = !{!"19.0.451"}
!2 = !{!"64"}

;_code_end
