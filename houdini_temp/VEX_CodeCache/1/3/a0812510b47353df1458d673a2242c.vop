;_name	/obj/geo1/init_population/attribvop1
; ModuleID = 'obj_geo1_init_population_attribvop1'

@0 = private constant [18 x i8] c"Number_Of_Circles\00"
@1 = private constant [0 x <3 x double>] zeroinitializer
@2 = private constant [0 x double] zeroinitializer
@3 = private constant [0 x <4 x double>] zeroinitializer
@ctr = external global <3 x double>*
@rad = external global double*
@rgba = external global <4 x double>*
@octr = external global <3 x double>*
@orad = external global double*
@orgba = external global <4 x double>*
@fitness = external global double
@numpt = external global i64
@oldfit = external global double
@error = external global double
@4 = private constant [4 x i8] c"ctr\00"
@5 = private constant [4 x i8] c"rad\00"
@6 = private constant [5 x i8] c"rgba\00"
@7 = private constant [5 x i8] c"octr\00"
@8 = private constant [5 x i8] c"orad\00"
@9 = private constant [6 x i8] c"orgba\00"
@10 = private constant [8 x i8] c"fitness\00"
@11 = private constant [6 x i8] c"numpt\00"
@12 = private constant [7 x i8] c"oldfit\00"
@13 = private constant [6 x i8] c"error\00"

define private void @"_obj_geo1_init_population_attribvop1_snippet1@[V[F[P[V[F[PFIFF"(<3 x double>** %_bound_ctr, double** %_bound_rad, <4 x double>** %_bound_rgba, <3 x double>** %_bound_octr, double** %_bound_orad, <4 x double>** %_bound_orgba, double* %_bound_fitness, i64* %_bound_numpt, double* %_bound_oldfit, double* %_bound_error) nounwind alwaysinline {
__llvm_entry:
  %return = call i64 @"chi@IS"(i8* getelementptr inbounds ([18 x i8]* @0, i64 0, i64 0))
  br label %cond

cond:                                             ; preds = %body, %__llvm_entry
  %i.0 = phi i64 [ 0, %__llvm_entry ], [ %output19, %body ]
  %rgba.0 = phi <4 x double>* [ getelementptr inbounds ([0 x <4 x double>]* @3, i64 0, i64 0), %__llvm_entry ], [ %output16, %body ]
  %rad.0 = phi double* [ getelementptr inbounds ([0 x double]* @2, i64 0, i64 0), %__llvm_entry ], [ %output13, %body ]
  %ctr.0 = phi <3 x double>* [ getelementptr inbounds ([0 x <3 x double>]* @1, i64 0, i64 0), %__llvm_entry ], [ %output10, %body ]
  %return3 = call i64 @"lt@III"(i64 %i.0, i64 %return)
  %0 = icmp ne i64 %return3, 0
  br i1 %0, label %body, label %end

body:                                             ; preds = %cond
  %return4 = call <3 x double> @"nrandom@V"()
  %return5 = call <3 x double> @"fit01@VVVV"(<3 x double> %return4, <3 x double> <double -5.000000e-01, double -5.000000e-01, double 0.000000e+00>, <3 x double> <double 5.000000e-01, double 5.000000e-01, double 0.000000e+00>)
  %return6 = call double @"nrandom@F"()
  %output = fmul double %return6, 1.500000e-01
  %return7 = call <4 x double> @"nrandom@P"()
  %output10 = call <3 x double>* @"push@[VV"(<3 x double>* %ctr.0, <3 x double> %return5)
  %output13 = call double* @"push@[FF"(double* %rad.0, double %output)
  %output16 = call <4 x double>* @"push@[PP"(<4 x double>* %rgba.0, <4 x double> %return7)
  %output19 = add i64 %i.0, 1
  br label %cond

end:                                              ; preds = %cond
  store <3 x double>* %ctr.0, <3 x double>** %_bound_ctr
  store double* %rad.0, double** %_bound_rad
  store <4 x double>* %rgba.0, <4 x double>** %_bound_rgba
  store <3 x double>* %ctr.0, <3 x double>** %_bound_octr
  store double* %rad.0, double** %_bound_orad
  store <4 x double>* %rgba.0, <4 x double>** %_bound_orgba
  %_bound_numpt26 = load i64* %_bound_numpt
  %cast = sitofp i64 %_bound_numpt26 to double
  %output27 = call double @"div@FF"(double 1.000000e+00, double %cast)
  store double %output27, double* %_bound_fitness
  store double 0.000000e+00, double* %_bound_oldfit
  store double 1.000000e+09, double* %_bound_error
  ret void
}

declare i64 @"chi@IS"(i8*) nounwind readnone

declare i64 @"lt@III"(i64, i64) nounwind readnone

define private <3 x double> @"nrandom@V"() alwaysinline {
__llvm_entry:
  %t_0_ = call double @"nrandom@F"()
  %t_1_ = call double @"nrandom@F"()
  %t_2_ = call double @"nrandom@F"()
  %rw03 = call <3 x double> @"setcomp@VFI"(<3 x double> undef, double %t_0_, i64 0)
  %rw07 = call <3 x double> @"setcomp@VFI"(<3 x double> %rw03, double %t_1_, i64 1)
  %rw011 = call <3 x double> @"setcomp@VFI"(<3 x double> %rw07, double %t_2_, i64 2)
  ret <3 x double> %rw011
}

declare double @"nrandom@F"() nounwind

declare <3 x double> @"setcomp@VFI"(<3 x double>, double, i64) nounwind readnone

declare <3 x double> @"fit01@VVVV"(<3 x double>, <3 x double>, <3 x double>) nounwind

define private <4 x double> @"nrandom@P"() alwaysinline {
__llvm_entry:
  %t_0_ = call double @"nrandom@F"()
  %t_1_ = call double @"nrandom@F"()
  %t_2_ = call double @"nrandom@F"()
  %t_3_ = call double @"nrandom@F"()
  %rw03 = call <4 x double> @"setcomp@PFI"(<4 x double> undef, double %t_0_, i64 0)
  %rw07 = call <4 x double> @"setcomp@PFI"(<4 x double> %rw03, double %t_1_, i64 1)
  %rw011 = call <4 x double> @"setcomp@PFI"(<4 x double> %rw07, double %t_2_, i64 2)
  %rw015 = call <4 x double> @"setcomp@PFI"(<4 x double> %rw011, double %t_3_, i64 3)
  ret <4 x double> %rw015
}

declare <4 x double> @"setcomp@PFI"(<4 x double>, double, i64) nounwind readnone

declare <3 x double>* @"push@[VV"(<3 x double>*, <3 x double>) nounwind readnone

declare double* @"push@[FF"(double*, double) nounwind readnone

declare <4 x double>* @"push@[PP"(<4 x double>*, <4 x double>) nounwind readnone

declare double @"div@FF"(double, double) nounwind readnone

define void @obj_geo1_init_population_attribvop1(<3 x double>* %ctr, double* %rad, <4 x double>* %rgba, <3 x double>* %octr, double* %orad, <4 x double>* %orgba, double %fitness, i64 %numpt, double %oldfit, double %error) nounwind {
__llvm_entry:
  %"<rad>" = alloca double*
  %"<rgba>" = alloca <4 x double>*
  %"<octr>" = alloca <3 x double>*
  %"<orad>" = alloca double*
  %"<orgba>" = alloca <4 x double>*
  %"<fitness>" = alloca double
  %"<oldfit>" = alloca double
  %"<error>" = alloca double
  %0 = alloca i64
  %"<ctr>" = alloca <3 x double>*
  store <3 x double>* %ctr, <3 x double>** %"<ctr>"
  store double* %rad, double** %"<rad>"
  store <4 x double>* %rgba, <4 x double>** %"<rgba>"
  store <3 x double>* %octr, <3 x double>** %"<octr>"
  store double* %orad, double** %"<orad>"
  store <4 x double>* %orgba, <4 x double>** %"<orgba>"
  store double %fitness, double* %"<fitness>"
  store double %oldfit, double* %"<oldfit>"
  store double %error, double* %"<error>"
  store i64 %numpt, i64* %0
  call void @"_obj_geo1_init_population_attribvop1_snippet1@[V[F[P[V[F[PFIFF"(<3 x double>** %"<ctr>", double** %"<rad>", <4 x double>** %"<rgba>", <3 x double>** %"<octr>", double** %"<orad>", <4 x double>** %"<orgba>", double* %"<fitness>", i64* %0, double* %"<oldfit>", double* %"<error>")
  %evalue = load <3 x double>** %"<ctr>"
  %gvalue = call <3 x double>* @"_export@[VS[V"(i8* getelementptr inbounds ([4 x i8]* @4, i64 0, i64 0), <3 x double>* %evalue) nounwind readonly
  %evalue2 = load double** %"<rad>"
  %gvalue3 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([4 x i8]* @5, i64 0, i64 0), double* %evalue2) nounwind readonly
  %evalue4 = load <4 x double>** %"<rgba>"
  %gvalue5 = call <4 x double>* @"_export@[PS[P"(i8* getelementptr inbounds ([5 x i8]* @6, i64 0, i64 0), <4 x double>* %evalue4) nounwind readonly
  %evalue6 = load <3 x double>** %"<octr>"
  %gvalue7 = call <3 x double>* @"_export@[VS[V"(i8* getelementptr inbounds ([5 x i8]* @7, i64 0, i64 0), <3 x double>* %evalue6) nounwind readonly
  %evalue8 = load double** %"<orad>"
  %gvalue9 = call double* @"_export@[FS[F"(i8* getelementptr inbounds ([5 x i8]* @8, i64 0, i64 0), double* %evalue8) nounwind readonly
  %evalue10 = load <4 x double>** %"<orgba>"
  %gvalue11 = call <4 x double>* @"_export@[PS[P"(i8* getelementptr inbounds ([6 x i8]* @9, i64 0, i64 0), <4 x double>* %evalue10) nounwind readonly
  %evalue12 = load double* %"<fitness>"
  %gvalue13 = call double @"_export@FSF"(i8* getelementptr inbounds ([8 x i8]* @10, i64 0, i64 0), double %evalue12) nounwind readonly
  %gvalue15 = call i64 @"_export@ISI"(i8* getelementptr inbounds ([6 x i8]* @11, i64 0, i64 0), i64 %numpt) nounwind readonly
  %evalue16 = load double* %"<oldfit>"
  %gvalue17 = call double @"_export@FSF"(i8* getelementptr inbounds ([7 x i8]* @12, i64 0, i64 0), double %evalue16) nounwind readonly
  %evalue18 = load double* %"<error>"
  %gvalue19 = call double @"_export@FSF"(i8* getelementptr inbounds ([6 x i8]* @13, i64 0, i64 0), double %evalue18) nounwind readonly
  store <3 x double>* %gvalue, <3 x double>** @ctr
  store double* %gvalue3, double** @rad
  store <4 x double>* %gvalue5, <4 x double>** @rgba
  store <3 x double>* %gvalue7, <3 x double>** @octr
  store double* %gvalue9, double** @orad
  store <4 x double>* %gvalue11, <4 x double>** @orgba
  store double %gvalue13, double* @fitness
  store i64 %gvalue15, i64* @numpt
  store double %gvalue17, double* @oldfit
  store double %gvalue19, double* @error
  ret void
}

declare <3 x double>* @"_export@[VS[V"(i8*, <3 x double>*)

declare double* @"_export@[FS[F"(i8*, double*)

declare <4 x double>* @"_export@[PS[P"(i8*, <4 x double>*)

declare double @"_export@FSF"(i8*, double)

declare i64 @"_export@ISI"(i8*, i64)

define void @__shader_default_arguments() {
__llvm_entry:
  call void @obj_geo1_init_population_attribvop1(<3 x double>* getelementptr inbounds ([0 x <3 x double>]* @1, i64 0, i64 0), double* getelementptr inbounds ([0 x double]* @2, i64 0, i64 0), <4 x double>* getelementptr inbounds ([0 x <4 x double>]* @3, i64 0, i64 0), <3 x double>* getelementptr inbounds ([0 x <3 x double>]* @1, i64 0, i64 0), double* getelementptr inbounds ([0 x double]* @2, i64 0, i64 0), <4 x double>* getelementptr inbounds ([0 x <4 x double>]* @3, i64 0, i64 0), double 0.000000e+00, i64 0, double 0.000000e+00, double 0.000000e+00)
  ret void
}

!context = !{!0}
!version = !{!1}
!precision = !{!2}

!0 = metadata !{metadata !"cvex"}
!1 = metadata !{metadata !"18.5.633"}
!2 = metadata !{metadata !"64"}

;_code_end
