attribwrangle/snippet
	Color Random

	float seed = 0.99 + ch("seed");
	float r = hscript_rand ( @ptnum + seed + sin ( 13 * @ptnum + 19 * seed ) );

	float s = fit ( random ( 17 * @ptnum + 91 * seed ), 0, 1, ch("srangex"), ch("srangey"));
	s = ch("s") * ( 1 - ch("srand") ) + s * ch("srand") * ch("s");

	float val = fit ( random ( 173 * @ptnum + 11 * seed ), 0, 1, ch("vrangex"), ch("vrangey"));
	val = ch("v") * ( 1 - ch("vrand") ) + val * ch("vrand") * ch("v");

	@Cd = hsvtorgb ( ( r + 0.618033988749895 ) % 1, s, val );

attribwrangle/snippet

	Attribute Transfer
	//Attribute Transfer

	int handle = pcopen(@OpInput2, "P", @P, chf("rad"), chi("num"));
	vector lookup_P = pcfilter(handle, "P"); //Average P
	vector lookup_attrib = pcfilter(handle, chs("attrib")); //Average of attrib

	i@many = pcnumfound(handle);
	if(i@many>0){
	`chs("attrib_cast")` = lookup_attrib; //Supply the attribute you want to transfer
	v@P = lerp(v@P, lookup_P, chf("mix"));
	}

attribwrangle/snippet

	Add Normal
	@N = @N;


attribwrangle/snippet
	Convert to polyline

    	for(int i = 0; i< @numvtx; i++){
    
   	int vtx1,vtx2;
    	if(i<@numvtx-1){
    	vtx1 = i;
    	vtx2 = i+1;
    	}
    	else{
    	vtx1 = i;
    	vtx2 = 0;
    	}
    
    
    	int lvtx1 = vertexindex(0,@primnum,vtx1);
    	int pt1 = vertexpoint(0,lvtx1);
    
    	int lvtx2 = vertexindex(0,@primnum,vtx2);
    	int pt2 = vertexpoint(0,lvtx2);
    
    	int prim = addprim(0,“polyline”);
    	addvertex(0,prim,pt1);
    	addvertex(0,prim,pt2);
    	}
    
    	removeprim(0,@primnum,0);
    
    	//Convert to polgon to polyline. Use clean sop to remove overlap.
    	//Ends convert one primitive to one polyline。These code convert one segment to one polyline after that can do something foreach segment.




attribwrangle/snippet
	Convert sphere primitive intrinsic transform to pscale	

	matrix3 m3 = primintrinsic(0, 'transform', @primnum);

	vector extracted = cracktransform(0, 0, 2, { 0, 0, 0 }, m3);

	@pscale = max(extracted,max(extracted,extracted));


attribwrangle/snippet
	Clip

	float dotprod = dot(chv("clip_dir"),normalize(chv("clip_pos")-@P));

	if( dotprod > 0 )
	{
	removepoint(geoself(),@ptnum);
	}

attribwrangle/snippet
	PcfindFilter
	vector smoothfilter ( int input; int pts [ ]; float dist [ ]; string attrib )
	{
    	float sum = 0, w, d;
   	 vector value, result = 0;
    	float maxd = dist [ -1 ];
 	   int count = len ( pts );
   	 for ( int i = 0; i < count; ++i )
  	  {
  	      value = point ( input, attrib, pts [ i ] );
       	 w = 1 - smooth ( 0, 1.1 * maxd, dist [ i ] );
     	   sum += w;
    	    result += w * value;
  	  }
  	  result /= sum;
  	  return result;
	}

	float dists [ ] = { };
	int pts [ ] = pcfind ( 1, "P", @P, ch("r"), chi("maxpts"), dists );

	@Cd = smoothfilter ( 1, pts, dists, "Cd" );


attribwrangle/snippet
	Random orient
	vector axis=sample_direction_uniform(rand(@ptnum));
  
	float angle=ch("angle");
  
  	p@orient=quaternion(angle,axis);

attribwrangle/snippet
	Get min max
	//run over detail
	int pts[]=expandpointgroup(0,"*");
	float min,max;

	foreach(int pt;pts){

    		float ptmax=point(0,"__test",pt);
  		float ptmin=point(0,"__test",pt);
    
    		if(pt == 0){
        			min = ptmin;
        			max = ptmax;
    		}
    		else{
        			if(ptmax > max) max = ptmax;
        			else if(ptmin < min) min = ptmin;
    		}
	}

	f@min=min;
	f@max=max;